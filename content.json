{"meta":{"title":"zolanunu","subtitle":null,"description":"ohhhhhhh","author":"zolanunu","url":"http://zhangbuzola.cn"},"pages":[{"title":"关于博主","date":"un00fin00","updated":"un00fin00","comments":true,"path":"about/index.html","permalink":"http://zhangbuzola.cn/about/index.html","excerpt":"","text":"博主简介博主本科毕业于重庆西南大学，专业是计算机科学与技术，研究生现就读于哈尔滨工业大学深圳研究生院，计算机技术专业，实验室研究方向是生物信息。 2018年年底毕业，目前正在求职和准备毕业设计。这两个重要的事情，要在18年下半年完成，任重并努力中。 求职目标是：java后台开发，希望自己能找到属于自己位置的工作。 给自己的忠告：爱自己；努力，努力，再努力；踏实；知世故而不世故，见过生活凌厉，依然内心向暖。 爱情随缘，不再争取，身体和心里疗伤的过程中。 博客会一直更新，目前想进行主题的优化，博客内容不限于学习技术，会记录一些自己的生活点滴：感动和迷茫。沉淀自己，增添生活的仪式感。 平时的爱好：看书，看电影，听歌，美食，爱猫（目前养了一只三花猫咪：酸菜，是现在陪伴我最多的，我很爱她）。 喜欢简单的生活，正在学会独处。 期待更好的自己。"},{"title":"categories","date":"un44fin44","updated":"un44fin44","comments":true,"path":"categories/index.html","permalink":"http://zhangbuzola.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"un44fin44","updated":"un44fin44","comments":true,"path":"tags/index.html","permalink":"http://zhangbuzola.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/07/12/hello-world/","link":"","permalink":"http://zhangbuzola.cn/2018/07/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"2018年读书书单","slug":"2018读书书单","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2018/07/10/2018读书书单/","link":"","permalink":"http://zhangbuzola.cn/2018/07/10/2018读书书单/","excerpt":"","text":"技术类剑指offer 第2版 Java并发编程实战 设计模式之禅 EffectiveJava中文版 第2版 深入理解Java虚拟机 生活杂书在我的开始，是我的结束———————作者：方方 万箭穿心——————————————作者：方方 没有你什么都不甜蜜—————————作者：约恩.卡尔曼.斯特凡松 (Jon Kalman Stefanssom)","categories":[{"name":"生活轨迹","slug":"生活轨迹","permalink":"http://zhangbuzola.cn/categories/生活轨迹/"}],"tags":[{"name":"读书书单","slug":"读书书单","permalink":"http://zhangbuzola.cn/tags/读书书单/"},{"name":"2018","slug":"2018","permalink":"http://zhangbuzola.cn/tags/2018/"}]},{"title":"java基础学习之Thread类","slug":"java基础之Thread类","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2018/07/09/java基础之Thread类/","link":"","permalink":"http://zhangbuzola.cn/2018/07/09/java基础之Thread类/","excerpt":"","text":"Thread类继承结构1234567- java.lang.Object - java.lang.Thread实现的接口：Runnable直接实现子类：ForkJoinWorkerThreadpublic class Thread extends Object implements Runnable 源码 构造函数1234567Thread()Thread(Runnable target)Thread(Runnable target, String name)Thread(String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name)Thread(ThreadGroup group, String name) 源码分析https://docs.oracle.com/javase/8/docs/api/index.html Thread类中方法start()方法启动线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。 run()方法run()方法是不需要用户调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。 sleep()方法12sleep(long millis) //参数为毫秒sleep(long millis,int nanoseconds) //第一参数为毫秒，第二个参数为纳秒 sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。 如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread类的静态sleep()方法来实现。 当前线程调用sleep()方法进入阻塞状态后，在其睡眠时间内，该线程不会获得执行机会，即使系统中没有其他可执行线程，处于sleep()中的线程也不会执行，因此sleep()方法常用来暂停程序的执行 但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。看下面这个例子就清楚了： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test &#123; private int i = 10; private Object object = new Object(); public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread1 = test.new MyThread(); MyThread thread2 = test.new MyThread(); thread1.start(); thread2.start(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; synchronized (object) &#123; i++; System.out.println(&quot;i:&quot;+i); try &#123; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;进入睡眠状态&quot;); Thread.currentThread().sleep(10000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;睡眠结束&quot;); i++; System.out.println(&quot;i:&quot;+i); &#125; &#125; &#125;&#125;// --------------------------------i:11线程Thread-0 进入睡眠状态线程Thread-0 睡眠结束i:12i:13线程Thread-1 进入睡眠状态线程Thread-1 睡眠结束i:14 从上面输出结果可以看出，当Thread-0进入睡眠状态之后，Thread-1并没有去执行具体的任务。只有当Thread-0执行完之后，此时Thread-0释放了对象锁，Thread-1才开始执行。 注意，如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。 yield()方法yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态方法，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入到就绪状态。即让当前线程暂停一下，让系统的线程调度器重新调度一次，完全可能的情况是：当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。 调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，当某个线程调用了yield()方法之后，只有优先级与当前线程相同或者比当前线程更高的处于就绪状态的线程才会获得执行机会。 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。 join()方法123join()join(long millis) //参数为毫秒join(long millis,int nanoseconds) //第一参数为毫秒，第二个参数为纳秒 假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的事件。 123456789101112131415161718192021222324252627282930313233343536public class Test &#123; public static void main(String[] args) throws IOException &#123; System.out.println(&quot;进入线程&quot;+Thread.currentThread().getName()); Test test = new Test(); MyThread thread1 = test.new MyThread(); thread1.start(); try &#123; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;等待&quot;); thread1.join(); System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;继续执行&quot;); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;进入线程&quot;+Thread.currentThread().getName()); try &#123; Thread.currentThread().sleep(5000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;); &#125; &#125;&#125;// ------------------------进入线程main线程main等待进入线程Thread-0线程Thread-0执行完毕线程main继续执行 可以看出，当调用thread1.join()方法后，main线程会进入等待，然后等待thread1执行完之后再继续执行。 实际上调用join方法是调用了Object的wait方法，这个可以通过查看源码得知： wait方法会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限。 由于wait方法会让线程释放对象锁，所以join方法同样会让线程释放对一个对象持有的锁。具体的wait方法使用在后面文章中给出。 interrupt()方法interrupt，顾名思义，即中断的意思。单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。 下面看一个例子： 1234567891011121314151617181920212223242526272829303132public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println(&quot;进入睡眠状态&quot;); Thread.currentThread().sleep(10000); System.out.println(&quot;睡眠完毕&quot;); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;得到中断异常&quot;); &#125; System.out.println(&quot;run方法执行完毕&quot;); &#125; &#125;&#125;// ----------------进入睡眠状态得到中断异常run方法执行完毕 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+&quot; while循环&quot;); i++; &#125; &#125; &#125;&#125; 运行该程序会发现，while循环会一直运行直到变量i的值超出Integer.MAX_VALUE。所以说直接调用interrupt方法不能中断正在运行中的线程。 但是如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志位置为true，那么可以通过调用isInterrupted()判断中断标志是否被置位来中断线程的执行。比如下面这段代码： 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; while(!isInterrupted() &amp;&amp; i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+&quot; while循环&quot;); i++; &#125; &#125; &#125;&#125; 运行会发现，打印若干个值之后，while循环就停止打印了。 但是一般情况下不建议通过这种方式来中断线程，一般会在MyThread类中增加一个属性 isStop来标志是否结束while循环，然后再在while循环中判断isStop的值。 1234567891011121314class MyThread extends Thread&#123; private volatile boolean isStop = false; @Override public void run() &#123; int i = 0; while(!isStop)&#123; i++; &#125; &#125; public void setStop(boolean stop)&#123; this.isStop = stop; &#125; &#125; 那么就可以在外面通过调用setStop方法来终止while循环。 interrupted方法 interrupted()函数是Thread静态方法，用来检测当前线程的interrupt状态，检测完成后，状态清空。通过下面的interrupted源码我们能够知道，此方法首先调用isInterrupted方法，而isInterrupted方法是一个重载的native方法private native boolean isInterrupted(boolean ClearInterrupted) 通过方法的注释能够知道，用来测试线程是否已经中断，参数用来决定是否重置中断标志。 12345678910111213public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125;public boolean isInterrupted() &#123; return isInterrupted(false);&#125;/** * Tests if some Thread has been interrupted. The interrupted state * is reset or not based on the value of ClearInterrupted that is * passed. */private native boolean isInterrupted(boolean ClearInterrupted); stop方法stop方法已经是一个废弃的方法，它是一个不安全的方法。因为调用stop方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以stop方法基本是不会被用到的。 destroy方法destroy方法也是废弃的方法。基本不会被使用到。 以下是关系到线程属性的几个方法： 1234getId //用来得到线程IDgetName和setName //用来得到或者设置线程名称。getPriority和setPriority //用来获取和设置线程优先级。setDaemon和isDaemon // 用来设置线程是否成为守护线程和判断线程是否是守护线程。 用来设置线程是否成为守护线程和判断线程是否是守护线程。 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。 Thread类有一个比较常用的静态方法currentThread()用来获取当前线程。 参考https://blog.csdn.net/linxdcn/article/details/72819817?locationNum=13&amp;fps=1 Java8 中 ThreadLocal类和其他线程池","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"《我不是药神》我看到了什么","slug":"20180706我不是药神","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/07/06/20180706我不是药神/","link":"","permalink":"http://zhangbuzola.cn/2018/07/06/20180706我不是药神/","excerpt":"","text":"观影之前看这个电影之前，我大概看过了一些关于这部电影的解说，知道是一部良心电影。有的人能看哭，有的人看到了现实。其实关于药品安全问题，我是不太关心这种国家大事的吧，因为看了我只会觉得心累，见识不高，很难就这种大事有很高的见解，最多是为穷人感叹一下，无良商家只为挣钱这类的感性认识。再无其他。从近两年刷豆瓣和微博以后，知道很多人情冷暖，黑暗和光明的都有。这和之前自己很少和网络接触有关吧，活在一个没有网络的环境中，给自己制造了一个生活很美好，只有爱情和生活的琐事能伤到我的那种。too navie and too narrow。 观影泪点其实我不是药神，情节很正常，没有多少笑点，整个过程从一个中年大叔遇到离婚，孩子移民，父亲病危，没有任何可以舒缓的点，接着就是白血病人求药，卖药，遇到坏心人发现商机，警察也在调查，各种膈应人的事情不断，选择放弃卖药，然后就是一年后了。 一年后，看似中年大叔的生活在慢慢变好了，但是从一个女人的撕心裂肺开始以后，我的泪点触发到了。 成年人的爱情真的，不能明说，就算其实喜欢也不会去冲动追求。因为有太多的重担在身上。（程勇和慧的爱情） 有很多现实的点吧。比如说：法不容情；穷病是没办法治好的。让人真的很心疼，因为我就是处在一个穷的阶段吧。 中年大叔里面经常抱怨的就是医院就是杀人的地方。我其实很同意，看似救人的地方很冰冷。自己从爷爷住院，我进入医院，我就不喜欢医院的环境。 其他最深的感触就是，健康是你最大的资本。希望我爱的人和爱我的人身体健康，快乐可能很少，但是一定要身体健康。 再就是晚上自己在复习的期间在听喜马拉雅FM 竹子的广播，关于成熟人的爱情的一点点说法： 显然，“追”这个字已经过时了，现在大家都用“撩”。正如我在广播开头所说，无论男女，“追”这个行为好像在十八岁以后就结束了，那种痴傻的为对方写情书、往暗恋对象抽屉里塞巧克力的桥段，在成人的世界里是不存在的。 而随着年龄的渐长，你也会在当代约会市场中发现，每一位“成年人”的心房都不是那么容易打开的，要傻追，太容易吓跑脆弱的我们。于是，每个人都得学两手技巧，得知游戏的规则和技巧，面对心上人，才能从容的喘口气，拿出从过去的失败感情中总结的一切经验技巧，镇定应战。 你问我说，这样累不累啊？两个人喜欢对方，就不能坦诚相待么？我很遗憾的告诉你，从我个人的经验来看，随着年龄和阅历的增长，我们只会变的越来越复杂，过去种种“伤痕”让我们的心变的越来越封闭，我认真觉得，我们需要长一点时间的追逐，来看清对方的本来面目。我们也需要长一点的时间，静下来考验自己的内心，了解我们需不需要这段感情。","categories":[{"name":"生活轨迹","slug":"生活轨迹","permalink":"http://zhangbuzola.cn/categories/生活轨迹/"}],"tags":[{"name":"观影记","slug":"观影记","permalink":"http://zhangbuzola.cn/tags/观影记/"}]},{"title":"再见，不再见，六月","slug":"2018上半年总结","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/07/05/2018上半年总结/","link":"","permalink":"http://zhangbuzola.cn/2018/07/05/2018上半年总结/","excerpt":"秘密","text":"秘密 Incorrect Password! No content to display! U2FsdGVkX19X7ZLZp5nQzt2XHqmb7wS31e7ubp8b8DRcrefr0HicUoCB5sU2ygZqXTtAmodjA9Rlzs8jmxlFGhCXgYD9ZAE1h3lDc+EcusDjhFJpaxxoaLa3hfxzdwBpVcdQNQBY+CyOD5ZJqyRM5tXvql9EPRYfsapaxtKXqwlkrL0G7EyvQ5RCo5PdlX294+iuk2w62SJbvCWqx1/TqGe1ZfKfAqc2Bj6S/st3A95kgmKgNpuPHPr8V/90JA5Tp4c4h6Unmel/qvy3QzsNz9rZw3dBhsyM8/JowskeAOAEO9yecfC+LjofXludi/ehlYva0RgqxXZ+e60BrA4CH6yoPDWc7GcsuxLNChOSTu/NlFmnMRmXR+x0niQCmvNM6OOKvf1d+nSVDAe+Vr331SdrJ3yQX0AwdR0X3AdVvrJSWl3dLNAVLfyqgMfbKufmvsVCLfoNauD593tArHn49l9cc3UlQyc86FxgXO4yqVlk2G4SjSpn+0sW2hnJ285od+VdzxTJHpiLZmXZe1G28oEisYj3xTxZolmzsblUoIrgvRIl9gF/RCxkfWnkrM9GhyLkq2NfEWRw9erCi7Gip4P6vkkCtIoqbYTubtQNMvdhGCpN8EsvXKQzpvLZVjwMU0mr+hPcBKwVTiRveB+QYJCjYMfyJF7uVt2s56+iVSWMxK2ReWB7zHrPoo4LQxc2upJyLhlGUT1PH2kSFGbmwahPzetNcDLf+DLj+tyx/b3y5NR2/O4osddRdIphh77BZbnQhQL763x++4amTFVrcsig2ta6PCTluR+fqX9ck8o2tIEwtoMZ7CDwHqVKit8BImlmqIuHN32lBSxMul8+YIZfmLohj/nrOVuMT7GX203dhxWtlXdvo89RIAaAMiL4mA1nz9DljQ5Nay9WqodSZQLZXKvP36cRthXyyppy76u/RP6E/dugn7zBw4SukFJrh/ZgXeQMb0DYrEuKSlqEwuI2HCgR7RbGiMpveGERBYkaGlLpqrtuql2S2fkIXYn4C/JvzfyReoNITJpmzV71+RlR0cnyg/kt32DRyqEKD2pFj12ggmt5Kt18F27ls6KDK2Dcesdeskfs655Nl6oCRCsI6GA3RQqpHmqhHCfFyFd9/Qx2Fp81Bfm1p15Dl+gi7mx/wnZwiLk+CKX4n8mgdWfSZPlNOsA584IqGd5WXjPipOTMjLgwallmGABzP21iPf1JMj6yMey1OT00fL+uddVmbeL7kFkkzgmew/E7O9dME0IFjKkDjPeGqCo+Ecyel7bVfpGmzUr6t+Hxax0RaW4vmohdZJ7kp0lHtntTWNxl5f3naFUY/WFAH3HuqrekP6R+13caBmzsGM0m23uYwHnLdRn16pnk9uTKqd7FmHKKEjg3qE8icBWZjUfH+/Dvgq2XXuTmdJTRg77VwkWNtX5lyfRBUlJnYY6hwSDwN8r/CKCE2D4m60QGEizIrUzJa7OhA9s9NeGWQb0tghP+y1KCZzJEj3NXzuSHnh8EjC3m6iCEdQnGCmH+HVzV3/duOglkVkFBmkJH/TQBkCsQA6M+H0F4TIhD2GN3s1ZO8lw+OuePzHFxOcKVCOAseTAmRbRXdEO+OiGfZFYBsicXr7ZljGkTMPRgIuZRFN6QgG25HMZctY+xbrD7OuQI8sHfn6UxEucj1UNYRz/y6v+8IqTsG4tJuC2N9lg7pRg2nYMW6p1FTO74UyNC4AAJBfn6PPBcaH/1ZVNmSvNX8Oap4t348X09GWcuHzRQwC24UtCHk6wVYNSjc6nMei9RR2mb0tvwDEPYY3XIyhSF7WQsDS4821wTSRVAkBGY56mslq0vojEvabsDkXfX0z8dp0uN3Polnkg8w62n6zaiRCoJ2UnNIlJ3TYhCb0HY/WxaXoY5Nd8aBD1yvVuAP3hrGUxoeZYCjmH7ULrGakiwV7yKJYNb6tvTPJeHZnJhkAytSTbfpYuY6dtwDFvrckr1dzfDzQyYXnNJgh/1MyiBwC+nMJnvcwbyI1nWT7EdGoy5eGZJ0VTP025z8yJgzO8QJtHC2s/WB5ajZ8f7PFH5IRyGdmcpapQjYnzfgMnE1MoQo8rvLhdfIwKQNyBKVegx2ZxS1/6hip+SiU9r/fKwEj3Y0s0Dhmsn/+zEQnNa4QIOGxVf2QFiEKXyizr1vY18crdcuVGcIcV6weJN8LfYUQ2L49uCEScUWoedDLS/i6y0Kaq0ZdjvY+VjpVPdWDRilerBrSsLaf9AP/Z0ZX+zQzRsg+GJVGVKpEOfuTQ2yJ1jEJYl7hjeS9V4G74SEJosOO6WGn7fr6HcDSt12yWrK6t9r7YgB7EjbBCDV3WEqVVVHrBzyLkcFm2LRorzf+A4RNJLlphdivBPmjAkOT1mD5sO3ZoPe57IvPfDlvvX0awQPjnKEHLsO2kA0S2ZG7vZDleynRQo8TvIZDtV/fJnj5CiJXFQFcQOTMENrIzaPoqxKAR0F68UrPtFNBbxCFVTRTBkQXFEIXAmcYhhXbhJ40yf+QSJEGUKR9kek6ulWeswYKaq7nJbULQAeaMdBhyJZIR3g5SQLklu6hOewlOC+iJVSj6mMvYypsG3ooU1cJrs/NQ2btKCBpvJ7fA5dba/fQxiCS/Brgv1w6HHmyVELgdJQiYITcOpjRysgz+u5zHdmEZFJ66QnrTQNQt6rkUOIvgyxnRKcaqvSHWKqbr4iUMOTGWV1O97ePi+VpN4EMWUdfVkbIjchhM+AznZTZOG1Kzm4hhWVyQMg+82BTarKvN1sB8BUvlS4UpoFBwIGyRLwVXCcTKN/FazhJCHRO82CpxgLjY5XuzkHwbqeaXVPmXAkvNA6bBiIqY6+jfrr96HzB+5pK4BAYD4cr4HIzo4R9yiZHUWCuSDX5pB3/qYsJpRnLrihCUmyj52el39M2u/hIFNYbYRL2fu4UfsQxkCqdd+Mt1bjJTi7icxNOpWInSs2MXAX01zmsXfSd4D4aehnT89T0l8rg/AfhdgqsI0jv4na+ar0VCE2Hh43Sd7SqHsu+ZndK5hWYofO5SK24sFht5R20153QF+eSHDgU8FXhIM04lqw6WZykygvspy3z+JS2QXHdCzYzMMKsVNtmZFxx2YYDKer9YKhHQYW+CFNVkcBCIdg/FhAVehDiUBxlSHZYvILYy1zUB20zCyF+darHh2Vx0WaMaA21dQcFM4wua7UcT6UuNfiLQmXBotfFggoFSKJ+3gLTOkeSXsLzcty33SmnSauw+e+YZKz53+hZpH5BmzyLbGz9r0KN7ACpziPyB/xfuUyzeXE28CDLvagKQY0tmxCG3qbj+wXC/RREFR86fu/ijEiP+1wENrV6FuNtE9TalZ3zPWCrZGci66rfgifWCPq+rbycX/NZfGPW3vY8X4CIx6QsMBLX4jVof73mXiz/7yJBdXPiLbqEVNCeUUrA5pWHNFu8OD3lLcKwc/D0PYVNn1rKv+P9PA5ksi4IqEOVtMkgFXHMb4hHdqx/MvaKcnDxRA/3ybfO8qIlmNeKrUWuDY1SRy4TljwHU2d977ORBk3rQugiQuF7kQYOpVm3ytkWIFCYHxaQie6b2d53fWlxEJuQRa5I1V1DtLfFX/OnpG28MyLT/ivfguEcASEVBmGED+GMM/Es7Oxk8HUFX03n2BqIxUW1qtWFWEM66iE6gJ4wJ5/CY6muhGAyEBhwCXekReZ6C9omJ3p7Krxz1OUiFhBUE4QU8rSnICB9TdKIdsjJU31172FX2CD+9cF+PqOMHLFRehrlnvVohnFx/2bMPPCel2AySu8jwqUzyMjgtorFq42eR1LRVM+xARiVTmeRokN7laxiEwIwmNe/YIWeZxqYAFT35p8m72o/kwfVkQL+7ZX99+J6oedQjrUHhAn9byWB82GS2QoX+XaT4utcNgK2X7y8Lv99DPzfrTBTYC1NOYzR1tIDPj/eUuhUpJFoLHrfVHi+3Qyx0zDhraJ6L9ysYdyBzOlWi2nkz6gBdz6wFaWobmHz2V42lBEPZl3s0btL+53wSmt0w8GOnHsZWgLjfVHUum5RVH6pIIyPW+1kQ3Wf7rgReims65Jbw03b76jCNjdlNVu8JB1OUbyOQ2pefzg+CNrhFUFLE7T+VYE7krHZkxMRBG/hUrma/0GAMkCS6IiPh3ArzjtYRDeSm9Hn3Pu3zt+EiRcn+GNEQDSafJH5Nz2TM248z2mEtm90taFiQbn46CECZ2DiJNZtNIYtvJA5P0OM6RczUOXD+l2psvxTpFUSYnxXsia+cISrPAIWYSccPFriIYlmTd7JUFMtrkzRh8VcxGrYwJnbCf7JR00UAQetIg7t16wyvBDEff2ZhkxfqTSyqmeGqTLNkihxM+HhCeDfzW/9iNz3dpu7F9i5bobbJoykTfk365wAzV75kKYrbuc8e+n5xj5PNpAXFyqJO+eCp8a9iWR6AU9w9yr1thgwKEZoJ7BfIcdHCXMBCZF1Bc0ajAA2dZ+iAX9/4PFidKND8e3GkoVwj7LkI6A0LbsfM43TtSQG9U2YgjxkVbLAp86nQEfqamqos/IpQ995BsHphLRf27ZfNEEN7SKgXVf7kcTlUAyArNjDjL4cdjuh3mK5oYQX5lCeQY8NZm09+ujRU7yBSR7JfmvAN9LOqN0XwHLYPCNRnzI74HTPLeI/hy6WMhByS9fsNehdsdf65l59aIsP1KtJpqyk4yNsyPEZHSZE7BkYkOFBCqAK+N4DESR7N5kdoVZUJhfQs25EBPqx1malm5TgKyDDW+madDz635DGbZE7NUDpEvQId0ejGtXYIooZ/IFpRfkigACRsXEb0kKdk9zaz5shYVgD9g7A862wHOShXsdqsTpCYDWLRNnVSvpczyzbcitGI0RoxtpOoAYQUCFsDxpbOVvBXxOc2lRVIoc8j4/Q6pYWqpcwH9SCdRJYYQ+ueZjtZQa8cZL8d1Hu95lc2T0sFpTS7mVv/9wUgW5AAR73qxTIA5q4s0ibsyFiERLMEDqbGFeuyiyN3Gr6foAOV+qL2xbqNO8sMBNBZcN9zRrXR05z4S+pNRvsWltRbIOZWqAVafLHFsX9i9P6obhII/wiWcfbBiDZjQJF6YOIkLy6wWuZDBApXntSs2dCUq5mNQ1sLiiNXZg+1NSryNzXUB+/PGEwJIPop+hgK2vsrE8SsXdCFPYg2Ai20euN6th2+cXQx2LkagFm9r1JWunC3vEUwLRNqtEh8Yr22+t4P7F4AjZI/52iCdW+Um85a91QhrHlWsQPnIIfAtIpNMYXSSwCu02I++GpxmOXbJ0Zv3NnLbaLbnXcL505uY1EF2jjoIqmRstGq2XUEVT/Nccs5h5le1N6Uxdigf49sZnhGAMV3cVNk9/uAHxnXZpkWZ/dqSi2KhTlSvi7+xw9m+V17w4574kY/dtO0uK5Gyior1HQ/ZMnnfHA7SG5S6X39540cKSS89kOB+OEzVgWSlZx1ylGH/FX6F2FFMIPqJ1JvSCQe6r7Wlk2EW1iYvqpGNUhkqM+49+1BX8O/IWicRiurgoM3+Xg7VOx3rNcjCIoem1lq78aX49PUDJC4AhRDqkgx6dxt4fmf9KQFlDFN5NygwL3AYfbHpmjXYVMZxfrf1B+k4SFc4vBGPlAbPJElWWytZ4e5GO65QwOmlbWzMFPrQNe6SFW8TKX724P53Bd+fQZMyyYdpLGTno2bF6S3nplkCHXOpNja2SwjI7o8XzcWe7kQZVPzngZr8gZpu9ImnaQ16sioOM7NHebc3R4X6E/NDcIxCLZip6ioiP62ZlH4QTsbL7u7Pmpa2OubG9Kusy1Xrue9Tgrqnnj2I7apG3rNf/zndEIRhYpbNCOumZvVZbNHz94K6NxjHTEWNH8/bjuTedmGBpzKtf5P6L8xb6aUvdCNcAL2cBeLdNovL3rOmsy7fMzzCszrxwdM6c7iBTOA6XIhDBxtSYDe8xBy/arK5rVPMw9twRmYgCB5JuphX9CFpCQ3fdXtxzZfuAvnnLJ4mRMTC0JAeTmM/ogerkn440yrcHR+z4Ff0+yRgAvZkhBGgel9maAZyQGqW6YdarQhTdYVjJ0N2GPdhxiBDIPkrSUhnTio2KySIOSEyxLCQgWdmD8rZZ3kshO4XHcSntPbbu8jZEUEZboc15uVqsFQM8HOVlUgsgBNtP4vCy4ao7NDkWAcx5/8OVD6YBSwLGkmLzOMJ+1srzUVY9ZG2TOl0M91zSHctTs7UZ3LjxMyC9fw4gXfT2IMKKIAk0f2bI9qFJJdvXE+msQFvLpbslSgkUXfZkqMoP9MTdOCJNU16qSOkyd50CL18puk1pFdD9+Z2V0svhzckCZUG7t2pnltGrdTdxjDgL+CNQZhgUSvuHgjG28uggNrKTlIalFWxmXO4tyxflb5MDEUgdrA6e56oKzUOE7Kl/gGIKFN0t8s6cNGmetqjdv0+dM6c9hyS4kvDZEXTd+MW8ZLayLZN7nTSMqlt1BifBTc4zE3PSuhbbp+8oUrEnwH0JvkAXW8N3nm1zpC8kBX0uYoVvDy52LKr32dQThAGWFDYoxiADxj8a+qvIKknDnrSa1sm7w85kF/hqF/y9JDQyt5nbOCezDryTAogJZ1riQ6Ws532PBMUvGswxRLVqK3EpxjHIKn4xSDPk82yNMcSrp3K6lCpH+8JKIyu33lqwzF5AvibhFtN8jJOnw/JhQ6GidbEtoABI6lt2EOCLuvN13dJCs7FfwOP3OJMqrUf2zjbUHWciQUN9hJE71Nxg8ii0kPymomFub+pD6xmmqPPHhMX9dD5+cuqh5y4gis+7Vtvd/aeziqRyQObhMz9hsoKpfUROfyhb576Pd7zCXB7NhEZCzGfWh/6SngDwDeqPdSCmudSTQZJBRw0lZiEr8O68HVnVFrrDoMYXRUrhJ1Pl8yi9BiSP6M8w2C5+LXufVUScHFILT2aMEoTlnlB0QHXiktlIxq0frp2tzeJP/ui5Dsa4AJ4PnZ0FgzwI2zHbVu64+66IKkNxM3ocPM0pXu6VPi+2PTjNJfgcUAG0XwGmqq8IvC7yias1wMFg02xTUatIdKTnOJPKHu5IfeYb4lgW63BvSJr4aovuDWlOaSsPU+rxskH74iSUGjc2M5vbNe69MJ4MJW0ujeHyzmLNadFfQAym41vuIEBTA0oIpIPFKECHPPRgumnLkeujI16Qcwtulf2F7+vyWkzDEJ9/laxIRfrJOo2d+nX+aFpN4DpnS4jxvUosCkXpM+xwXfLfxxDCXIfRI5oE7tD6kKZry5e6QRtbyHwD+bPgnecibxUcgSHwD15WbkEMAH/II+C7E6n4CCewibZqPHvLDyny3Vfpgrb+eylMFHxH3c6Husl6/OgOtkz4hiK2IZ6TZ8hSI7HfaO95UVc9oLVainKs/BDtJKVnsWy5U0dtGb4olks2gF9zTUVLLiu98u41KBSpYTt7dKZQJ+kXihSe3hyidFuO5fFtDHhwTKrgPTckjceLlQ03UcLH0YqIu2kjuMBMynaJqndEXXu7wuKkYvwVdDqvgEwIIUvh6Mo0jAaq+fdfHQChoIq1V2rPnZAwqUEdGl5a65Urv7QVgWx0nO/HCCd+BWS2BKLJvgQk2gpUJztCQ5ABvegtoxvdgaVpg3/AhfP0nmR2i7N5ES1f+jh5ukZqyUCpL44CtTCK2Kr0kC1w1hjtYr0aT4pbPw8qjsVDRiNiT9myCxMsAbRr/cJxMU103oyJf07I/tDd/Bz1eoDDxg5BT0bPEIunWr8cQ6IYQCqSJxoVh4Lz6VW9ZOcLP6fYQ/JpTOsSMQTkH/zZFK+8bOaC69HDmJMN1nNIcBNM3M0BUSTmuFowR33CHP8R9anXzVVmqHnmCYk/cWGXJ+4LJwnxREDXNSbssYqgEnAtalv/ZBNShLNKIvYDcXjxV8RTJO53Qqxjs/EVdwZr8RGLg7lJNM4ovMvrv38+H0pswLuXNGlDZFQ+WKLkcb8ij48L63bt82m0HlDY204Eb15aX5hVCcEKxhjZsNgVUhqTppxrsUZtscOWGCGncHWnd4V2aNOKx0ZqGInUxTpJsEujEx4nb1brNl6RpyNLyYol542ww2x3i6TM4rUkV+kmoUG9tYt3qrmHmwV7GORoYpMAY2BWiJUHhFjlxjS0Oh68LKIlnBaxx+gHtJVzoJ5hdL7FFuZt6LoGezDtyg56M7yGkgQwh6kKf81viDz7nfhOjrO0ZtXnAQ5vCrXZRlHETf4BzutaZyJSRL3TM1qexzsa7Bc48+1GT8EjSjAJ9oJKHJIPfqTy7sfnhjoNeIUIyyBWd2y+zTPGJvu+87HfAvYnUEcy3On8FzRUMiYgpdQiUYJEfUaC5ceZQeYFAxNQBViMBOa2v8Q7qn/r6TuJtxi4noYysv1XfhkSZM5tSbRlElV609gnIPqxBtofmUei/MOBVsast8kxhpfbzRhKiuCwbaazhRK6S+UkYRkkhWidgSA54zZ18hftFlyQGgwWBaMBXen2w7ugikA+mbEz3V6YexHUhJgDeMifJSUGZ7fcMaQIsNQmg7H8MeSl+MyAhB+mGJ2xMNnsPsbmMFhAt6FPO96EMvq0R0Z1PQD07Lhe4koOeZLU9Tcu586ffIe/yGCw3OiH0LX1ZBXv1c/zubkgPmp9QiHfgVYt8LC0NpbfuXTASkK+Bd+6tQY/eVUpnVOwiqjiKx2PuGkAnNCSo2Qc2w9ym73S/fDU2mr1LIfwTbIG7Esuv+SmI1vnHd9V8ztCe5NyfjXsMXraMqfX320gKVb182D1DZkf0XXPwX1JJ+tRTuBFn0RFknrqIlk8Ik1P97pN3aq/zRjMPBZDoHYgy/wwi9N5EiisxvqaiWanH18FHljRdveasQicKKFQ9Jkgrq6alXBTyoImmGYvO5ypUdnBm/plM7Rcf8HI0CgjgyXBBuOi0WSdId+Oc3y62uM1ztOljN9uaNqCr/nebgO/fVWO5Yb/FtKpfTf6p4zR8Cl7m7yGOiVw1+JjSDV6A1M7upysxB6H8W8Z/M9V90MsZ6cBuUxpXedO8OSXpwupYjIePG9SqHLM/Whqu/TiU3TT+J3/lYyAXdTXGFBpFPujrPa4thrAJ/6NxEuBRGWBkhLx2cQeFKl611S+vcleZu6GAIwVJL/4CHeEB0nGYmXXUfEzTnTUxqRtK+c20ZC2qwYP4e0VLd8vmo+VPHlt8rL6dQGQwhkh+jlV9Y/BvEfCeU27HLvJ5Pyi0hXzN/v0vUE/MjGNHTSSMbfJCUsM0DewZdZaYymnL4w9yaahPtebZJz5XX+TsPIpgQDbS2dyMihIEtZjQWTcsftgihk8NOxgR33XpKPtGn0uLOlN8eK1i4yKZiTLOAxHxRDX/1+M43iJnZKr6oA3gQ+Gc5o6FbngP9hULO/44mU4Kq1IQVIz0I0hzpSs36TywwXWRhyyFX8sxDU5qH06n66EYJHgbTYYtjPkaLkZlpaG88pMSe8sV98c/KA0z5lbIlRHbdo/jmZ6PkzbNIubzMcX5k809KE/FXXztOgcOPWX+Q8jd64GwHiYDXl+JX30vXrN8rFXjTWlXn+rXVbwEMvkn3GS6utk4kH+bydoZ48x9nbO/UH0KavU8TxDErmWaQx3pAVkfweMca8JNxX/4dRV0MnYYs6QOJIXYeX9QgoUDS+tWeHVfveXNmz9UUPteJfUuqbx5NkqZjqQ+H3bt5EHbkakkh9g9RAVycr/ILjBDctM6MyE0tFv75VZV0xaWSpiigNX6HiNSs4z8LhDRzDHYgueAPHRFS4wcFC/B/tXTNoF2kvIGZnFY0Tz6AzNiIlbTPjPY9W2j4ALacPG/wr3bGcxPvDj/mTWZQO8aacUWCYcLJqIJuKDDAuizMJ0dDf5y6jL1x4puMzZXPrJtZfaiVy43EjrXwM0ZeIp91i1EQOTv+z0wkek+/tN8TDUg0Mgm0863tETc5DjAOHKynrwqr0/Wcy4GO8i54dPItRDlumphgAtlxuTyzDSEho/hnxBTAFb3Znh0BiHvQwPUJ6xIzBPHPwkiyVf/EEM94OQEAXPyu684zyWZkW8915j2fUJ8ZLga8qWTvev8EL9aiM5ZjIqT2E2WEe+zsxKF8Y9Nwjlct9UThSqAJBCN99MJSIvZUwAfFpxA3onQ9dWCYJ9VcesvLzeHiBPNwsOzHw41MN0CNuLeKSyStbWmRrcg/6nArZv3ahby68+OfYCHHnqMtvCtCehV+9VTb6l3rUmrIPlzktydHWOsxg9De3OxjTRfhpp4QDXFcSYCpyDUn5bXhabpmhSzqVF5sjj8YVKH0ouuY2BJq6zzAC7k+GjYLua59pY0BYz4Aw9pbKW4RwSVgYCiWWJmoSRyf79VpGt1/IvtrZJJFv0lPAGa5/8GBH6O+2DX+ejdSJZ5OQ0OwCwYX+/vW5JZj5SuoyN3n5A6EakQ/EnTlWfBDb6ua4mstbBJeM0pFLgBFh2Iz41sTaJzAWHVnUS3cSDfVCqr5Aq1CIHlZ0Jdxywv0LJLT39cvyCc6+PGT4A5tH+rfhrFkw6vWcGME9BGyZiAKPCwt/qHTK0o0HKLX6x0zkBP5yqVCH9TUSG8qhqnbkhaFubFMwzgKL/3DgIGr+fvyW21zLOirS38/voyjg2gbdFBHxEGxLyS7X3PdizrSQVpKE4/NdrdLWkKwytTnHxXV2Zf3j24PoztUsr+oBACgV1oJn4CmXmMBUuTRWYsEcP8XR64e7UV3LEFHbxAq8ZZJ7BvmKVQPVxj31K15umrKPU1HlaBLlKAIdkMlu34Qp4OoBLJYKCQwT3HcIkntP2Bgp1hzKhoO1wixzgoLEvdy1npzYZqElnWnJr3P148JYe6iIrajeM7agYjzIyJz2dSKBn33+TbnW36uGv45uF+lRQ2XOC+4EctVV880KT963cv+QMolL1kt93QYlK5G0FmKOOT63+WvNjJA9cuC64h9ayu0GPJv/1y5vslPL32QqrBVX/GNgm6asuNURwLlrGB4TefyP1S8aGyMjZ43tVEfhhPiuKHcKGu5X9amzviTRnGhKetrIgA21fepiiXjnZVnZViplnHYAaYOJc77yDG2wK5PhK3Q7Tju/YjznpZDJ+JqBORhQh1niVB4xblM9GMtun2Z98YWROm3wZ5ckrleLrOn32zGMpiJFVsDM9gtPenbf39zoNzeDwD0M9EAesNYVC74rhcoYMkIenKbHhM4Ao2N1VO7VWFQ7DO3C7s9O4/NPCZ8roWXS5uYfia2l2F95nVLXpJzE6jC0MorMTonx8wu48Pwxz/oqwCOAVftMkitlxMypSqOvMXKb8MrbrPx601jE+3HBn4wj5NnTzT0K4zTvWPgFmeZFCk2rXhku/Px7h61hMtfpo9xfCuvCHc1A3tRtBmryh6MVUBOiaN6lSapzwg2g7ofUOPnPZ98QkdTlzNBWzZnABnH86mWPRL/DZ14q9QsLdAxVjc02","categories":[{"name":"生活轨迹","slug":"生活轨迹","permalink":"http://zhangbuzola.cn/categories/生活轨迹/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://zhangbuzola.cn/tags/2018/"},{"name":"生活","slug":"生活","permalink":"http://zhangbuzola.cn/tags/生活/"}]},{"title":"java基础之缓存一致性","slug":"java基础之缓存一致性","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/07/05/java基础之缓存一致性/","link":"","permalink":"http://zhangbuzola.cn/2018/07/05/java基础之缓存一致性/","excerpt":"","text":"大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。 比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 通过在总线加LOCK#锁的方式 通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之多线程三","slug":"java基础之多线程三","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2018/07/04/java基础之多线程三/","link":"","permalink":"http://zhangbuzola.cn/2018/07/04/java基础之多线程三/","excerpt":"","text":"线程实现继承Thread类在java.lang包中定义, 继承Thread类必须重写run()方法 123456789101112class MyThread extends Thread&#123; private static int num = 0; public MyThread()&#123; num++; &#125; @Override public void run() &#123; System.out.println(&quot;主动创建的第&quot;+num+&quot;个线程&quot;); &#125;&#125; 创建好了自己的线程类之后，就可以创建线程对象了，然后通过start()方法去启动线程。注意，不是调用run()方法启动线程，run方法中只是定义需要执行的任务，如果调用run方法，即相当于在主线程中执行run方法，跟普通的方法调用没有任何区别，此时并不会创建一个新的线程来执行定义的任务。 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); &#125;&#125;class MyThread extends Thread&#123; private static int num = 0; public MyThread()&#123; num++; &#125; @Override public void run() &#123; System.out.println(&quot;主动创建的第&quot;+num+&quot;个线程&quot;); &#125;&#125; 在上面代码中，通过调用start()方法，就会创建一个新的线程了。为了分清start()方法调用和run()方法调用的区别，请看下面一个例子： 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;主线程ID:&quot;+Thread.currentThread().getId()); MyThread thread1 = new MyThread(&quot;thread1&quot;); thread1.start(); MyThread thread2 = new MyThread(&quot;thread2&quot;); thread2.run(); &#125;&#125; class MyThread extends Thread&#123; private String name; public MyThread(String name)&#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(&quot;name:&quot;+name+&quot; 子线程ID:&quot;+Thread.currentThread().getId()); &#125;&#125; 从输出结果可以得出以下结论： thread1和thread2的线程ID不同，thread2和主线程ID相同，说明通过run方法调用并不会创建新的线程，而是在主线程中直接运行run方法，跟普通的方法调用没有任何区别； 虽然thread1的start方法调用在thread2的run方法前面调用，但是先输出的是thread2的run方法调用的相关信息，说明新线程创建的过程不会阻塞主线程的后续执行。 实现Runnable接口在Java中创建线程除了继承Thread类之外，还可以通过实现Runnable接口来实现类似的功能。实现Runnable接口必须重写其run方法。 下面是一个例子： 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;主线程ID：&quot;+Thread.currentThread().getId()); MyRunnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); thread.start(); &#125;&#125; class MyRunnable implements Runnable&#123; public MyRunnable() &#123; &#125; @Override public void run() &#123; System.out.println(&quot;子线程ID：&quot;+Thread.currentThread().getId()); &#125;&#125; Runnable的中文意思是“任务”，顾名思义，通过实现Runnable接口，我们定义了一个子任务，然后将子任务交由Thread去执行。注意，这种方式必须将Runnable作为Thread类的参数，然后通过Thread的start方法来创建一个新线程来执行该子任务。如果调用Runnable的run方法的话，是不会创建新线程的，这根普通的方法调用没有任何区别。 事实上，查看Thread类的实现源代码会发现Thread类是实现了Runnable接口的。 在Java中，这2种方式都可以用来创建线程去执行子任务，具体选择哪一种方式要看自己的需求。直接继承Thread类的话，可能比实现Runnable接口看起来更加简洁，但是由于Java只允许单继承，所以如果自定义类需要继承其他类，则只能选择实现Runnable接口。 使用ExecutorService、Callable、Future实现有返回结果的多线程多线程后续会学到，这里暂时先知道一下有这种方法即可。 ExecutorService、Callable、Future这个对象实际上都是属于Executor框架中的功能类。想要详细了解Executor框架的可以访问http://www.javaeye.com/topic/366591 ，这里面对该框架做了很详细的解释。返回结果的线程是在JDK1.5中引入的新特征，确实很实用，有了这种特征我就不需要再为了得到返回值而大费周折了，而且即便实现了也可能漏洞百出。 可返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** 有返回值的线程 */ @SuppressWarnings(&quot;unchecked&quot;) public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; System.out.println(&quot;----程序开始运行----&quot;); Date date1 = new Date(); int taskSize = 5; // 创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(taskSize); // 创建多个有返回值的任务 List&lt;Future&gt; list = new ArrayList&lt;Future&gt;(); for (int i = 0; i &lt; taskSize; i++) &#123; Callable c = new MyCallable(i + &quot; &quot;); // 执行任务并获取Future对象 Future f = pool.submit(c); // System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString()); list.add(f); &#125; // 关闭线程池 pool.shutdown(); // 获取所有并发任务的运行结果 for (Future f : list) &#123; // 从Future对象上获取任务的返回值，并输出到控制台 System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString()); &#125; Date date2 = new Date(); System.out.println(&quot;----程序结束运行----，程序运行时间【&quot; + (date2.getTime() - date1.getTime()) + &quot;毫秒】&quot;); &#125; &#125; class MyCallable implements Callable&lt;Object&gt; &#123; private String taskNum; MyCallable(String taskNum) &#123; this.taskNum = taskNum; &#125; public Object call() throws Exception &#123; System.out.println(&quot;&gt;&gt;&gt;&quot; + taskNum + &quot;任务启动&quot;); Date dateTmp1 = new Date(); Thread.sleep(1000); Date dateTmp2 = new Date(); long time = dateTmp2.getTime() - dateTmp1.getTime(); System.out.println(&quot;&gt;&gt;&gt;&quot; + taskNum + &quot;任务终止&quot;); return taskNum + &quot;任务返回运行结果,当前任务时间【&quot; + time + &quot;毫秒】&quot;; &#125;&#125; 代码说明： 上述代码中Executors类，提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。 public static ExecutorService newFixedThreadPool(int nThreads)创建固定数目线程的线程池。 public static ExecutorService newCachedThreadPool()创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。 public static ExecutorService newSingleThreadExecutor()创建一个单线程化的Executor。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。 ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。 创建（new）状态: 准备好了一个多线程的对象就绪（runnable）状态: 调用了start()方法, 等待CPU进行调度运行（running）状态: 执行run()方法阻塞（blocked）状态: 暂时停止执行, 可能将资源交给其它线程使用终止（dead）状态: 线程销毁当需要新起一个线程来执行某个子任务时，就创建了一个线程。但是线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源，在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。 当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。 线程在运行状态过程中，可能有多个原因导致当前线程不继续运行下去，比如用户主动让线程睡眠（睡眠一定的时间之后再重新执行）、用户主动让线程等待，或者被同步块给阻塞，此时就对应着多个状态：time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）。 当由于突然中断或者子任务执行完毕，线程就会被消亡。 下面这副图描述了线程从创建到消亡之间的状态： 在有些教程上将blocked、waiting、time waiting统称为阻塞状态，这个也是可以的，只不过这里我想将线程的状态和Java中的方法调用联系起来，所以将waiting和time waiting两个状态分离出来。 注:sleep和wait的区别: sleep是Thread类的方法,wait是Object类中定义的方法. Thread.sleep不会导致锁行为的改变, 如果当前线程是拥有锁的, 那么Thread.sleep不会让线程释放锁. Thread.sleep和Object.wait都会暂停当前的线程. OS会将执行时间分配给其它线程. 区别是, 调用wait后, 需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间. 上下文切换对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。 由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子：比如一个线程A正在读取一个文件的内容，正读到文件的一半，此时需要暂停线程A，转去执行线程B，当再次切换回来执行线程A的时候，我们不希望线程A又从文件的开头来读取。 因此需要记录线程A的运行状态，那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。 说简单点的：对于线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。 虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。 线程的常用方法12345678910111213141516171819202122public void start() // 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。public void run() // 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。public final void setName(String name)// 改变线程名称，使之与参数 name 相同。public final void setPriority(int priority)// 更改线程的优先级。public final void setDaemon(boolean on)// 将该线程标记为守护线程或用户线程。public final void join(long millisec)// 等待该线程终止的时间最长为 millis 毫秒。public void interrupt() //中断线程public final boolean isAlive()// 测试线程是否处于活动状态。public static void yield() // 暂停当前正在执行的线程对象，并执行其他线程。public static void sleep(long millisec)// 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。public static Thread currentThread()// 返回对当前正在执行的线程对象的引用。 静态方法1234567currentThread() // 返回代码段正在被哪个线程调用的信息。public class Run1&#123; public static void main(String[] args)&#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; sleep()方法作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread()返回的线程。 sleep方法有两个重载版本： 12sleep(long millis) //参数为毫秒sleep(long millis,int nanoseconds) //第一参数为毫秒，第二个参数为纳秒 sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。看下面这个例子就清楚了： 1234567891011121314151617181920212223242526272829303132public class Test &#123; private int i = 10; private Object object = new Object(); public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread1 = test.new MyThread(); MyThread thread2 = test.new MyThread(); thread1.start(); thread2.start(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; synchronized (object) &#123; i++; System.out.println(&quot;i:&quot;+i); try &#123; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;进入睡眠状态&quot;); Thread.currentThread().sleep(10000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;睡眠结束&quot;); i++; System.out.println(&quot;i:&quot;+i); &#125; &#125; &#125;&#125; 从上面输出结果可以看出，当Thread-0进入睡眠状态之后，Thread-1并没有去执行具体的任务。只有当Thread-0执行完之后，此时Thread-0释放了对象锁，Thread-1才开始执行。 注意，如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。 yield()方法调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。代码： 12345678910111213141516171819202122public class MyThread extends Thread&#123; @Override public void run() &#123; long beginTime=System.currentTimeMillis(); int count=0; for (int i=0;i&lt;50000000;i++)&#123; count=count+(i+1); //Thread.yield(); &#125; long endTime=System.currentTimeMillis(); System.out.println(&quot;用时：&quot;+(endTime-beginTime)+&quot; 毫秒！&quot;); &#125;&#125; public class Run &#123; public static void main(String[] args) &#123; MyThread t= new MyThread(); t.start(); &#125;&#125;执行结果：用时：3 毫秒！ 如果将 //Thread.yield();的注释去掉，执行结果如下：用时：16080 毫秒！ 对象方法 start()方法start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。 run()方法run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。 getId()getId()的作用是取得线程的唯一标识 代码： 12345678public class Test &#123; public static void main(String[] args) &#123; Thread t= Thread.currentThread(); System.out.println(t.getName()+&quot; &quot;+t.getId()); &#125;&#125;输出：main 1 isAlive()方法方法isAlive()的功能是判断当前线程是否处于活动状态代码： 12345678910111213141516171819public class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;run=&quot;+this.isAlive()); &#125;&#125;public class RunTest &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread myThread=new MyThread(); System.out.println(&quot;begin ==&quot;+myThread.isAlive()); myThread.start(); System.out.println(&quot;end ==&quot;+myThread.isAlive()); &#125;&#125;程序运行结果：begin ==falserun=trueend ==false 方法isAlive()的作用是测试线程是否偶处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。 有个需要注意的地方System.out.println(&quot;end ==&quot;+myThread.isAlive());虽然上面的实例中打印的值是true,但此值是不确定的。打印true值是因为myThread线程还未执行完毕，所以输出true。如果代码改成下面这样，加了个sleep休眠： 1234567public static void main(String[] args) throws InterruptedException &#123; MyThread myThread=new MyThread(); System.out.println(&quot;begin ==&quot;+myThread.isAlive()); myThread.start(); Thread.sleep(1000); System.out.println(&quot;end ==&quot;+myThread.isAlive()); &#125; 则上述代码运行的结果输出为false,因为mythread对象已经在1秒之内执行完毕。 join()方法在很多情况下，主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。方法join()的作用是等待线程对象销毁。 12345678910111213141516171819202122public class Thread4 extends Thread&#123; public Thread4(String name) &#123; super(name); &#125; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(getName() + &quot; &quot; + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 启动子进程 new Thread4(&quot;new thread&quot;).start(); for (int i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; Thread4 th = new Thread4(&quot;joined thread&quot;); th.start(); th.join(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125;&#125; 执行结果： 1234567891011121314151617181920main 0main 1main 2main 3main 4new thread 0new thread 1new thread 2new thread 3new thread 4joined thread 0joined thread 1joined thread 2joined thread 3joined thread 4main 5main 6main 7main 8main 9 由上可以看出main主线程等待joined thread线程先执行完了才结束的。如果把th.join()这行注释掉，运行结果如下： 1234567891011121314151617181920main 0main 1main 2main 3main 4main 5main 6main 7main 8main 9new thread 0new thread 1new thread 2new thread 3new thread 4joined thread 0joined thread 1joined thread 2joined thread 3joined thread 4 getName和setName用来得到或者设置线程名称。 getPriority和setPriority用来获取和设置线程优先级。 setDaemon和isDaemon用来设置线程是否成为守护线程和判断线程是否是守护线程。 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。 在上面已经说到了Thread类中的大部分方法，那么Thread类中的方法调用到底会引起线程状态发生怎样的变化呢？下面一幅图就是在上面的图上进行改进而来的： 停止线程停止线程是在多线程开发时很重要的技术点，掌握此技术可以对线程的停止进行有效的处理。 停止一个线程可以使用Thread.stop()方法，但最好不用它。该方法是不安全的，已被弃用。 在Java中有以下3种方法可以终止正在运行的线程： 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用他们可能产生不可预料的结果。 使用interrupt方法中断线程，但这个不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。 暂停线程interrupt()方法线程的优先级 在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。 设置线程优先级有助于帮“线程规划器”确定在下一次选择哪一个线程来优先执行。设置线程的优先级使用setPriority()方法，此方法在JDK的源码如下： 12345678910111213public final void setPriority(int newPriority) &#123; ThreadGroup g; checkAccess(); if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123; throw new IllegalArgumentException(); &#125; if((g = getThreadGroup()) != null) &#123; if (newPriority &gt; g.getMaxPriority()) &#123; newPriority = g.getMaxPriority(); &#125; setPriority0(priority = newPriority); &#125; &#125; 在Java中，线程的优先级分为1~10这10个等级，如果小于1或大于10，则JDK抛出异常throw new IllegalArgumentException()。JDK中使用3个常量来预置定义优先级的值，代码如下： 123public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程优先级特性 继承性 比如A线程启动B线程，则B线程的优先级与A是一样的。 规则性 高优先级的线程总是大部分先执行完，但不代表高优先级线程全部先执行完。 随机性 优先级较高的线程不一定每一次都先执行完。 守护线程在Java线程中有两种线程，一种是User Thread（用户线程），另一种是Daemon Thread(守护线程)。 Daemon的作用是为其他线程的运行提供服务，比如说GC线程。其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的，唯一的区别之处就在虚拟机的离开：如果User Thread全部撤离，那么Daemon Thread也就没啥线程好服务的了，所以虚拟机也就退出了。 守护线程并非虚拟机内部可以提供，用户也可以自行的设定守护线程，方法：public final void setDaemon(boolean on) ；但是有几点需要注意： thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 （备注：这点与守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别） 在Daemon线程中产生的新线程也是Daemon的。 （这一点又是有着本质的区别了：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是“父进程挂掉，init收养，然后文件0,1,2都是/dev/null，当前目录到/”）不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。 同步与死锁同步代码块在代码块上加上”synchronized”关键字，则此代码块就称为同步代码块 同步代码块格式 123synchronized(同步对象)&#123; 需要同步的代码块;&#125; 同步方法除了代码块可以同步，方法也是可以同步的 方法同步格式 1synchronized void 方法名称()&#123;&#125; 面试题 线程和进程有什么区别？ 答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。 如何在Java中实现线程？ 答：创建线程有两种方式：一、继承 Thread 类，扩展线程。二、实现 Runnable 接口。 启动一个线程是调用run()还是start()方法？ 答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。 Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? 答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 线程的sleep()方法和yield()方法有什么区别？ 答: ① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； ③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； ④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 请说出与线程同步以及线程调度相关的方法。 答： wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java集合之Map下的相关接口及直接实现类","slug":"java集合之Map下接口及直接实现类","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/04/27/java集合之Map下接口及直接实现类/","link":"","permalink":"http://zhangbuzola.cn/2018/04/27/java集合之Map下接口及直接实现类/","excerpt":"","text":"Map接口Map 提供 Key 到 Value 的映射，一个 Map 中不能包含相同的 Key，每个 Key 只能映射一个 Value。Map 接口提供 3 种集合的视图，Map 的内容可以被当作一组 Key 集合，一组 Value 集合，或者一组 Key-Value 映射。 Map中的方法123456789int size() 存储的键值对的个数boolean isEmpty() 判断容器中是不是空的boolean containsKey() 判断容器中是否包含对应的键boolean containsValue() 判断容器中是否包含指定的值V get(Object value) 根据键来获取对应的值 V put(K key,V value) 把键值对数据添加到Map容器中V remove(Object key) 删除Map容器中对应的keyCollection&lt;V&gt; values() 获取Map容器中所有的值Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet() 返回包含的映射关系的Set视图 SortedMap接口12public interface SortedMap&lt;K,V&gt;extends Map&lt;K,V&gt; 123456789java.util.SortedMap.comparator() //接收比较器，用于Map排序java.util.SortedMap.entrySet() //后去Map中的entrySet集合java.util.SortedMap.firstKey() //第一个keyjava.util.SortedMap.headMap(K k) //在k之前的键值对java.util.SortedMap.keySet() //获取key的set集合java.util.SortedMap.lastKey() //最后的keyjava.util.SortedMap.subMap(K k1, K k2) //k1，k2之间的键值对java.util.SortedMap.tailMap(K) //集合最后的键值对java.util.SortedMap.values() //集合所有的values 应用1234567891011121314151617SortedMap&lt;String,Integer&gt; sortedTreeMap = new TreeMap&lt;String,Integer&gt;(); // SortedMap接收TreeMap的实例 // 增加元素sortedTreeMap.put(&quot;aa&quot;, 11);sortedTreeMap.put(&quot;bb&quot;, 22);sortedTreeMap.put(&quot;cc&quot;, 33);sortedTreeMap.put(&quot;dd&quot;, 44);sortedTreeMap.put(&quot;ee&quot;, 55);System.out.println(&quot;共有多少个元素：&quot; + sortedTreeMap.size()); //添加了7个元素，减去重复的剩余5个System.out.println(&quot;entrySet：&quot; + sortedTreeMap.entrySet()); //所有的键值对System.out.println(&quot;第一个元素：&quot; + sortedTreeMap.firstKey()); //第一个key元素System.out.println(&quot;最后一个元素：&quot; + sortedTreeMap.lastKey()); //最后一个key元素System.out.println(&quot;headSet元素：&quot; + sortedTreeMap.headMap(&quot;cc&quot;)); //cc之前的元素System.out.println(&quot;tailSet元素：&quot; + sortedTreeMap.tailMap(&quot;cc&quot;)); //cc之后的元素System.out.println(&quot;subSet元素：&quot; + sortedTreeMap.subMap(&quot;aa&quot;, &quot;dd&quot;)); //aa到dd之间的元素System.out.println(&quot;subSet元素：&quot; + sortedTreeMap.values()); //values,所有的value值 NavigableMap接口1public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123;&#125; 所有已知实现类： 1ConcurrentSkipListMap, TreeMap NavigableMap扩展了 SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法。方法 lowerEntry、floorEntry、ceilingEntry 和 higherEntry 分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象，如果不存在这样的键，则返回 null。类似地，方法 lowerKey、floorKey、ceilingKey 和 higherKey 只返回关联的键。所有这些方法是为查找条目而不是遍历条目而设计的。 可以按照键的升序或降序访问和遍历 NavigableMap。descendingMap 方法返回映射的一个视图，该视图表示的所有关系方法和方向方法都是逆向的。升序操作和视图的性能很可能比降序操作和视图的性能要好。subMap、headMap 和 tailMap 方法与名称相似的 SortedMap 方法的不同之处在于：可以接受用于描述是否包括（或不包括）下边界和上边界的附加参数。任何 NavigableMap 的 Submap 必须实现 NavigableMap 接口。 此接口还定义了 firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。 subMap(K, K)、headMap(K) 和 tailMap(K) 方法被指定为返回 SortedMap，以允许现有 SortedMap 实现能相容地改进为实现 NavigableMap，但鼓励此接口的扩展和实现重写这些方法以返回 NavigableMap。类似地，可以重写 SortedMap.keySet() 以返回 NavigableSet。 应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162NavigableMap&lt;String, Integer&gt; navigatorTreeMap = new TreeMap&lt;String, Integer&gt;();// SortedMap接收TreeMap的实例// 增加元素navigatorTreeMap.put(&quot;aa&quot;, 11);navigatorTreeMap.put(&quot;bb&quot;, 22);navigatorTreeMap.put(&quot;cc&quot;, 33);navigatorTreeMap.put(&quot;dd&quot;, 44);navigatorTreeMap.put(&quot;ee&quot;, 55);navigatorTreeMap.put(&quot;ff&quot;, 55);navigatorTreeMap.put(&quot;gg&quot;, 55);System.out.println(navigatorTreeMap.size()); // 7个元素：System.out.println(navigatorTreeMap.ceilingKey(&quot;cc&quot;));// 返回大于等于cc的最小键：ccSystem.out.println(navigatorTreeMap.ceilingEntry(&quot;c&quot;));// 返回一个键-值映射关系，它与大于等于cc的最小键关联：cc=33System.out.println(navigatorTreeMap.descendingMap());// 返回逆序视图:&#123;gg=55, ff=55, ee=55, dd=44, cc=33, bb=22, aa=11&#125;System.out.println(navigatorTreeMap.firstKey());// 最小键:aaSystem.out.println(navigatorTreeMap.firstEntry());// 最小键对应的k-v键值对：aa=11System.out.println(navigatorTreeMap.floorEntry(&quot;c&quot;));// 返回一个键-值映射关系，它与小于等于给定键的最大键关联:bb=22System.out.println(navigatorTreeMap.floorKey(&quot;cc&quot;));// 返回小于等于cc的最大键:ccSystem.out.println(navigatorTreeMap.headMap(&quot;bb&quot;));// 返回此映射的部分视图，其键值严格小于bb:&#123;aa=11&#125;System.out.println(navigatorTreeMap.headMap(&quot;bb&quot;, true));// 同上小于等于（true）:&#123;aa=11, bb=22&#125;System.out.println(navigatorTreeMap.higherEntry(&quot;c&quot;));// 返回一个键-值映射关系，它与小于等于给定键的最大键关联:cc=33System.out.println(navigatorTreeMap.higherKey(&quot;cc&quot;));// 返回小于等于cc的最大键:ddSystem.out.println(navigatorTreeMap.lastEntry());// 返回一个键-值映射关系，它与小于等于给定键的最大键关联:gg=55System.out.println(navigatorTreeMap.lastKey());// 返回小于等于cc的最大键:ggSystem.out.println(navigatorTreeMap.lowerEntry(&quot;c&quot;));// 返回一个键-值映射关系，它与小于等于给定键的最大键关联:bb=22System.out.println(navigatorTreeMap.lowerKey(&quot;cc&quot;));// 返回严格小于cc的最大键:bbSystem.out.println(navigatorTreeMap.pollFirstEntry());// 移除并返回与此映射中的最小键关联的键-值映射关系:aa=11System.out.println(navigatorTreeMap.pollLastEntry());// 移除并返回与此映射中的最大键关联的键-值映射关系:gg=55System.out.println(navigatorTreeMap.navigableKeySet());// 返回此映射中所包含键的// NavigableSet 视图。:[bb, cc, dd, ee, ff]System.out.println(navigatorTreeMap.subMap(&quot;aa&quot;, true, &quot;dd&quot;, true));// 返回部分视图，true表示包括当前元素键值对:&#123;bb=22, cc=33, dd=44&#125;System.out.println(navigatorTreeMap.subMap(&quot;bb&quot;, &quot;dd&quot;));// 返回部分视图包括前面的元素，不包括后面的：&#123;bb=22, cc=33&#125;System.out.println(navigatorTreeMap.tailMap(&quot;cc&quot;));// 返回元素大于cc的元素映射视图,包括cc：//&#123;cc=33, dd=44, ee=55, ff=55&#125;System.out.println(navigatorTreeMap.tailMap(&quot;cc&quot;, false));// 返回元素大于等于cc的元素映射视图:&#123;dd=44, ee=55, ff=55&#125;System.out.println(navigatorTreeMap.descendingMap());// 返回此映射中所包含映射关系的逆序：&#123;ff=55, ee=55, dd=44, cc=33, bb=22&#125;视图。:System.out.println(navigatorTreeMap.descendingKeySet());// 返回此映射中所包含键的逆序// NavigableSet视图:[ff, ee, dd, cc, bb] 抽象类AbstractMapAbstractMap 提供了 Map 的基本实现，使得我们以后要实现一个 Map 不用从头开始，只需要继承 AbstractMap, 然后按需求实现/重写对应方法即可。 1public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet(); WeakHashMap这种Map通常用在数据缓存中。它将键存储在弱引用（WeakReference）中。如果没有强引用指向键对象，这些键就可以被GC垃圾回收线程回收。值被保存在强引用中，所以要确保没有引用从值指向键或者将值也保存在弱引用中m.put(key, new WeakReference(value)) LinkedHashMapHashMap和LinkedList的结合，所有元素的插入顺序存储在LinkedList中。所以迭代LinkedHashMap的条目（entry）、键和值的时候总是遵循插入的顺序。在JDK中，这是元素消耗内存最大的集合。 TreeMap一种基于已排序且带导向信息Map的红黑树。每次插入都会按照自然顺序或者给定的比较器排序。这个Map需要实现equals方法和Comparable/Comparator。compareTo需要前后一致。这个类实现了一个NavigableMap接口：可以带有与键数量不同的入口，可以得到键的上一个或者下一个入口，可以得到另一Map某一范围的键（大致和SQL的BETWEEN运算符相同），TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。 HashMap和hashtable比较 hashtable基于旧的dictionary类，HashMap基于jdk1.2新的map接口。 hashtable同步，线程安全；HashMap异步，线程不安全，但是效率高。 hashtable不能添加null key和null value；HashMap可以添加null key和null value。4）不需要线程安全，一般使用HashMap。 HashMap和treemap比较 HashMap使用hashcode对元素进行快速查找，元素顺序不固定；treemap元素顺序通过key固定（实现了sortedmap），想要得到有序结果，使用treemap，linkedhashmap是基于元素进入集合的顺序。 频繁索引，添加，删除元素使用HashMap，要求添加的键类明确定义了hashCode()和 equals()的实现。 二树map一样，但顺序不一样，导致hashCode()不一样。在hashMap中，同样的值的map,顺序不同，equals时false;而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。 参考https://www.cnblogs.com/yulinfeng/p/8486539.html","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"Collections","slug":"Collections","permalink":"http://zhangbuzola.cn/tags/Collections/"}]},{"title":"java集合之TreeMap(二)","slug":"java集合之TreeMap","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/04/27/java集合之TreeMap/","link":"","permalink":"http://zhangbuzola.cn/2018/04/27/java集合之TreeMap/","excerpt":"","text":"TreeMap简介 TreeMap是一个有序的key-value集合，是通过红黑树实现的。HahMap是Key无序的，而TreeMap是Key有序的。 TreeMap继承于AbstractMap，所以它是一个Map，也就是一个key-value集合。 TreeMap继承了NavigableMap，而NavigableMap继承自SortedMap，为SortedMap添加了搜索选项，NavigableMap有几种方法，分别是不同的比较要求：floorKey是小于等于，ceilingKey是大于等于，lowerKey是小于，higherKey是大于。 TreeMap的成员变量1234567891011121314151617181920212223242526public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; private final Comparator&lt;? super K&gt; comparator; private transient Entry&lt;K,V&gt; root = null; private transient int size = 0; private transient int modCount = 0; public TreeMap() &#123; comparator = null; &#125; public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator; &#125; //后面省略&#125;static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left = null; Entry&lt;K,V&gt; right = null; Entry&lt;K,V&gt; parent; boolean color = BLACK; //后续省略&#125; TreeMap的构造方法1234567891011121314151617181920212223242526272829303132333435public TreeMap()public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125;public TreeMap(Map&lt;? extends K,? extends V&gt; m)public TreeMap(SortedMap&lt;K,? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125;/*** size: map里键值对的数量* it: 传入的map的entries迭代器* str: 如果不为空，则从流里读取key-value* defaultVal：见名知意，不为空，则value都用这个值*/private void buildFromSorted(int size, Iterator&lt;?&gt; it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; this.size = size; root = buildFromSorted(0, 0, size-1, computeRedLevel(size), it, str, defaultVal);&#125;private static int computeRedLevel(int sz) &#123; int level = 0; for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1) level++; return level;&#125; 123456789101112131415161718192021222324public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125; public void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; int mapSize = map.size(); //判断map是否SortedMap，不是则采用AbstractMap的putAll if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) &#123; Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator(); //同为null或者不为null，类型相同，则进入有序map的构造 if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) &#123; ++modCount; try &#123; buildFromSorted(mapSize, map.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return; &#125; &#125; super.putAll(map);&#125; Map的单元是对键值对的处理，之前分析过的两种Map,HashMap和LinkedHashMap都是用哈希值去寻找我们想要的键值对，优点是由O(1)的查找速度。 那如果我们在一个对查找性能要求不那么高，反而对有序性要求比较高的应用场景呢？ 这个时候HashMap就不再适用了，我们需要一种新的Map，在JDK中提供了一个接口：SortedMap,我想分析一下具体的实现中的一种：TreeMap。 TreeMap的继承结构 实现相关接口SortedMap接口1234567891011121314151617public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; &#123; //返回用于对键的进行排序的比较器，如果此映射使用其键的自然排序，则为null Comparator&lt;? super K&gt; comparator(); //返回从fromKey（包括）到toKey（不包括）之间的map SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey); //返回小于toKey的map SortedMap&lt;K,V&gt; headMap(K toKey); //返回大于或等于fromKey的map SortedMap&lt;K,V&gt; tailMap(K fromKey); //返回map中第一个（最低）键 K firstKey(); //返回map中最后一个（最高）键 K lastKey(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();&#125; SortedMap的接口比较简单，没有很特别的地方，唯一比较特别的就是返回Comparator这个接口，可以设想实现排序功能的秘密或许就藏在此处。下面让我们来看一下Comparator和Comparable接口，两者之间有点关联，可以理解为Comparable自带了比较功能，而Comparator是赋予没有比较能力的对象一种比较能力。举个简单例子：面对一道计算题，小明天生口算能力很强，看一眼就能算出来答案。而小李没有这种能力，需要借助计算器才能得出答案。 Comparable接口1234public interface Comparable&lt;T&gt; &#123; //如果小于o，返回负数；等于o，返回0；大于o返回正数。 public int compareTo(T o);&#125; 对，就是这么简单，里面传入一个泛型T的对象o，对o进行比较。如果小于o，返回负数；等于o，返回0；大于o返回正数。 我们熟悉的很多对象如String，Integer，Double等都实现了这个接口。 Comparator接口照例先来看一下代码： 1234567891011121314151617181920212223242526272829303132@FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; // 核心方法，用来比较两个对象，如果o1小于o2，返回负数；等于o2，返回0；大于o2返回正数 int compare(T o1, T o2); // 好像很少用到，一般都用对象自带的equals boolean equals(Object obj); /**-----------下面的都是JDK1.8新增的接口，挑几个放进去----------*/ //返回反向排序比较器 default Comparator&lt;T&gt; reversed() &#123; return Collections.reverseOrder(this); &#125; //根据名字知道，先进行compare比较后，再进行一次比较 default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123; int res = compare(c1, c2); return (res != 0) ? res : other.compare(c1, c2); &#125;; &#125; //对int类型的key进行比较 public static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) &#123; Objects.requireNonNull(keyExtractor); return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2)); &#125; //返回正常顺序的比较器 public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder() &#123; return (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE; &#125;&#125; 一起来看一下如何使用，先来看一下JDK1.8以前的用法： 123456789101112public class SimpleComparator implements Comparator&lt;Item&gt; &#123; @Override public int compare(Item o1, Item o2) &#123; return o1.price - o2.price; &#125; public static void main(String[] args) &#123; List&lt;Item&gt; items = Arrays.asList(new Item(&quot;banana&quot;, 200), new Item(&quot;apple&quot;, 400), new Item(&quot;Orange&quot;, 100)); Collections.sort(items, new SimpleComparator()); System.out.println(items); &#125;&#125; 上述main函数的输出是： 1[Item&#123;name=&apos;Orange&apos;, price=100&#125;, Item&#123;name=&apos;banana&apos;, price=200&#125;, Item&#123;name=&apos;apple&apos;, price=400&#125;] JDK1.8以前的用法要自己手动实现Comparator接口，然后调用Collections.sort()，传入实现类来完成排序，非常麻烦，而JDK1.8则相对来说简单了很多： 12345public static void main(String[] args) &#123; List&lt;Item&gt; items = Arrays.asList(new Item(&quot;banana&quot;, 200), new Item(&quot;apple&quot;, 400), new Item(&quot;Orange&quot;, 100)); Collections.sort(items, (Item a, Item b) -&gt; a.price - b.price); System.out.println(items);&#125; 甚至，我们可以不使用Collections.sort： 12345678public static void main(String[] args) &#123; List&lt;Item&gt; items = Arrays.asList(new Item(&quot;banana&quot;, 100), new Item(&quot;Orange&quot;, 100), new Item(&quot;apple&quot;, 400), new Item(&quot;Orange&quot;, 50)); items.sort((Item a, Item b) -&gt; a.price - b.price); System.out.println(items); //使用上面的thenComparing items.sort(Comparator.comparing(Item::getName).thenComparing(Comparator.comparingInt(Item::getPrice))); System.out.println(&quot;after using thenComparing: &quot; + items); &#125; 上述main函数的输出： 12[Item&#123;name=&apos;orange&apos;, price=50&#125;, Item&#123;name=&apos;banana&apos;, price=100&#125;, Item&#123;name=&apos;orange&apos;, price=100&#125;, Item&#123;name=&apos;apple&apos;, price=400&#125;]after using thenComparing: [Item&#123;name=&apos;apple&apos;, price=400&#125;, Item&#123;name=&apos;banana&apos;, price=100&#125;, Item&#123;name=&apos;orange&apos;, price=50&#125;, Item&#123;name=&apos;orange&apos;, price=100&#125;] NavigableMap接口123456789101112131415161718192021222324252627282930313233343536373839404142public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123; //返回键小于且最接近Key（不包含等于）的键值对，没有返回null Map.Entry&lt;K,V&gt; lowerEntry(K key); //返回小于且最接近（不包含等于）Key的键，没有返回null K lowerKey(K key); //返回键小于且最接近（包含等于）Key的键值对，没有返回null Map.Entry&lt;K,V&gt; floorEntry(K key); //返回小于且最接近（包含等于）Key的键，没有返回null K floorKey(K key); //返回大于且最接近（包含等于）给定key的键值对，没有返回null Map.Entry&lt;K,V&gt; ceilingEntry(K key); //同上 K ceilingKey(K key); //返回大于且最接近（不包含等于）给定key的键值对 Map.Entry&lt;K,V&gt; higherEntry(K key); //同上 K higherKey(K key); //返回第一个Entry Map.Entry&lt;K,V&gt; firstEntry(); //返回最后一个Entry Map.Entry&lt;K,V&gt; lastEntry(); //移除并返回第一个Entry Map.Entry&lt;K,V&gt; pollFirstEntry(); //同上 Map.Entry&lt;K,V&gt; pollLastEntry(); //返回map中包含的映射关系的逆序视图 NavigableMap&lt;K,V&gt; descendingMap(); //返回map中包含的键的NavigableSet视图。 set的迭代器按key的升序 NavigableSet&lt;K&gt; navigableKeySet(); //逆序 NavigableSet&lt;K&gt; descendingKeySet(); //根据fromKey和toKey来返回子map，两个boolean参数用于是否包含该key NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); //返回小于（或等于,根据inclusive）toKey的map NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive); //返回大于（或等于,根据inclusive）fromKey的map NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive); SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey); SortedMap&lt;K,V&gt; headMap(K toKey); SortedMap&lt;K,V&gt; tailMap(K fromKey);&#125; 注意：上述返回的map与原map是相互影响的。 主要方法详细的看下面的参考链接吧。 参考http://www.cnblogs.com/joemsu/p/7940843.html","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"Collections","slug":"Collections","permalink":"http://zhangbuzola.cn/tags/Collections/"},{"name":"TreeMap","slug":"TreeMap","permalink":"http://zhangbuzola.cn/tags/TreeMap/"}]},{"title":"java集合之Map等接口","slug":"java集合之Map等接口","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/04/27/java集合之Map等接口/","link":"","permalink":"http://zhangbuzola.cn/2018/04/27/java集合之Map等接口/","excerpt":"","text":"整体框架图 Iterator接口12345678910111213141516171819public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException(&quot;remove&quot;); &#125; /** * 举个简单例子（把集合里的元素每个都输出出来）： * List&lt;String&gt; names = new ArrayList&lt;&gt;(); * names.add(&quot;Joemsu&quot;); * names.add(&quot;GodnessY&quot;); * names.iterator().forEachRemaining(c -&gt; System.out.println(&quot;hi! &quot; + c)); */ default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; Collection接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; //值得一提的是:如果size超过Integer.MAX_VALUE也只会返回Integer.MAX_VALUE int size(); boolean isEmpty(); //如果向集合里添加null，使用contains(null)，也可以返回true boolean contains(Object o); Iterator&lt;E&gt; iterator(); /** * 深层拷贝，修改数组的数据不会对集合里的元素产生影响。 * 注意：只能返回Object[],不能强制转换其他类型，如需要转型，使用下面带泛型的方法。 */ Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); //保留c集合里的元素 boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); //如过a.equals(b)，则hashCode()肯定相同，反之不一定 int hashCode(); //针对parallelStream()添加的方法，用于分割集合，进行并行处理 @Override default Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0); &#125; /** * 如果满足filter，则删除，举个栗子： * Collection&lt;String&gt; myHeart = new ArrayList&lt;&gt;(); * myHeart.add(&quot;Boduolaoshi&quot;); * myHeart.add(&quot;GodnessY&quot;); * System.out.println(&quot;before: &quot; + myHeart.size()); * myHeart.removeIf(s -&gt; s.equals(&quot;Boduolaoshi&quot;)); * System.out.println(&quot;after: &quot; + myHeart.size()); */ default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed; &#125; default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false); &#125; //采用并行处理，使用多核cpu的特性 default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true); &#125;&#125; Set接口 Set的各种底层实现都是对应的Map，熟悉了Map里的各种方法，相信对于Set的了解也会更加深入。 1234// HashMap就是HashSet里实现具体操作的对象private transient HashMap&lt;E,Object&gt; map;// 将对象作为Value存进去private static final Object PRESENT = new Object(); set集合储存特点： 不允许元素重复 不记录添加顺序 Set判断俩个对象是否相等用equals，而不是使用==。也就是说，俩个对象.equals比较返回true，Set集合是不会接受这俩个对象的。 HashsetHashSet是Set接口最常用的实现类，顾名思义，底层采用了哈希表算法（散列/Hash）。 其实底层也是一个数组，存在的意义是提供查询速度，插入速度较快，但是适用于少量数据的插入操作。 在HashSet中如何判断俩个对象是否相等（俩个条件必须同时满足）： 俩个对象的hashcode方法返回值相等。 俩个对象的equals比较相等，返回true，则说明是相同对象。 对象的hashCode值决定了在哈希表中的存储位置。 当我们往HashSet集合添加新的对象的时候，由于Set集合不允许元素重复，所以他会做检查。首先他先会判断新对象的hashCode值： 如果hashCode值对应的位置没有元素对象，则存放成功。 如果hashCode值对应的位置有元素对象，他会使用equals方法，二者做比较，若返回true，则视为同一个对象，添加失败。若返回false，则非常麻烦，储存在之前对象同槽位的链表上，我们拒绝这种方法。 存储在哈希表中的对象，都应该覆盖equals方法和hasCode方法，并且保证equals相等的时候hasCode也相等。 LinkedHashSetlist接口：允许元素重复，记录元素的先后顺序。 Set接口：不允许元素重复，不记录元素的先后顺序。 需求：不允许元素重复，记录元素的先后添加顺序。 LinkedHashSet：底层采用hash算法和链表算法。 hash表来保证唯一性，此时就是HashSet，在哈希表中元素没有先后顺序。 链表：来记录元素的先后顺序。 LinkedHashSet类是HashSet的子类。 TreeSetTreeSet集合底层采用红黑树算法，会对储存的元素默认使用自然顺序排序（从小到大）。 注意：必须保证TreeSet集合中的元素是相同的数据类型，否则报错；（泛型的使用）。 TreeSet类 实现 NavigableSet接口（可做范围查询集合） 继承 SortedSet接口（可做排序的集合） 比较Set接口三个实现类的共同特点： 不允许元素重复。 都不是线程安全的类。 解决方案：Set s = Collection.synchronizedSet(Set对象); HashSetHashSet：不保证元素的先后顺序。底层采用的是哈希表算法，查询效率极高。 判断俩个对象相等的规则： equals比较为true； hashCode值相同； 要求：要求存在哈希表中的元素对象都得覆盖equals和hasCode方法。 LinkedHashSetHashSet的子类，底层也采用的是哈希算法，但是也使用了链表算法来维持元素 的 先后添加顺序。 判断俩个对象相等的规则和hashset相同。 因为需要多使用一个链表来记录元素的顺序，所以性能相对于HashSet较低。 一般少用没如果要求一个集合既要保证元素不重复，也需要记录先后添加顺序，才选择使用LinkedHashSet。 TreeSetTreeSet：不保证元素的先后添加顺序，但是会对集合中的元素做排序操作。 底层采用红黑树算法（树结构，比较擅长做范围查询）。 HashSet做等值查询查询效率比较高；TreeSet做范围查询效率高。 Map接口Map接口和Collection接口的不同是它是一种映射关系，是二元的。Map接口中需要存放两种值，key和values。而且key的值都是不可重复的。Map&lt;key,values&gt;中的key和values的值是存放在Map.Entry&lt;key,values&gt;中的。 继承结构12345678910111213Type Parameters:K - the type of keys maintained by this mapV - the type of mapped valuesAll Known Subinterfaces:Bindings, ConcurrentMap&lt;K,V&gt;, ConcurrentNavigableMap&lt;K,V&gt;, LogicalMessageContext, MessageContext, NavigableMap&lt;K,V&gt;, SOAPMessageContext, SortedMap&lt;K,V&gt;All Known Implementing Classes:AbstractMap, Attributes, AuthProvider, ConcurrentHashMap,ConcurrentSkipListMap, EnumMap, HashMap, Hashtable, IdentityHashMap, LinkedHashMap, PrinterStateReasons,Properties, Provider, RenderingHints, SimpleBindings, TabularDataSupport, TreeMap, UIDefaults, WeakHashMap java8 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239public interface Map&lt;K,V&gt; &#123; //同样的，如果size超过Integer.MAX_VALUE也只会返回Integer.MAX_VALUE int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); V get(Object key); V put(K key, V value); V remove(Object key); void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); //对set的变动会影响到map，反过来也一样 Set&lt;K&gt; keySet(); //对Collection的变动会影响到map，反过来也一样 Collection&lt;V&gt; values(); //对Set的变动会影响到map，反过来也一样 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); boolean equals(Object o); int hashCode(); //Entry start interface Entry&lt;K,V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); //使用默认方法对Key进行比较 public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey()&#123; return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey()); &#125; //使用默认方法对Value比较 public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123; return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue()); &#125; /** * 自己传比较的方法，举个栗子： * Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); * map.put(&quot;sorted&quot;, 2); * map.put(&quot;collect&quot;, 1); * map.put(&quot;each&quot;, 3); * System.out.println(&quot;before sort&quot;); * map.entrySet().forEach(System.out::println); * System.out.println(&quot;after sort&quot;); * map.entrySet() * .stream() * .sorted(Map.Entry.comparingByKey((a, b) -&gt; a.length() - b.length())) * .collect(Collectors.toList()).forEach(System.out::println); */ public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) &#123; Objects.requireNonNull(cmp); return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey()); &#125; public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) &#123; Objects.requireNonNull(cmp); return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue()); &#125; &#125; //Entry end //获取指定key 的value，没有则返回默认值 default V getOrDefault(Object key, V defaultValue) &#123; V v; return (((v = get(key)) != null) || containsKey(key)) ? v : defaultValue; &#125; /** * 对每队键值对操作： map.forEach((i, j) -&gt; System.out.println(i + j)) * 注意这里的(i, j)的类型与你初始化map的键值类型对应，i即K, j即V */ default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Objects.requireNonNull(action); for (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123; K k; V v; try &#123; k = entry.getKey(); v = entry.getValue(); &#125; catch(IllegalStateException ise) &#123; // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); &#125; action.accept(k, v); &#125; &#125; /** * 传入BiFunction类型，对每个键值对进行处理，返回类型与V类型相同 * Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); * map.put(&quot;hi&quot;, 3); * map.put(&quot;hello&quot;, 4); * BiFunction&lt;String, Integer, Integer&gt; bi = (a, b) -&gt; a.length() + b; //为了容易理解，这么写 * map.forEach((i, j) -&gt; System.out.println(i + &quot;:&quot; + j)); * map.replaceAll(bi); * map.forEach((i, j) -&gt; System.out.println(i + &quot;:&quot; + j)); */ default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; Objects.requireNonNull(function); for (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123; K k; V v; try &#123; k = entry.getKey(); v = entry.getValue(); &#125; catch(IllegalStateException ise) &#123; // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); &#125; // ise thrown from function is not a cme. v = function.apply(k, v); try &#123; entry.setValue(v); &#125; catch(IllegalStateException ise) &#123; // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); &#125; &#125; &#125; //如果为空的话，插入 default V putIfAbsent(K key, V value) &#123; V v = get(key); if (v == null) &#123; v = put(key, value); &#125; return v; &#125; default boolean remove(Object key, Object value) &#123; Object curValue = get(key); if (!Objects.equals(curValue, value) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false; &#125; remove(key); return true; &#125; default boolean replace(K key, V oldValue, V newValue) &#123; Object curValue = get(key); if (!Objects.equals(curValue, oldValue) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false; &#125; put(key, newValue); return true; &#125; default V replace(K key, V value) &#123; V curValue; if (((curValue = get(key)) != null) || containsKey(key)) &#123; curValue = put(key, value); &#125; return curValue; &#125; //如果key不存在，则通过mappingFunction生成value，并插入 default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; Objects.requireNonNull(mappingFunction); V v; if ((v = get(key)) == null) &#123; V newValue; if ((newValue = mappingFunction.apply(key)) != null) &#123; put(key, newValue); return newValue; &#125; &#125; return v; &#125; //如果存在key对应的值，则通过remappingFunction来计算新的value，（value不为空）然后更新，为空则删除key default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); V oldValue; if ((oldValue = get(key)) != null) &#123; V newValue = remappingFunction.apply(key, oldValue); if (newValue != null) &#123; put(key, newValue); return newValue; &#125; else &#123; remove(key); return null; &#125; &#125; else &#123; return null; &#125; &#125; default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); V oldValue = get(key); V newValue = remappingFunction.apply(key, oldValue); if (newValue == null) &#123; // delete mapping if (oldValue != null || containsKey(key)) &#123; // something to remove remove(key); return null; &#125; else &#123; // nothing to do. Leave things as they were. return null; &#125; &#125; else &#123; // add or replace old mapping put(key, newValue); return newValue; &#125; &#125; //将旧的oldValue和新的传进去value通过remappingFunction进行处理，然后更新 default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); Objects.requireNonNull(value); V oldValue = get(key); V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value); if(newValue == null) &#123; remove(key); &#125; else &#123; put(key, newValue); &#125; return newValue; &#125;&#125; List接口List接口是定义一个允许重复项的有序集合，与set的区别在于List都是线性存放的。下面有三个常用实现类，ArrayList，LinkedList，Vector。 ArrayListArrayList：是一种会扩充的Array，Array是一个长度确定的数组,Arraylist则是不用实现知道数组长度。比如：在游戏中每隔一段时间生成一队小兵对象，这个数量是未知的且会变化的。它的特点就是能动态增容。但是在内存中的实现依旧是以数组的方式实现的，当数组内存不够时则会自动扩充一小段内存。 优点：具有直接根据索引下标进行数据查找的功能，直接根据引用和索引确定在内存中的位置直接读取，索引时间复杂度为常数； 缺点：具有数组的通病，当增加或删除一个数据时，最多可能移动数组长个数据，时间复杂度为N；另若是当添加元素大于初始容器容量时，需要进行扩充，将旧数据复制到新的大数组中,具体实现为，调用了ensureCapacity(size+1)方法，之后将元素的索引赋给elementData[size]，而后size自增。一般每次扩充为原来的1.5倍。 ArrayList不是线程安全的，因此不适合存在于多线程中，但是在我以往的经验中也用过，需要对这个实例出的对象使用synchronized也可以考虑使用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，但是我还没有用过。 ArrayList的代码实现的功能包括:set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法，还有如remove（int index），remove（E element）removeRange(int Fromindex,int toindex )delete（）的删除元素方法。还有如get（int index）等获取方法。 LinkedListLinkedList：上面描述的Arraylist是根据数组Array实现的，而LinkedList就是根据链表实现的，它包括了链表的优点，增减迅速，占内存分散。LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。由于LinkedList还提供了头节点和尾节点，这些操作允许将链接列表用作堆栈、队列或双端队列 (deque)。 一般都会将ArrayList和LinkedList作比较，他们的区别最主要也就是数组和链表的区别，需要根据背景来使用，比如一个随机寻找的功能，显然ArrayList更适合，若是一个大批量数据插入问题，则LinkedList更适合。 Vectorvector：和ArrayList在实现方式，优缺点很相似，但是它是同步的，也就是说适合于多线程中，每次只能有一个线程对其进行操作，但是实现同步需要很高的花费，因此在访问方面略慢于ArrayList。vector的自我扩充一般是原默认值的两倍。 参考https://docs.oracle.com/javase/8/docs/api/index.html http://www.cnblogs.com/joemsu/p/7667588.html","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"Collections","slug":"Collections","permalink":"http://zhangbuzola.cn/tags/Collections/"}]},{"title":"Java集合之LinkedHashMap","slug":"java集合之LinkedHashMap","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/04/12/java集合之LinkedHashMap/","link":"","permalink":"http://zhangbuzola.cn/2018/04/12/java集合之LinkedHashMap/","excerpt":"","text":"LinkedHashMap简介在使用HashMap的时候，可能会遇到需要按照当时put的顺序来进行哈希表的遍历。通过上篇对HashMap的了解，我们知道HashMap中不存在保存顺序的机制。 本篇文章要介绍的LinkedHashMap专为此特性而生。在LinkedHashMap中可以保持两种顺序，分别是插入顺序和访问顺序，这个是可以在LinkedHashMap的初始化方法中进行指定的。相对于访问顺序，按照插入顺序进行编排被使用到的场景更多一些，所以默认是按照插入顺序进行编排。 看一下实际的运行效果，测试代码如下： 1234567891011121314151617public static void main(String[] args) &#123; Map&lt;String, String&gt; test = new LinkedHashMap&lt;String, String&gt;(9); test.put(&quot;化学&quot;,&quot;93&quot;); test.put(&quot;数学&quot;,&quot;98&quot;); test.put(&quot;生物&quot;,&quot;92&quot;); test.put(&quot;英语&quot;,&quot;97&quot;); test.put(&quot;物理&quot;,&quot;94&quot;); test.put(&quot;历史&quot;,&quot;96&quot;); test.put(&quot;语文&quot;,&quot;99&quot;); test.put(&quot;地理&quot;,&quot;95&quot;); for (Map.Entry entry : test.entrySet()) &#123; System.out.println(entry.getKey().toString() + &quot;:&quot; + entry.getValue().toString()); &#125;&#125;// 运行结果输出的顺序与插入的顺序是一致的。 几点总结： 底层是散列表和双向链表 允许为null，不同步 插入的顺序是有序的(底层链表致使有序) 装载因子和初始容量对LinkedHashMap影响是很大的~ LinkedHashMap 原理在LinkedHashMap中，是通过双联表的结构来维护节点的顺序的。上文中的程序，实际上在内存中的情况如下图所示，每个节点都进行了双向的连接，维持插入的顺序（默认）。head指向第一个插入的节点，tail指向最后一个节点。 LinkedHashMap是HashMap的亲儿子，直接继承HashMap类。LinkedHashMap中的节点元素为Entry&lt;K,V&gt;，直接继承HashMap.Node&lt;K,V&gt;。UML类图关系如下： 重写的方法 构造方法LinkedHashMap有5个构造方法： LinkedHashMap和HashMap的put方法是一样的！LinkedHashMap继承着HashMap，LinkedHashMap没有重写HashMap的put方法 参考https://zhuanlan.zhihu.com/p/35559602 https://zhuanlan.zhihu.com/p/38431159 http://www.cnblogs.com/joemsu/p/7787043.html","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"Collections","slug":"Collections","permalink":"http://zhangbuzola.cn/tags/Collections/"},{"name":"LinkedHashMap","slug":"LinkedHashMap","permalink":"http://zhangbuzola.cn/tags/LinkedHashMap/"}]},{"title":"java集合之TreeMap","slug":"java_treemap","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2018/04/11/java_treemap/","link":"","permalink":"http://zhangbuzola.cn/2018/04/11/java_treemap/","excerpt":"","text":"TreeMap前述 TreeMap是一个有序的key-value集合，通过红黑树实现； 继承了AbstractMap， 所以它是一个Map，也就是一个key-value集合； 实现了NavigableMap接口，支持一系列的导航方法。比如返回有序的key集合； 实现了Cloneable接口，能被克隆； java.io.Serializable接口，意味着支持序列化； TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。 构造函数1234567891011// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。TreeMap()// 创建的TreeMap包含MapTreeMap(Map&lt;? extends K, ? extends V&gt; copyFrom)// 指定Tree的比较器TreeMap(Comparator&lt;? super K&gt; comparator)// 创建的TreeSet包含copyFromTreeMap(SortedMap&lt;K, ? extends V&gt; copyFrom) treeMap的API12345678910111213141516171819202122232425262728293031323334Entry&lt;K, V&gt; ceilingEntry(K key)K ceilingKey(K key)void clear()Object clone()Comparator&lt;? super K&gt; comparator()boolean containsKey(Object key)NavigableSet&lt;K&gt; descendingKeySet()NavigableMap&lt;K, V&gt; descendingMap()Set&lt;Entry&lt;K, V&gt;&gt; entrySet()Entry&lt;K, V&gt; firstEntry()K firstKey()Entry&lt;K, V&gt; floorEntry(K key)K floorKey(K key)V get(Object key)NavigableMap&lt;K, V&gt; headMap(K to, boolean inclusive)SortedMap&lt;K, V&gt; headMap(K toExclusive)Entry&lt;K, V&gt; higherEntry(K key)K higherKey(K key)boolean isEmpty()Set&lt;K&gt; keySet()Entry&lt;K, V&gt; lastEntry()K lastKey()Entry&lt;K, V&gt; lowerEntry(K key)K lowerKey(K key)NavigableSet&lt;K&gt; navigableKeySet()Entry&lt;K, V&gt; pollFirstEntry()Entry&lt;K, V&gt; pollLastEntry()V put(K key, V value)V remove(Object key)int size()SortedMap&lt;K, V&gt; subMap(K fromInclusive, K toExclusive)NavigableMap&lt;K, V&gt; subMap(K from, boolean fromInclusive, K to, boolean toInclusive)NavigableMap&lt;K, V&gt; tailMap(K from, boolean inclusive)SortedMap&lt;K, V&gt; tailMap(K fromInclusive) treeMap的数据结构继承关系1234567java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.TreeMap&lt;K, V&gt;public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;&#125; 继承关系图： 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050package java.util;public class TreeMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt;implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; // 比较器。用来给TreeMap排序 private final Comparator&lt;? super K&gt; comparator; // TreeMap是红黑树实现的，root是红黑书的根节点 private transient Entry&lt;K,V&gt; root = null; // 红黑树的节点总数 private transient int size = 0; // 记录红黑树的修改次数 private transient int modCount = 0; // 默认构造函数 public TreeMap() &#123; comparator = null; &#125; // 带比较器的构造函数 public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator; &#125; // 带Map的构造函数，Map会成为TreeMap的子集 public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m); &#125; // 带SortedMap的构造函数，SortedMap会成为TreeMap的子集 public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; &#125; public int size() &#123; return size; &#125; // 返回TreeMap中是否保护“键(key)” public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回TreeMap中是否保护&quot;值(value)&quot; public boolean containsValue(Object value) &#123; // getFirstEntry() 是返回红黑树的第一个节点 // successor(e) 是获取节点e的后继节点 for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) if (valEquals(value, e.value)) return true; return false; &#125; // 获取“键(key)”对应的“值(value)” public V get(Object key) &#123; // 获取“键”为key的节点(p) Entry&lt;K,V&gt; p = getEntry(key); // 若节点(p)为null，返回null；否则，返回节点对应的值 return (p==null ? null : p.value); &#125; public Comparator&lt;? super K&gt; comparator() &#123; return comparator; &#125; // 获取第一个节点对应的key public K firstKey() &#123; return key(getFirstEntry()); &#125; // 获取最后一个节点对应的key public K lastKey() &#123; return key(getLastEntry()); &#125; // 将map中的全部节点添加到TreeMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; // 获取map的大小 int mapSize = map.size(); // 如果TreeMap的大小是0,且map的大小不是0,且map是已排序的“key-value对” if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) &#123; Comparator c = ((SortedMap)map).comparator(); // 如果TreeMap和map的比较器相等； // 则将map的元素全部拷贝到TreeMap中，然后返回！ if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) &#123; ++modCount; try &#123; buildFromSorted(mapSize, map.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return; &#125; &#125; // 调用AbstractMap中的putAll(); // AbstractMap中的putAll()又会调用到TreeMap的put() super.putAll(map); &#125; // 获取TreeMap中“键”为key的节点 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 若“比较器”为null，则通过getEntryUsingComparator()获取“键”为key的节点 if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的左孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; &#125; return null; &#125; // 获取TreeMap中“键”为key的节点(对应TreeMap的比较器不是null的情况) final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = cpr.compare(k, p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的左孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; &#125; &#125; return null; &#125; // 获取TreeMap中不小于key的最小的节点； // 若不存在(即TreeMap中所有节点的键都比key大)，就返回null final Entry&lt;K,V&gt; getCeilingEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); // 情况一：若“p的key” &gt; key。 // 若 p 存在左孩子，则设 p=“p的左孩子”； // 否则，返回p if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; // 情况二：若“p的key” &lt; key。 &#125; else if (cmp &gt; 0) &#123; // 若 p 存在右孩子，则设 p=“p的右孩子” if (p.right != null) &#123; p = p.right; &#125; else &#123; // 若 p 不存在右孩子，则找出 p 的后继节点，并返回 // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。 // 理解这一点的核心是，getCeilingEntry是从root开始遍历的。 // 若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。 // 能理解上面所说的，那么就很容易明白，为什么“p的后继节点”又2种可能性了。 Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; // 情况三：若“p的key” = key。 &#125; else return p; &#125; return null; &#125; // 获取TreeMap中不大于key的最大的节点； // 若不存在(即TreeMap中所有节点的键都比key小)，就返回null // getFloorEntry的原理和getCeilingEntry类似，这里不再多说。 final Entry&lt;K,V&gt; getFloorEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else if (cmp &lt; 0) &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; else return p; &#125; return null; &#125; // 获取TreeMap中大于key的最小的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getHigherEntry进行理解。 final Entry&lt;K,V&gt; getHigherEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; &#125; else &#123; if (p.right != null) &#123; p = p.right; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; // 获取TreeMap中小于key的最大的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getLowerEntry进行理解。 final Entry&lt;K,V&gt; getLowerEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; // 将“key, value”添加到TreeMap中 // 理解TreeMap的前提是掌握“红黑树”。 // 若理解“红黑树中添加节点”的算法，则很容易理解put。 public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; // 若红黑树为空，则插入根节点 if (t == null) &#123; // TBD: // 5045147: (coll) Adding null to an empty TreeSet should // throw NullPointerException // // compare(key, key); // type check root = new Entry&lt;K,V&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; // 在二叉树(红黑树是特殊的二叉树)中，找到(key, value)的插入位置。 // 红黑树是以key来进行排序的，所以这里以key来进行查找。 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 新建红黑树的节点(e) Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; // 红黑树插入节点后，不再是一颗红黑树； // 这里通过fixAfterInsertion的处理，来恢复红黑树的特性。 fixAfterInsertion(e); size++; modCount++; return null; &#125; // 删除TreeMap中的键为key的节点，并返回节点的值 public V remove(Object key) &#123; // 找到键为key的节点 Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; // 保存节点的值 V oldValue = p.value; // 删除节点 deleteEntry(p); return oldValue; &#125; // 清空红黑树 public void clear() &#123; modCount++; size = 0; root = null; &#125; // 克隆一个TreeMap，并返回Object对象 public Object clone() &#123; TreeMap&lt;K,V&gt; clone = null; try &#123; clone = (TreeMap&lt;K,V&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // Put clone into &quot;virgin&quot; state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try &#123; clone.buildFromSorted(size, entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return clone; &#125; // 获取第一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(getFirstEntry()); &#125; // 获取最后一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(getLastEntry()); &#125; // 获取第一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; // 获取第一个节点 Entry&lt;K,V&gt; p = getFirstEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除第一个节点 if (p != null) deleteEntry(p); return result; &#125; // 获取最后一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollLastEntry() &#123; // 获取最后一个节点 Entry&lt;K,V&gt; p = getLastEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除最后一个节点 if (p != null) deleteEntry(p); return result; &#125; // 返回小于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(getLowerEntry(key)); &#125; // 返回小于key的最大的键值对所对应的KEY，没有的话返回null public K lowerKey(K key) &#123; return keyOrNull(getLowerEntry(key)); &#125; // 返回不大于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(getFloorEntry(key)); &#125; // 返回不大于key的最大的键值对所对应的KEY，没有的话返回null public K floorKey(K key) &#123; return keyOrNull(getFloorEntry(key)); &#125; // 返回不小于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(getCeilingEntry(key)); &#125; // 返回不小于key的最小的键值对所对应的KEY，没有的话返回null public K ceilingKey(K key) &#123; return keyOrNull(getCeilingEntry(key)); &#125; // 返回大于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(getHigherEntry(key)); &#125; // 返回大于key的最小的键值对所对应的KEY，没有的话返回null public K higherKey(K key) &#123; return keyOrNull(getHigherEntry(key)); &#125; // TreeMap的红黑树节点对应的集合 private transient EntrySet entrySet = null; // KeySet为KeySet导航类 private transient KeySet&lt;K&gt; navigableKeySet = null; // descendingMap为键值对的倒序“映射” private transient NavigableMap&lt;K,V&gt; descendingMap = null; // 返回TreeMap的“键的集合” public Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 获取“可导航”的Key的集合 // 实际上是返回KeySet类的对象。 public NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nks = navigableKeySet; return (nks != null) ? nks : (navigableKeySet = new KeySet(this)); &#125; // 返回“TreeMap的值对应的集合” public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values()); &#125; // 获取TreeMap的Entry的集合，实际上是返回EntrySet类的对象。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet()); &#125; // 获取TreeMap的降序Map // 实际上是返回DescendingSubMap类的对象 public NavigableMap&lt;K, V&gt; descendingMap() &#123; NavigableMap&lt;K, V&gt; km = descendingMap; return (km != null) ? km : (descendingMap = new DescendingSubMap(this, true, null, true, true, null, true)); &#125; // 获取TreeMap的子Map // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; return new AscendingSubMap(this, false, fromKey, fromInclusive, false, toKey, toInclusive); &#125; // 获取“Map的头部” // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; return new AscendingSubMap(this, true, null, true, false, toKey, inclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) &#123; return new AscendingSubMap(this, false, fromKey, inclusive, true, null, true); &#125; // 获取“子Map”。 // 范围是从fromKey(包括) 到 toKey(不包括) public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey(不包括) public SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey(包括) 到 最后一个节点 public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // ”TreeMap的值的集合“对应的类，它集成于AbstractCollection class Values extends AbstractCollection&lt;V&gt; &#123; // 返回迭代器 public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(getFirstEntry()); &#125; // 返回个数 public int size() &#123; return TreeMap.this.size(); &#125; // &quot;TreeMap的值的集合&quot;中是否包含&quot;对象o&quot; public boolean contains(Object o) &#123; return TreeMap.this.containsValue(o); &#125; // 删除&quot;TreeMap的值的集合&quot;中的&quot;对象o&quot; public boolean remove(Object o) &#123; for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) &#123; if (valEquals(e.getValue(), o)) &#123; deleteEntry(e); return true; &#125; &#125; return false; &#125; // 清空删除&quot;TreeMap的值的集合&quot; public void clear() &#123; TreeMap.this.clear(); &#125; &#125; // EntrySet是“TreeMap的所有键值对组成的集合”， // EntrySet集合的单位是单个“键值对”。 class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(getFirstEntry()); &#125; // EntrySet中是否包含“键值对Object” public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); return p != null &amp;&amp; valEquals(p.getValue(), value); &#125; // 删除EntrySet中的“键值对Object” public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); if (p != null &amp;&amp; valEquals(p.getValue(), value)) &#123; deleteEntry(p); return true; &#125; return false; &#125; // 返回EntrySet中元素个数 public int size() &#123; return TreeMap.this.size(); &#125; // 清空EntrySet public void clear() &#123; TreeMap.this.clear(); &#125; &#125; // 返回“TreeMap的KEY组成的迭代器(顺序)” Iterator&lt;K&gt; keyIterator() &#123; return new KeyIterator(getFirstEntry()); &#125; // 返回“TreeMap的KEY组成的迭代器(逆序)” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingKeyIterator(getLastEntry()); &#125; // KeySet是“TreeMap中所有的KEY组成的集合” // KeySet继承于AbstractSet，而且实现了NavigableSet接口。 static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; &#123; // NavigableMap成员，KeySet是通过NavigableMap实现的 private final NavigableMap&lt;E, Object&gt; m; KeySet(NavigableMap&lt;E,Object&gt; map) &#123; m = map; &#125; // 升序迭代器 public Iterator&lt;E&gt; iterator() &#123; // 若是TreeMap对象，则调用TreeMap的迭代器keyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器keyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).keyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).keyIterator()); &#125; // 降序迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; // 若是TreeMap对象，则调用TreeMap的迭代器descendingKeyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器descendingKeyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).descendingKeyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).descendingKeyIterator()); &#125; public int size() &#123; return m.size(); &#125; public boolean isEmpty() &#123; return m.isEmpty(); &#125; public boolean contains(Object o) &#123; return m.containsKey(o); &#125; public void clear() &#123; m.clear(); &#125; public E lower(E e) &#123; return m.lowerKey(e); &#125; public E floor(E e) &#123; return m.floorKey(e); &#125; public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; public E higher(E e) &#123; return m.higherKey(e); &#125; public E first() &#123; return m.firstKey(); &#125; public E last() &#123; return m.lastKey(); &#125; public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; public E pollFirst() &#123; Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry(); return e == null? null : e.getKey(); &#125; public E pollLast() &#123; Map.Entry&lt;E,Object&gt; e = m.pollLastEntry(); return e == null? null : e.getKey(); &#125; public boolean remove(Object o) &#123; int oldSize = size(); m.remove(o); return size() != oldSize; &#125; public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; public NavigableSet&lt;E&gt; descendingSet() &#123; return new TreeSet(m.descendingMap()); &#125; &#125; // 它是TreeMap中的一个抽象迭代器，实现了一些通用的接口。 abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // 上一次返回元素 Entry&lt;K,V&gt; lastReturned; // 期望的修改次数，用于实现fast-fail机制 int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123; expectedModCount = modCount; lastReturned = null; next = first; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个节点 final Entry&lt;K,V&gt; nextEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; &#125; // 获取上一个节点 final Entry&lt;K,V&gt; prevEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点 public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，&apos;新的当前节点&apos;实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向&quot;新的当前节点&quot;。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; &#125; &#125; // TreeMap的Entry对应的迭代器 final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntryIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // TreeMap的Value对应的迭代器 final class ValueIterator extends PrivateEntryIterator&lt;V&gt; &#123; ValueIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public V next() &#123; return nextEntry().value; &#125; &#125; // reeMap的KEY组成的迭代器(顺序) final class KeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; KeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return nextEntry().key; &#125; &#125; // TreeMap的KEY组成的迭代器(逆序) final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return prevEntry().key; &#125; &#125; // 比较两个对象的大小 final int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2); &#125; // 判断两个对象是否相等 final static boolean valEquals(Object o1, Object o2) &#123; return (o1==null ? o2==null : o1.equals(o2)); &#125; // 返回“Key-Value键值对”的一个简单拷贝(AbstractMap.SimpleImmutableEntry&lt;K,V&gt;对象) // 可用来读取“键值对”的值 static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e); &#125; // 若“键值对”不为null，则返回KEY；否则，返回null static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : e.key; &#125; // 若“键值对”不为null，则返回KEY；否则，抛出异常 static &lt;K&gt; K key(Entry&lt;K,?&gt; e) &#123; if (e==null) throw new NoSuchElementException(); return e.key; &#125; // TreeMap的SubMap，它一个抽象类，实现了公共操作。 // 它包括了&quot;(升序)AscendingSubMap&quot;和&quot;(降序)DescendingSubMap&quot;两个子类。 static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, java.io.Serializable &#123; // TreeMap的拷贝 final TreeMap&lt;K,V&gt; m; // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”； // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记” // fromStart是“表示是否从第一个节点开始计算”， // toEnd是“表示是否计算到最后一个节点 ” final K lo, hi; final boolean fromStart, toEnd; final boolean loInclusive, hiInclusive; // 构造函数 NavigableSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; if (!fromStart &amp;&amp; !toEnd) &#123; if (m.compare(lo, hi) &gt; 0) throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;); &#125; else &#123; if (!fromStart) // type check m.compare(lo, lo); if (!toEnd) m.compare(hi, hi); &#125; this.m = m; this.fromStart = fromStart; this.lo = lo; this.loInclusive = loInclusive; this.toEnd = toEnd; this.hi = hi; this.hiInclusive = hiInclusive; &#125; // 判断key是否太小 final boolean tooLow(Object key) &#123; // 若该SubMap不包括“起始节点”， // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内” // 则判断key太小。其余情况都不是太小！ if (!fromStart) &#123; int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; &#125; return false; &#125; // 判断key是否太大 final boolean tooHigh(Object key) &#123; // 若该SubMap不包括“结束节点”， // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内” // 则判断key太大。其余情况都不是太大！ if (!toEnd) &#123; int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; &#125; return false; &#125; // 判断key是否在“lo和hi”开区间范围内 final boolean inRange(Object key) &#123; return !tooLow(key) &amp;&amp; !tooHigh(key); &#125; // 判断key是否在封闭区间内 final boolean inClosedRange(Object key) &#123; return (fromStart || m.compare(key, lo) &gt;= 0) &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0); &#125; // 判断key是否在区间内, inclusive是区间开关标志 final boolean inRange(Object key, boolean inclusive) &#123; return inclusive ? inRange(key) : inClosedRange(key); &#125; // 返回最低的Entry final TreeMap.Entry&lt;K,V&gt; absLowest() &#123; // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点 // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry; // 否则，调用getHigherEntry(lo)获取大于lo的最小Entry TreeMap.Entry&lt;K,V&gt; e = (fromStart ? m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo))); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回最高的Entry final TreeMap.Entry&lt;K,V&gt; absHighest() &#123; // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点 // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry; // 否则，调用getLowerEntry(hi)获取大于hi的最大Entry TreeMap.Entry&lt;K,V&gt; e = TreeMap.Entry&lt;K,V&gt; e = (toEnd ? m.getLastEntry() : (hiInclusive ? m.getFloorEntry(hi) : m.getLowerEntry(hi))); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回&quot;大于/等于key的最小的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！ if (tooLow(key)) return absLowest(); // 获取“大于/等于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回&quot;大于key的最小的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absHigher(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！ if (tooLow(key)) return absLowest(); // 获取“大于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回&quot;小于/等于key的最大的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absFloor(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！ if (tooHigh(key)) return absHighest(); // 获取&quot;小于/等于key的最大的Entry&quot; TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回&quot;小于key的最大的Entry&quot; final TreeMap.Entry&lt;K,V&gt; absLower(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！ if (tooHigh(key)) return absHighest(); // 获取&quot;小于key的最大的Entry&quot; TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回“大于最大节点中的最小节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absHighFence() &#123; return (toEnd ? null : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi))); &#125; // 返回“小于最小节点中的最大节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absLowFence() &#123; return (fromStart ? null : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo))); &#125; // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法 abstract TreeMap.Entry&lt;K,V&gt; subLowest(); abstract TreeMap.Entry&lt;K,V&gt; subHighest(); abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key); abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key); abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key); abstract TreeMap.Entry&lt;K,V&gt; subLower(K key); // 返回“顺序”的键迭代器 abstract Iterator&lt;K&gt; keyIterator(); // 返回“逆序”的键迭代器 abstract Iterator&lt;K&gt; descendingKeyIterator(); // 返回SubMap是否为空。空的话，返回true，否则返回false public boolean isEmpty() &#123; return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty(); &#125; // 返回SubMap的大小 public int size() &#123; return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size(); &#125; // 返回SubMap是否包含键key public final boolean containsKey(Object key) &#123; return inRange(key) &amp;&amp; m.containsKey(key); &#125; // 将key-value 插入SubMap中 public final V put(K key, V value) &#123; if (!inRange(key)) throw new IllegalArgumentException(&quot;key out of range&quot;); return m.put(key, value); &#125; // 获取key对应值 public final V get(Object key) &#123; return !inRange(key)? null : m.get(key); &#125; // 删除key对应的键值对 public final V remove(Object key) &#123; return !inRange(key)? null : m.remove(key); &#125; // 获取“大于/等于key的最小键值对” public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(subCeiling(key)); &#125; // 获取“大于/等于key的最小键” public final K ceilingKey(K key) &#123; return keyOrNull(subCeiling(key)); &#125; // 获取“大于key的最小键值对” public final Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(subHigher(key)); &#125; // 获取“大于key的最小键” public final K higherKey(K key) &#123; return keyOrNull(subHigher(key)); &#125; // 获取“小于/等于key的最大键值对” public final Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(subFloor(key)); &#125; // 获取“小于/等于key的最大键” public final K floorKey(K key) &#123; return keyOrNull(subFloor(key)); &#125; // 获取“小于key的最大键值对” public final Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(subLower(key)); &#125; // 获取“小于key的最大键” public final K lowerKey(K key) &#123; return keyOrNull(subLower(key)); &#125; // 获取&quot;SubMap的第一个键&quot; public final K firstKey() &#123; return key(subLowest()); &#125; // 获取&quot;SubMap的最后一个键&quot; public final K lastKey() &#123; return key(subHighest()); &#125; // 获取&quot;SubMap的第一个键值对&quot; public final Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(subLowest()); &#125; // 获取&quot;SubMap的最后一个键值对&quot; public final Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(subHighest()); &#125; // 返回&quot;SubMap的第一个键值对&quot;，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subLowest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // 返回&quot;SubMap的最后一个键值对&quot;，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollLastEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subHighest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // Views transient NavigableMap&lt;K,V&gt; descendingMapView = null; transient EntrySetView entrySetView = null; transient KeySet&lt;K&gt; navigableKeySetView = null; // 返回NavigableSet对象，实际上返回的是当前对象的&quot;Key集合&quot;。 public final NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nksv = navigableKeySetView; return (nksv != null) ? nksv : (navigableKeySetView = new TreeMap.KeySet(this)); &#125; // 返回&quot;Key集合&quot;对象 public final Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 返回“逆序”的Key集合 public NavigableSet&lt;K&gt; descendingKeySet() &#123; return descendingMap().navigableKeySet(); &#125; // 排列fromKey(包含) 到 toKey(不包含) 的子map public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey) public final SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点] public final SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // Map的Entry的集合 abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; private transient int size = -1, sizeModCount; // 获取EntrySet的大小 public int size() &#123; // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小 if (fromStart &amp;&amp; toEnd) return m.size(); // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素 if (size == -1 || sizeModCount != m.modCount) &#123; sizeModCount = m.modCount; size = 0; Iterator i = iterator(); while (i.hasNext()) &#123; size++; i.next(); &#125; &#125; return size; &#125; // 判断EntrySetView是否为空 public boolean isEmpty() &#123; TreeMap.Entry&lt;K,V&gt; n = absLowest(); return n == null || tooHigh(n.key); &#125; // 判断EntrySetView是否包含Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry node = m.getEntry(key); return node != null &amp;&amp; valEquals(node.getValue(), entry.getValue()); &#125; // 从EntrySetView中删除Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key); if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue()))&#123; m.deleteEntry(node); return true; &#125; return false; &#125; &#125; // SubMap的迭代器 abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 上一次被返回的Entry TreeMap.Entry&lt;K,V&gt; lastReturned; // 指向下一个Entry TreeMap.Entry&lt;K,V&gt; next; // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义 final K fenceKey; int expectedModCount; // 构造函数 SubMapIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; // 每创建一个SubMapIterator时，保存修改次数 // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。 // 这就是所说的fast-fail机制的原理！ expectedModCount = m.modCount; lastReturned = null; next = first; fenceKey = fence == null ? null : fence.key; &#125; // 是否存在下一个Entry public final boolean hasNext() &#123; return next != null &amp;&amp; next.key != fenceKey; &#125; // 返回下一个Entry final TreeMap.Entry&lt;K,V&gt; nextEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的后继节点 next = successor(e); lastReturned = e; return e; &#125; // 返回上一个Entry final TreeMap.Entry&lt;K,V&gt; prevEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的前继节点 next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点(用于“升序的SubMap”)。 // 删除之后，可以继续升序遍历；红黑树特性没变。 final void removeAscending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，&apos;新的当前节点&apos;实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向&quot;新的当前节点&quot;。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; // 删除当前节点(用于“降序的SubMap”)。 // 删除之后，可以继续降序遍历；红黑树特性没变。 final void removeDescending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; &#125; // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public K next() &#123; return nextEntry().key; &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public Map.Entry&lt;K,V&gt; next() &#123; return prevEntry(); &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public K next() &#123; return prevEntry().key; &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; &#125; // 升序的SubMap，继承于NavigableSubMap static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866124060L; // 构造函数 AscendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 比较器 public Comparator&lt;? super K&gt; comparator() &#123; return m.comparator(); &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new AscendingSubMap(m, false, fromKey, fromInclusive, false, toKey, toInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new AscendingSubMap(m, fromStart, lo, loInclusive, false, toKey, inclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); return new AscendingSubMap(m, false, fromKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new DescendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // “升序EntrySet集合”类 // 实现了iterator() final class AscendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new SubMapEntryIterator(absLowest(), absHighFence()); &#125; &#125; // 返回“升序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new AscendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absHigher(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absLower(key); &#125; &#125; // 降序的SubMap，继承于NavigableSubMap // 相比于升序SubMap，它的实现机制是将“SubMap的比较器反转”！ static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866120460L; DescendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 反转的比较器：是将原始比较器反转得到的。 private final Comparator&lt;? super K&gt; reverseComparator = Collections.reverseOrder(m.comparator); // 获取反转比较器 public Comparator&lt;? super K&gt; comparator() &#123; return reverseComparator; &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new DescendingSubMap(m, false, toKey, toInclusive, false, fromKey, fromInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException(&quot;toKey out of range&quot;); return new DescendingSubMap(m, false, toKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException(&quot;fromKey out of range&quot;); return new DescendingSubMap(m, fromStart, lo, loInclusive, false, fromKey, inclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new AscendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // “降序EntrySet集合”类 // 实现了iterator() final class DescendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new DescendingSubMapEntryIterator(absHighest(), absLowFence()); &#125; &#125; // 返回“降序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new DescendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absLower(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absHigher(key); &#125; &#125; // SubMap是旧版本的类，新的Java中没有用到。 private class SubMap extends AbstractMap&lt;K,V&gt; implements SortedMap&lt;K,V&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -6520786458950516097L; private boolean fromStart = false, toEnd = false; private K fromKey, toKey; private Object readResolve() &#123; return new AscendingSubMap(TreeMap.this, fromStart, fromKey, true, toEnd, toKey, false); &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; throw new InternalError(); &#125; public K lastKey() &#123; throw new InternalError(); &#125; public K firstKey() &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; headMap(K toKey) &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; throw new InternalError(); &#125; public Comparator&lt;? super K&gt; comparator() &#123; throw new InternalError(); &#125; &#125; // 红黑树的节点颜色--红色 private static final boolean RED = false; // 红黑树的节点颜色--黑色 private static final boolean BLACK = true; // “红黑树的节点”对应的类。 // 包含了 key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色) static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 键 K key; // 值 V value; // 左孩子 Entry&lt;K,V&gt; left = null; // 右孩子 Entry&lt;K,V&gt; right = null; // 父节点 Entry&lt;K,V&gt; parent; // 当前节点颜色 boolean color = BLACK; // 构造函数 Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; // 返回“键” public K getKey() &#123; return key; &#125; // 返回“值” public V getValue() &#123; return value; &#125; // 更新“值”，返回旧的值 public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; // 判断两个节点是否相等的函数，覆盖equals()函数。 // 若两个节点的“key相等”并且“value相等”，则两个节点相等 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; // 覆盖hashCode函数。 public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; &#125; // 覆盖toString()函数。 public String toString() &#123; return key + &quot;=&quot; + value; &#125; &#125; // 返回“红黑树的第一个节点” final Entry&lt;K,V&gt; getFirstEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p; &#125; // 返回“红黑树的最后一个节点” final Entry&lt;K,V&gt; getLastEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.right != null) p = p.right; return p; &#125; // 返回“节点t的后继节点” static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123; Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 返回“节点t的前继节点” static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.left != null) &#123; Entry&lt;K,V&gt; p = t.left; while (p.right != null) p = p.right; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.left) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 返回“节点p的颜色” // 根据“红黑树的特性”可知：空节点颜色是黑色。 private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) &#123; return (p == null ? BLACK : p.color); &#125; // 返回“节点p的父节点” private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) &#123; return (p == null ? null: p.parent); &#125; // 设置“节点p的颜色为c” private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) &#123; if (p != null) p.color = c; &#125; // 设置“节点p的左孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) &#123; return (p == null) ? null: p.left; &#125; // 设置“节点p的右孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) &#123; return (p == null) ? null: p.right; &#125; // 对节点p执行“左旋”操作 private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125; &#125; // 对节点p执行“右旋”操作 private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125; &#125; // 插入之后的修正操作。 // 目的是保证：红黑树插入节点之后，仍然是一颗红黑树 private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; // 删除“红黑树的节点p” private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor&apos;s element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor (p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; // 删除之后的修正操作。 // 目的是保证：红黑树删除节点之后，仍然是一颗红黑树 private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK); &#125; private static final long serialVersionUID = 919286545866124006L; // java.io.Serializable的写入函数 // 将TreeMap的“容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeMap的“容量、所有的Entry”依次读出 private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Read in size int size = s.readInt(); buildFromSorted(size, null, s, null); &#125; // 根据已经一个排好序的map创建一个TreeMap private void buildFromSorted(int size, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; this.size = size; root = buildFromSorted(0, 0, size-1, computeRedLevel(size), it, str, defaultVal); &#125; // 根据已经一个排好序的map创建一个TreeMap // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。 private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi, int redLevel, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; if (hi &lt; lo) return null; // 获取中间元素 int mid = (lo + hi) / 2; Entry&lt;K,V&gt; left = null; // 若lo小于mid，则递归调用获取(middel的)左孩子。 if (lo &lt; mid) left = buildFromSorted(level+1, lo, mid - 1, redLevel, it, str, defaultVal); // 获取middle节点对应的key和value K key; V value; if (it != null) &#123; if (defaultVal==null) &#123; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next(); key = entry.getKey(); value = entry.getValue(); &#125; else &#123; key = (K)it.next(); value = defaultVal; &#125; &#125; else &#123; // use stream key = (K) str.readObject(); value = (defaultVal != null ? defaultVal : (V) str.readObject()); &#125; // 创建middle节点 Entry&lt;K,V&gt; middle = new Entry&lt;K,V&gt;(key, value, null); // 若当前节点的深度=红色节点的深度，则将节点着色为红色。 if (level == redLevel) middle.color = RED; // 设置middle为left的父亲，left为middle的左孩子 if (left != null) &#123; middle.left = left; left.parent = middle; &#125; if (mid &lt; hi) &#123; // 递归调用获取(middel的)右孩子。 Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel, it, str, defaultVal); // 设置middle为left的父亲，left为middle的左孩子 middle.right = right; right.parent = middle; &#125; return middle; &#125; // 计算节点树为sz的最大深度，也是红色节点的深度值。 private static int computeRedLevel(int sz) &#123; int level = 0; for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1) level++; return level; &#125;&#125; TreeMap是通过红黑树实现的，TreeMap存储的是key-value键值对，TreeMap的排序是基于对key的排序。 参考https://www.cnblogs.com/skywang12345/p/3310928.html","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"Collections","slug":"Collections","permalink":"http://zhangbuzola.cn/tags/Collections/"},{"name":"TreeMap","slug":"TreeMap","permalink":"http://zhangbuzola.cn/tags/TreeMap/"}]},{"title":"Java并发编程实战之java内存模型","slug":"javaConcurrencyInPractice_c16","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/03/23/javaConcurrencyInPractice_c16/","link":"","permalink":"http://zhangbuzola.cn/2018/03/23/javaConcurrencyInPractice_c16/","excerpt":"","text":"本章中，主要是讲述关于安全发布，同步策略，以及一致性 什么时候内存模型，为什么需要他简单的赋值操作 1i=1； 内存模型需要解决的问题是: 在什么条件下，读取i的线程将会看到i的值会是1 似乎很简单，但是如果没有同步，那么程序执行过程中，会有许多因素会导致线程无法立即甚至是永远不会另一个线程的操作结果。 在编译器中生成的指令顺序，是可以和源码中顺序不同的，而且编译器还会把变量保存在寄存器中而不是内存中；处理器可以采用乱序或并行的方式来执行指令；缓存可能会改变写入变量提交到主内存的次序；而且保存在处理器本地缓存中的值，对其他处理器是不可见的。这些因素都会让一个线程无法看到变量的最新值，并且会导致其他线程中的内存操作似乎在乱序执行，如果没有使用正确的同步的话。 单线程环境下，无法看到这些底层技术，它们除了提高程序的执行速度之外，不会产生其他影响。java语言规范要求JVM在线程中维护一种类似串行的语义：只要程序的最终结果与在严格串行环境中执行的结果相同，那么上述所有操作都是允许的。 在多线程环境下，维护程序的串行性会导致很大的性能开销。对并发应用程序中的线程来说，它们在大部分时间里都执行各自的任务，因此在线程之间的协调操作只会降低应用程序的运行速度，不会有任何好处。当多个线程共享数据的时候，才需要协调它们之间的操作，并且JVM依赖程序通过同步操作来找出这些协调操作将在何时发生。 JMM规定了JVM必需遵循一组最小保证，这组保证规定了对变量的写入操作会在何时将对其他线程可见。JMM在设计的时候就在可预测性和程序的易于开发性之间进行了权衡，从而在各种主流的处理器体系架构上能实现高性能的JVM。JMM需要了解现代处理器和编译器中使用的程序性能提升措施。 平台的内存模型在共享内存的多处理器体系架构中，每个处理器都拥有自己的缓存，并且定期地与主内存进行协调。在不同处理器架构中提供了不同级别的缓存一致性，其中一部分只提供了最小的保证，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。 重排序在没有充分同步的程序中，如果调度器采用不恰当的方式来交替执行不同线程的操作，那么会导致不正确的结果。更糟的是，JMM还是的不同线程看到的操作顺序是不同的，从而导致在缺乏同步的情况下，要推断操作的执行顺序，是几乎很难做到的。 各种使得操作延迟或者看似乱序执行的不同原因，都认为是重排序。 内存级别的重排序会使程序的行为变得不可预测。如果没有同步，那么推断出执行顺序是很困难的，而要确保在程序中的正确地使用同步是很容易的。同步将限制编译器，运行时和硬件对内存操作重排序的港式，从而在实施重排序时不会破坏JMM提供的可见性保证。（在大多数主流的处理器架构中，内存模型都很强大，使得读取volatile变量的性能与读取非volatile变量的性能大致相当。） java内存模型简介java内存模型是通过各种操作来定义的，包括对变量的读/写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。JMM为程序中所有的操作定义了一个偏序关系（偏序关系g是集合上的一种关系，具有反对称，自反和传递属性，但对于任意两个元素x,y来说，并不需要一定要满足xgy或者ygx，我们每天都在使用偏序关系来表达喜好，比如我们可以更喜欢寿司而不是干酪三明治，可以更喜欢莫扎特而不是马勒，但是我们不用再干酪三明治和莫扎特之间做出明确的喜好选择），称为Happen-Before。要想保证执行操作B的线程看到操作A的结果，不管AB操作是否在同一个线程中执行，那么AB之间必须满足Happens-Before关系。如果两个操作之间缺乏Happens-Before关系，那么JVM可以对它们任意地重排序。 当一个变量被多个线程读取并且至少被一个线程写入的时候，如果在读操作和写操作之间没有依照Happens-Before来排序，那么就会产生数据竞争问题。在正确同步的程序中不存在数据竞争，并会表现出串行一致性，这意味着程序中所有操作都会按照一种固定的和全局的顺序执行。 当一个变量被多个线程读取并且至少有一个线程是写入的操作时，如果在读操作和写操作之间没有遵循Happens-Before来排序，那么就会产生数据竞争问题。在正确同步的程序中不存在数据竞争，并会表现出串行一致性，这意味着程序中的所有操作都会按照一种固定的和全局的顺序执行。 Happens-Before规则程序顺序规则：如果程序中操作A在操作B之前，那么线程中A操作将在B操作之前执行； 监视器锁原则：在监视器锁上的解锁操作必须在同一个监视器上的加锁操作之前执行。（显式锁和内置锁在加锁和解锁等操作上有着相同的内存语义。） volatile变量规则：对volatile变量的写入操作必须在对该变量的读操作之前执行。（原子变量和volatile变量在读操作和写操作有着相同的语义。）线程启动规则：在线程上对Thread.Start的调用必须在该线程中执行任何操作之前执行。 线程结束规则：线程中任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从Thread.join中成功返回或者在调用Thread.isAlive的时候返回false 中断规则：当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行（通过抛出IntrruptedException，或者调用isInterrupted和interrupted）； 终结器规则：对象的构造函数必须在启动该对象的终结器之前执行完成； 传递性：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。 两个线程使用同一个锁进行同步的时候，能够保证顺序性，但是如果是不同的锁同步，就不能推断它们之间的动作顺序，因为这两个线程的操作执勤啊并不存在Happens-Before关系。 借助同步因为Happens-Before的排序功能很强大，因此有时候可以“借助PiggyBack”现有同步机制的可见性属性。 这需要将Happens-Before的程序顺序规则和其他某个顺序规则（通常是监视器锁规则或者volatile变量规则）结合起来，从而对某个未被锁保护的变量的访问操作进行排序。 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.CancellationException;import java.util.concurrent.ExecutionException;import java.util.concurrent.locks.AbstractQueuedSynchronizer;// FutureTask 的内部类public final class Sync extends AbstractQueuedSynchronizer &#123; private static final int RUNNING = 1, RAN = 2, CANCELLED = 4; private V result; private Exception exception; void insertSet(V v) &#123; while(true) &#123; int s = getState(); if(ranorCancelled(s)) &#123; return; &#125; if(compareAndSetState(s, RAN)) &#123; break; &#125; &#125; result = v; releaseShared(0); done(); &#125; V insertGet() throws InterruptedException, ExecutionException &#123; acquireInterruptibly(0); if(getState() == CANCELLED) &#123; throw new CancellationException(); &#125; if(exception != null) &#123; throw new ExecutionException(exception); &#125; return result; &#125;&#125; 程序清单16-2 说明如何借助同步的FutureTask的内部类 发布发布的安全性来自于JMM提供的保证，但是造成发布的不正确真正原因是：发布一个共享对象和另一个线程访问该对象之间缺少一种Happens-Before排序。 不安全的发布缺少Happens-Before关系的时候，就可能出现重排序的问题，这就解释了为什么在没有充分同步的情况下发布一个对象会导致另一个线程看到一个只被部分构造的对象。在初始化一个新的对象的时候需要写入多个变量，也就是新对象中的各个域。同样在发布一个引用的时候也需要写入一个变量，也就是新对象的引用。如果无法确保发布共享引用的操作在另一个线程加载该共享引用之前执行，那么对新对象引用的写入操作将于对象中的各个域的写入操作重排序。在这种情况下，另一个线程可能看到对象引用的最新值，但同时也将看到对象的某些或者全部状态中包含的是无效值，也就是一个被部分构造对象。 错误的延时初始化会导致不正确的发布。 123456789public class UnsafeLazyInitialization &#123; private static Resource resource; public static Resource getInstance() &#123; if(resource == null) &#123; resource = new Resource(); // 不安全的发布 &#125; return resource; &#125;&#125; 多次创建resource的低效率问题，竞态问题等等。如果不考虑这些，UnsafeLazyInitialization仍然是不安全的，因为另一个线程可能看到对部分构造的Resource实例的引用。 假设线程A是第一个调用getInstance的线程，他会看到resource是null，然后初始化。当B线程随后调用的时候，非空，会直接使用这个已经构造好的Resource。这好像没有什么问题了，但是线程A的写入操作和B的读取操作之间没有Happens-Before关系，在发布对象时候存在数据竞争的问题，因此B其实不一定能看到Resource的正确状态。 除了不可变对象意外，使用被另一个线程初始化的对象通常都是不安全的，除非对象的发布操作时在使用该对象的线程开始使用之前执行。 安全的发布保证发布对象的操作会在使用该对象之前之前。 Happens-Before排序是在内存访问级别上操作的，他是一种并发级汇编语言，而安全发布的运行级别更接近程序设计。 安全初始化模式 123456789public class UnsafeLazyInitialization &#123; private static Resource resource; public Synchronized static Resource getInstance() &#123; if(resource == null) &#123; resource = new Resource(); // 不安全的发布 &#125; return resource; &#125;&#125; 采用特殊的方式来处理静态域，并提供了额外的线程安全性保证。 提前初始化也是可以的。 public class UnsafeLazyInitialization { private static Resource resource = new Resource(); public static Resource getInstance() { return resource; }} 延迟初始化占位类模式 使用专门的类来进行初始化 public class ResourceFactory { private static class ResourceHolder { public static Resource resource = new Resource(); } public static Resource getResource() { return ResourceHolder.resource; }} 双重检查加锁（DCL）DCL（很不好） public class DoubleCheckedLocking { private static Resource resource; public static Resource getInstance() { if(resource == null) { synchronized (DoubleCheckedLocking.class) { if(resource==null) { resource = new Resouce(); } } } return resource; }} DCL声称能够实现两全其美，在常见代码路径上的延迟初始化中不存在同步开销。它的工作原理是：首先检查是否没有在同步的情况下需要初始化，从而保证只有一个线程对共享的资源进行初始化，在常见的代码路径中，获取一个已经构造好的Resource引用，并没有使用同步。这就是问题所在，线程可能看到一个仅被部分构造的Resource DCL真正的问题在于：当在没有同步的情况下，读取一个共享对象的时候，可能发生的最糟糕事情是看到一个失效值，此时DCL方法将通过在持有锁的情况下再次尝试来避免这种风险。然而，实际情况远比这种情况糟糕，线程可能看到引用的当前值，但是对象的状态值却是失效的，这意味着线程可以看到处于无效或者错误的状态。 DCL已经被废弃了 初始化过程中的安全性如何保证初始化过程中的安全性，那么就可以使得被正确构造的不可变对象在没有同步的情况下也能安全地在多个线程之间共享，而不用管他们是如何发布的，甚至可以通过某种数据竞争方式来发布。 初始化安全性，会导致一个安全漏洞，从而使恶意代码绕过安全检查。 初始化安全性将确保，对于被正确构造的队形，所有线程都能看到又构造函数为对象给各个final域设置的正确值，而不管采用何种方式来发布对象。并且，对于可以通过被正确构造对象中某个final域到达的任意变量将同样对于其他线程是可见的。 初始化安全性只能保证通过final域可达的值从构造过程完成时开始的可见性。对于通过非final域可达的值，或者在构成过程完成后可能改变的值，必须采用同步来确保可见性。 123456789101112131415import java.util.HashMap;import java.util.Map;public class SafeStates &#123; private final Map&lt;String, String&gt; states; public SafeStates() &#123; states = new HashMap&lt;String, String&gt;(); states.put(&quot;al&quot;, &quot;AK&quot;); states.put(&quot;hel&quot;, &quot;HJ&quot;); // more put &#125; public String getAbbreviation(String s) &#123; return states.get(s); &#125;&#125; 总结java内存模型说明了某个线程的内存操作在哪些情况下对于其他线程是可见的。其中包括确保这些操作时按照一种Happens-Before的偏序关系进行排序，而这种关系是基于内存操作和同步操作等级别来定义的。 如果确定好充足的同步，那么当线程访问共享数据的时候，会发生一些非常奇怪的问题。如果使用一些更高级规则，比兔@GuardedBy和安全发布，那么就算不考虑Heppens-Before的底层细节，也能确保线程安全性。","categories":[{"name":"技术书","slug":"技术书","permalink":"http://zhangbuzola.cn/categories/技术书/"}],"tags":[{"name":"java并发编程实战","slug":"java并发编程实战","permalink":"http://zhangbuzola.cn/tags/java并发编程实战/"}]},{"title":"Java并发编程实战之原子变量与非阻塞同步","slug":"javaConcurrencyInPractice_c15","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/03/23/javaConcurrencyInPractice_c15/","link":"","permalink":"http://zhangbuzola.cn/2018/03/23/javaConcurrencyInPractice_c15/","excerpt":"","text":"前言java.util.concurrent包的许多类中，比如ConcurrentLinkedQueue和Semaphore，都提供了比synchronized机制更高的性能和可伸缩性。这种性能的提升主要来源于：原子变量和非阻塞的同步机制。 非阻塞算法在并发算法领域很重要，这种算法用底层的原子机器指令，比如比较并交换指令，代替锁来确保数据在并发访问中的一致性。非阻塞算法被广泛应用在操作系统和JVM中实现线程/进程调度机制、垃圾回收机制以及锁和其他并发数据结构。 非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调，并且极大地减少调度开销。而且非阻塞算法不存在死锁和其他活跃性问题。在基于锁的算法中，如果一个线程在休眠或者自旋的同时拥有一个锁，那么其他线程将无法继续执行下去，而非阻塞算法不会受到单个线程失败的影响。从java5.0开始，就可以使用原子变量类（AtomicInteger/AtomicReference）来构建高效的非阻塞算法。 原子变量不仅用于那么非阻塞算法的开发，而且可以用作一种“更好的volatile类型变量”。原子变量提供了与volatile类型变量相同的内存语义，此外还支持原子的更新操作，更加适用于实现计数器，序列发生器和统计数据收集等，同时还能比基于锁的方法提供更高的可伸缩性。 锁的劣势通过锁协议来协调对共享变量的访问，可以确保无论哪个线程持有守护变量的锁，都能采用独占方式来访问这些变量，并且对变量的任何修改对随后获得这个锁的其他线程也是可见的。 现在的许多JVM都对非竞争锁获取和锁释放等操作进行极大地优化，但是如果有多个线程同时请求锁，那么JVM就需要借助操作的功能。如果出现了这种情况，那么一些线程将被挂起并且在稍后恢复运行（当线程在锁上发生竞争，智能的JVM不一定会挂起线程，而是会根据之前获取操作中对锁的持有时间长短来判断使线程挂起还是自旋等待）。当线程恢复执行的时候，必须等待其他线程执行完他们的时间片以后，才能被调度执行。 再挂起和恢复线程等过程中存在着很大的开销，并且通常存在着较长时间的中断。如果基于锁的类中包含有细粒度的操作（比如同步容器类），那么当在锁上存在着激烈的竞争时，调度开销与工作开销的比值会很高。 线程安全的类，没有竞争的情况下会运行的很好，但是在竞争的情况下，其性能可能会由于上下文切换的开销和调度延迟而降低。如果锁的持有时间非常短，那么当在不恰当的时间请求锁的时候，使线程休眠将付出很高的代价。 volatile与锁相比，volatile变量是一种更轻量级的同步机制，因为在使用这些变量的时候不会发生上下文切换或者线程调度等操作。 volatile的缺陷：虽然提供了相似的可见性保证，但是不能用于构建原子的复合操作。因此，当一个变量依赖于其他变量的时候，或者当变量的新值依赖于旧值时，就不能使用volatile变量。这些都限制了volatile变量的使用，因此他们不能用来实现一些常见的工具，比如：计数器或者互斥体。 ++i 不是原子操作例如，虽然自增操作++i，看起来像一个原子操作，但是事实上它包含了3个独立的操作–获取变量的当前值，将这个值加1，然后再写入新值。为了确保更新操作不被丢失，整个读-改-写操作必需是原子的。目前为止，锁方法可以实现这种原子操作。 i++这一条语句，它实际上会被编译为两条CPU指令，因此若一些线程在运行时被从中打断，就会造成不确定的后果，如下： 1234567891011121314151617181920public class IplusplusExam &#123; private volatile static int i = 0; public static void main(String[] args) throws InterruptedException &#123; ExecutorService service = Executors.newCachedThreadPool(); for (int j = 0; j &lt; 10; j++) &#123; service.execute(new Runnable() &#123; @Override public void run() &#123; for (int k = 0; k &lt; 10000; k++) &#123; i++; &#125; &#125; &#125;); &#125; service.shutdown(); service.awaitTermination(1, TimeUnit.DAYS); System.out.println(i); &#125;&#125; 十个线程分别对i变量进行10000次i++操作，若i++是线程安全的，则最终i应该等于100000，但是你会发现每次结果都不一样。 锁还有其他缺点：一个线程在等待锁的时候，他不能做其他任何事情。如果一个线程在持有锁的情况下被延迟执行（比如发生了缺页错误，调度延迟，或者其他类似情况），那么所有需要这个锁的线程都无法执行下去。 如果阻塞线程的优先级更高，而尺有所的线程优先级更低，那么这也是一个问题–优先级反转。就算优先级高线程可以抢占执行，但是也需要等待锁被释放，从而导致他的优先级会降低至低优先级线程的级别。如果持有锁的线程被永久的阻塞（比如出现了无限循环，死锁，活锁或者其他活跃性障碍），所有等待这个锁的线程都永远没办法执行下去。 还有，锁定方式对于细粒度的操作（比如递增计数器）来说仍然是一个高开销的机制。在管理线程之间的竞争时应该有一种粒度更细的技术，类似于volatile变量的机制，同时又支持原子性操作。 硬件对并发的支持独占锁是悲观锁的一种。CAS是乐观锁机制（某种形式和的原子读-改-写指令）。 悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。 悲观锁机制存在以下问题： 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。 一个线程持有锁会导致其它所有需要此锁的线程挂起。 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。 对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。其实乐观锁就是：每次不加锁而是假设没有并发冲突而去完成某项操作，如果因为并发冲突失败就重试，直到成功为止。 乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 原子变量非阻塞并发的基础是CAS（CompareAndSwap，比较并替换，后面会详细介绍），而CAS的基础是Unsafe类，所以下面系统性的介绍一下Unsafe和CAS。 Unsafe类 Java的指针Unsafe类 Java放弃了指针，获得了更高的安全性和内存自动清理的能力。但是，它还是在一个角落里提供了类似于指针的功能，那就是sun.misc.Unsafe类，利用这个类，可以完成许多需要指针才能提供的功能，例如构造一个对象，但是不调用构造函数；找到对象中一个变量的地址，然后直接给它赋值，无视其final属性；通过地址直接操作数组；或者是进行CAS操作。例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class UnSafeExam &#123; public static void main(String[] args) throws InstantiationException, NoSuchFieldException &#123; //获得一个UnSafe实例 Unsafe unsafe = null; try &#123; Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); f.setAccessible(true); unsafe = (Unsafe) f.get(null); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; if (unsafe != null) &#123; try &#123; //构造一个对象，且不调用其构造函数 Test test = (Test) unsafe.allocateInstance(Test.class); //得到一个对象内部属性的地址 long x_addr = unsafe.objectFieldOffset(Test.class.getDeclaredField(&quot;x&quot;)); //直接给此属性赋值 unsafe.getAndSetInt(test, x_addr, 47); System.out.println(test.getX()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125; //通过地址操作数组 if (unsafe != null) &#123; final int INT_BYTES = 4; int[] data = new int[10]; System.out.println(Arrays.toString(data)); long arrayBaseOffset = unsafe.arrayBaseOffset(int[].class); System.out.println(&quot;Array address is :&quot; + arrayBaseOffset); unsafe.putInt(data, arrayBaseOffset, 47); unsafe.putInt(data, arrayBaseOffset + INT_BYTES * 8, 43); System.out.println(Arrays.toString(data)); &#125; //CAS if (unsafe != null) &#123; Test test = (Test) unsafe.allocateInstance(Test.class); long x_addr = unsafe.objectFieldOffset(Test.class.getDeclaredField(&quot;x&quot;)); unsafe.getAndSetInt(test, x_addr, 47); unsafe.compareAndSwapInt(test, x_addr, 47, 78); System.out.println(&quot;After CAS:&quot; + test.getX()); &#125; &#125; static class Test &#123; private final int x; Test(int x) &#123; this.x = x; System.out.println(&quot;Test ctor&quot;); &#125; int getX() &#123; return x; &#125; &#125;&#125; 熟悉反射的人应该很快能够理解上面的代码，下面重点说说CAS这个操作。CAS即CompareAndSwap操作，在Unsafe中它有如下形式： 123public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); 这三个方法都有四个参数，其中第一和第二个参数代表对象的实例以及地址，第三个参数代表期望值，第四个参数代表更新值。CAS的语义是，若期望值等于对象地址存储的值，则用更新值来替换对象地址存储的值，并返回true，否则不进行替换，返回false。 后面我们会看到诸多的原子变量，例如AtomicInteger、AtomicLong、AtomicReference等等都提供了CAS操作，其底层都是调用了Unsafe的CAS，它们的参数往往是三个，对象值、期望值和更新值，其语义也与Unsafe中的一致。CAS是所有原子变量的原子性的基础，为什么一个看起来如此不自然的操作却如此重要呢？其原因就在于这个native操作会最终演化为一条CPU指令cmpxchg，而不是多条CPU指令。由于CAS仅仅是一条指令，因此它不会被多线程的调度所打断，所以能够保证CAS操作是一个原子操作。补充一点，当代的很多CPU种类都支持cmpxchg操作，但不是所有CPU都支持，对于不支持的CPU，会自动加锁来保证其操作不会被打断。 由此可知，原子变量提供的原子性来自CAS操作，CAS来自Unsafe，然后由CPU的cmpxchg指令来保证。 保持原子性的AtomicInteger若要保持一个变量改变数值时的原子性，目前Java最简单的方法就是使用相应的原子变量，例如AtomicInteger、AtomicBoolean和AtomicLong。再来看一个例子： 12345678910111213141516171819public class AtomicIntegerExam &#123; public static void main(String[] args) throws InterruptedException &#123; AtomicInteger atomicInteger = new AtomicInteger(0); ExecutorService service = Executors.newCachedThreadPool(); for (int j = 0; j &lt; 10; j++) &#123; service.execute(new Runnable() &#123; @Override public void run() &#123; for (int k = 0; k &lt; 10000; k++) &#123; atomicInteger.incrementAndGet(); &#125; &#125; &#125;); &#125; service.shutdown(); service.awaitTermination(1, TimeUnit.DAYS); System.out.println(atomicInteger.get()); &#125;&#125; 这次的结果为保持为100000了。因为AtomicInteger的incrementAndGet()操作是原子性的。观察其内部代码，它使用了Unsafe的compareAndSwapInt()方法。那么现在整形有AtomicInteger，长整型有AtomicLong，布尔型有AtomicBoolean，那么浮点型怎么办？JDK的说法是程序员可以利用AtomicInteger以及Float.floatToRawIntBits和Float.intBitsToFloat来自己实现一个AtomicFloat；利用AtomicLong以及Double.doubleToRawLongBits和Double.longBitsToDouble来自己实现一个AtomicDouble。在网上可以搜索到相应的实现实现JDK没有提供的AtomicFloat - 杨尚川的个人页面，这里就不再赘述了。 原子引用AtomicReferenceJava的变量有两种类型，原始类型和引用类型。上一章讲了原始类型对应的原子变量，这一章讲的便是原子引用AtomicReference，它的作用就是能够实现对引用类型的原子化更改。例子如下： 1234567891011121314151617181920212223242526272829303132333435public class AtomReferenceExam &#123; public static void main(String[] args) throws InterruptedException &#123; AtomicReference&lt;Element&gt; reference = new AtomicReference&lt;&gt;(new Element(0, 0)); ExecutorService service = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; service.execute(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; boolean flag = false; while (!flag) &#123; Element storedElement = reference.get(); Element newElement = new Element(storedElement.x + 1, storedElement.y + 1); flag = reference.compareAndSet(storedElement, newElement); &#125; &#125; &#125; &#125;); &#125; service.shutdown(); service.awaitTermination(1, TimeUnit.DAYS); System.out.println(&quot;element.x=&quot; + reference.get().x + &quot;,element.y=&quot; + reference.get().y); &#125; private static class Element &#123; int x; int y; public Element(int x, int y) &#123; this.x = x; this.y = y; &#125; &#125;&#125; 值得注意的有两点，一是如果有好几个变量要同时进行原子化的改变，那么可以把这几个变量放到一个Java类中，做成一个所谓的POJO（Plain Ordinary Java Object）类，然后使用AtomicReference来操作这个类。 第二点是以下这段代码： 123456boolean flag = false;while (!flag) &#123; Element storedElement = reference.get(); Element newElement = new Element(storedElement.x + 1, storedElement.y + 1); flag = reference.compareAndSet(storedElement, newElement);&#125; 这是一种很通用的写法，在很多情况下，这种类似的写法都被称之为自旋锁（spinLock，我们会在后续的章节中介绍）。在使用AtomicReference的时候，会常常使用这种写法。 AtomicIntegerFieldUpdaterAtomicIntegerFieldUpdater、AtomicLongFieldUpdater和AtomicReferenceFieldUpdater都被称为原子属性更新器。这些类的应用场景是：如果已经有一个写好的类，但是随着业务场景的变化，其中某些属性在写入的时候需要保持原子性，那么就可以使用以上的类来实现这种原子性，并保持类的原有接口不变。 例子如下： 1234567891011121314151617181920212223242526272829303132333435public class AtomicIntegerFieldUpdaterExam &#123; public static void main(String[] args) throws InterruptedException &#123; Student student = new Student(0, &quot;Alex Wang&quot;); AtomicIntegerFieldUpdater&lt;Student&gt; updater = AtomicIntegerFieldUpdater.newUpdater(Student.class, &quot;id&quot;); ExecutorService service = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; service.execute(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; updater.getAndIncrement(student); &#125; &#125; &#125;); &#125; service.shutdown(); service.awaitTermination(1, TimeUnit.DAYS); System.out.println(student); &#125; private static class Student &#123; volatile int id; String name; public Student(int id, String name) &#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student id = &quot; + id + &quot;,name = &quot; + name; &#125; &#125;&#125; 上面的例子中给出了一个原有的类Student，其中属性id是volatile int（注意，要应用原子属性更新器的属性必须是volatile的），为了使这个属性能够被原子化的改变，我们创建了一个AtomicIntegerFieldUpdater，其构造方法为AtomicIntegerFieldUpdater.newUpdater(Student.class, “id”)，注意第一个参数是一个class，而第二个参数是属性名字的字符串值（这里显然用到了反射）。接下来就可以使用这个Updater来更新属性值了，其用法类似于AtomicInteger。10个线程分别对这个属性进行了10000次加1操作，结果为100000。 AtomicIntegerArray原子数组AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray是原子数组，数组中每个元素在改变时都可以保持原子性。例子如下： 123456789101112131415161718192021222324public class AtomicIntegerArrayExam &#123; public static void main(String[] args) throws InterruptedException &#123; AtomicIntegerArray array = new AtomicIntegerArray(5); array.set(0, 0); array.set(1, 0); ExecutorService service = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; service.execute(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; array.getAndIncrement(0); &#125; for (int j = 0; j &lt; 10000; j++) &#123; array.getAndIncrement(1); &#125; &#125; &#125;); &#125; service.shutdown(); service.awaitTermination(1, TimeUnit.DAYS); System.out.println(&quot;array[0] = &quot;+array.get(0)+&quot;, array[1] = &quot;+array.get(1)); &#125;&#125; 10个线程分别对array[0]和array[1]进行了10000次加1操作，结果符合原子性。还有一点值得注意的是，为了性能考虑，应该尽量使用AtomicIntegerArray[n]，而不是AtomicInteger[n]，因为后者需要创建n个原子变量实例，而前者只需要创建一个原子变量数组实例，而完成的功能是一样的。 AtomicStampedReference带有版本号的原子引用AtomicStampedReference和AtomicMarkableReference是atomic包中两个比较难以理解的类，它们都是为了解决ABA问题而创建出来的。 ABA问题12345678910在介绍AtomicReference的时候已经说过，为了实现原子引用的原子性改变，需要用一种类似于自旋锁的代码写法，如下：boolean flag = false;while (!flag) &#123; Element oldValue = reference.get(); Element newValue = new Element(…);//如果有其他线程在这里将oldValue从A改为B，做了一些事情，然后又将oldValue改为A，则下面的语句依然能够返回true flag = reference.compareAndSet(oldValue, newValue);&#125; 以上情况下，oldValue从A改为B，又从B改为A，不会影响compareAndSet的返回值。但是在某些情况下，会造成不确定的结果，因此影响了线程安全性，这种问题就叫做自旋锁的ABA问题，例如： ABA问题一般存在于链表、栈这类的并发数据结构中。从上面的例子中可以看出，由于ABA问题，最后的结果是，在特定的条件下，一个ACD栈（三个元素），经过一个pop操作（线程1）变成了B（一个元素），这显然不是线程安全的。下面的代码中，我模拟了这个例子（其中很多地方并未充分考虑并发的正确性，主要是为了展示ABA问题）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class ABAProblem &#123; public static void main(String[] args) throws InterruptedException &#123; MyStack&lt;String&gt; stack = new MyStack&lt;&gt;(); stack.push(&quot;B&quot;); stack.push(&quot;A&quot;); System.out.println(&quot;Stack init:&quot; + stack); ExecutorService service = Executors.newCachedThreadPool(); service.execute(new Runnable() &#123; @Override public void run() &#123; Thread.currentThread().setName(&quot;Thread1&quot;); stack.pop(); System.out.println(&quot;Thread1 pop :&quot; + stack); &#125; &#125;); service.execute(new Runnable() &#123; @Override public void run() &#123; Thread.currentThread().setName(&quot;Thread2&quot;); Node&lt;String&gt; A = stack.pop(); System.out.println(&quot;Thread2 pop :&quot; + stack); stack.pop(); System.out.println(&quot;Thread2 pop :&quot; + stack); stack.push(&quot;D&quot;); System.out.println(&quot;Thread2 push D:&quot; + stack); stack.push(&quot;C&quot;); System.out.println(&quot;Thread2 push C:&quot; + stack); stack.push(A); System.out.println(&quot;Thread2 push A:&quot; + stack); &#125; &#125;); service.shutdown(); service.awaitTermination(1, TimeUnit.DAYS); System.out.println(&quot;Stack result:&quot; + stack); &#125; static class MyStack&lt;T&gt; &#123; AtomicReference&lt;Node&lt;T&gt;&gt; head = new AtomicReference&lt;&gt;(null); public void push(T value) &#123; Node&lt;T&gt; node = new Node&lt;&gt;(value); push(node); &#125; public void push(Node&lt;T&gt; node) &#123; for (; ; ) &#123; Node&lt;T&gt; tmpHead = head.get(); if (head.compareAndSet(tmpHead, node)) &#123; node.setNext(tmpHead); return; &#125; &#125; &#125; public Node&lt;T&gt; pop() &#123; for (; ; ) &#123; Node&lt;T&gt; node = head.get(); if (node == null) &#123; return null; &#125; Node&lt;T&gt; nextNode = node.getNext(); // add this sleep to cause ABA problem if (Thread.currentThread().getName().equals(&quot;Thread1&quot;)) &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (head.compareAndSet(node, nextNode)) &#123; return node; &#125; &#125; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(&quot;[&quot;); Node&lt;T&gt; node = head.get(); while (node != null) &#123; sb.append(node.getValue()); if (node.getNext() != null) &#123; sb.append(&quot;,&quot;); &#125; node = node.getNext(); &#125; sb.append(&quot;]&quot;); return sb.toString(); &#125; &#125; private static class Node&lt;T&gt; &#123; private T value; private Node&lt;T&gt; next; public Node(T value) &#123; this.value = value; &#125; public Node&lt;T&gt; getNext() &#123; return next; &#125; public void setNext(Node&lt;T&gt; next) &#123; this.next = next; &#125; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125; &#125;&#125; 运行结果是： 12345678Stack init:[A,B]Thread2 pop :[B]Thread2 pop :[]Thread2 push D:[D]Thread2 push C:[C,D]Thread2 push A:[A,C,D]Thread1 pop :[B]Stack result:[B] 代码中的push和pop方法都用无限循环的for语句实现，这也是并发中的常见写法，与前面类似自旋锁的while语句实现类似的功能，但由于不需要定义一个boolean变量，因此更加简洁。为了保证ABA问题一定出现，我特意插入了一个针对特定线程的sleep语句。在现实中，出现ABA的几率其实是很小的。 用AtomicStampedReference解决ABA问题ABA问题的实质是：在并发编程中，仅靠检查变量的值是无法知道这个变量是否被改动过的，还要加上一个版本号（当变量改变就改变其版本号）才能确定变量保持不变。AtomicStampedReference实现了此功能，它保存变量引用的同时，还赋予此变量一个版本号。每当变量改动时（这个改动是程序员自定义的，例如存储的数值改变，或者是变量在内存中的位置移动了，或者是变量在某一个数据结构中被移动了），AtomicStampedReference可以同时改动版本号；因此在进行CAS操作时，同时检查引用和版本号，只有同时符合才能成功。如此变可以确保ABA问题不会发生了。代码进行如下改动（仅改动MyStack）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static class MyStack&lt;T&gt; &#123; //initialStamp = 0 AtomicStampedReference&lt;Node&lt;T&gt;&gt; head = new AtomicStampedReference&lt;&gt;(null, 0); public void push(T value) &#123; Node&lt;T&gt; node = new Node&lt;&gt;(value); push(node); &#125; public void push(Node&lt;T&gt; node) &#123; for (; ; ) &#123; Node&lt;T&gt; tmpHead = head.getReference(); int stamp = head.getStamp(); if (head.compareAndSet(tmpHead, node, stamp, stamp + 1)) &#123; node.setNext(tmpHead); return; &#125; &#125; &#125; public Node&lt;T&gt; pop() &#123; for (; ; ) &#123; Node&lt;T&gt; node = head.getReference(); int stamp = head.getStamp(); if (node == null) &#123; return null; &#125; Node&lt;T&gt; nextNode = node.getNext(); // add this sleep to cause ABA problem if (Thread.currentThread().getName().equals(&quot;Thread1&quot;)) &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (head.compareAndSet(node, nextNode, stamp, stamp + 1)) &#123; return node; &#125; &#125; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(&quot;[&quot;); Node&lt;T&gt; node = head.getReference(); while (node != null) &#123; sb.append(node.getValue()); if (node.getNext() != null) &#123; sb.append(&quot;,&quot;); &#125; node = node.getNext(); &#125; sb.append(&quot;]&quot;); return sb.toString(); &#125;&#125; 在每次改动head保存的变量时，都同时给版本号加1，这样就避免了ABA问题的发生，运行结果如下： 12345678Stack init:[A,B]Thread2 pop :[B]Thread2 pop :[]Thread2 push D:[D]Thread2 push C:[C,D]Thread2 push A:[A,C,D]Thread1 pop :[C,D]Stack result:[C,D] 另外值得一提的是，AtomicStampedReference还有一个简化版AtomicMarkableReference，它保存的版本号是一个boolean值，适用于某些简化的情景下。 小结所谓“线程安全的”，就是在并发环境下能够保持运行结果不变。除了原始的synchronize阻塞方法外，使用原子性的语句能够在保持线程安全的前提下提供更好的性能。原子性的基础是CAS语句，而它则是由Unsafe类提供的。有了此利器，JDK提供了AtomicInteger、AtomicBoolean和AtomicLong等类来实现整形、布尔型和长整型变量的原子增减操作；提供了AtomicReference来实现引用类型的原子操作；提供了AtomicIntegerFieldUpdater、AtomicLongFieldUpdater和AtomicReferenceFieldUpdater来实现原有类中某个属性的原子更新操作；提供了AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray等原子数组，数组中每个元素在改变时都可以保持原子性。为了避免ABA问题，提供了AtomicStampedReference和AtomicMarkableReference。","categories":[{"name":"技术书","slug":"技术书","permalink":"http://zhangbuzola.cn/categories/技术书/"}],"tags":[{"name":"java并发编程实战","slug":"java并发编程实战","permalink":"http://zhangbuzola.cn/tags/java并发编程实战/"}]},{"title":"java基础学习之IO流","slug":"javabase_IO","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/03/01/javabase_IO/","link":"","permalink":"http://zhangbuzola.cn/2018/03/01/javabase_IO/","excerpt":"","text":"IO流 字节流字符流字符流中的对象融合了编码表，也就是系统默认的编码表，系统默认的是GBK编码。 字符流只用来处理文本数据，字节流用来处理媒体数据。 数据最常见的表现方式是文件，字符流用于操作文件的子类一般是FileReader和FileWriter。 注意事项： 写入文件必须flush close 使用流对象要抛出IO异常 定义文件路径的时候：可以用’/‘或者’\\‘ 缓存区字符流的缓存区 缓冲区的出现时为了提高流的操作效率而出现的. 需要被提高效率的流作为参数传递给缓冲区的构造函数 在缓冲区中封装了一个数组，存入数据后一次取出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import java.io.*; class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; //创建一个字符读取流流对象，和文件关联 FileReader rw = new FileReader(&quot;buf.txt&quot;); //只要将需要被提高效率的流作为参数传递给缓冲区的构造函数即可 BufferedReader brw = new BufferedReader(rw); for(;;) &#123; String s = brw.readLine(); if(s==null) break; System.out.println(s); &#125; brw.close();//关闭输入流对象 //创建一个字符写入流对象 FileWriter fw = new FileWriter(&quot;buf.txt&quot;); //为了提高字符写入效率，加入了缓冲技术。 //只要将需要被提高效率的流作为参数传递给缓冲区的构造函数即可 BufferedWriter bfw = new BufferedWriter(fw); //bfw.write(&quot;abc\\r\\nde&quot;); //bfw.newLine(); 这行代码等价于bfw.write(&quot;\\r\\n&quot;),相当于一个跨平台的换行符 //用到缓冲区就必须要刷新 for(int x = 1; x &lt; 5; x++) &#123; bfw.write(&quot;abc&quot;); bfw.newLine(); //java提供了一个跨平台的换行符newLine(); bfw.flush(); &#125; bfw.flush(); //刷新缓冲区 bfw.close(); //关闭缓冲区，但是必须要先刷新 //注意，关闭缓冲区就是在关闭缓冲中的流对象 fw.close(); //关闭输入流对象 &#125; &#125; 流操作的基本规律。 一、两个明确：(明确体系) 1. 明确源和目的 源：输入流 InputStream Reader 目的：输出流 OutputStream Writer 2. 操作的数据是否是纯文本 是： 字符流 否： 字节流 二、明确体系后要明确具体使用的对象 通过设备区分：内存，硬盘，键盘 目的设备：内存，硬盘，控制台 示例1：将一个文本文件中的数据存储到另一个文件中: 复制文件 一、明确体系 源：文件--&gt;读取流--&gt;(InputStream和Reader) 是否是文本：是--&gt;Reader 目的：文件--&gt;写入流--&gt;(OutputStream Writer) 是否纯文本：是--&gt;Writer 二、 明确设备 源：Reader 设备：硬盘上一个文本文件 --&gt; 子类对象为：FileReader FileReader fr = new FileReader(&quot;Goods.txt&quot;); 是否提高效率：是--&gt;加入Reader中的缓冲区：BufferedReader BufferedReader bufr = new BufferedReader(fr); 目的：Writer 设备：键盘上一个文本文件 --&gt; 子类对象：FileWriter FileWriter fw = new FileWriter(&quot;goods1.txt&quot;); 是否提高效率：是--&gt;加入Writer的缓冲区：BufferedWriter BufferedWriter bufw = new BufferedWriter(fw); 示例2：将一个图片文件数据复制到另一个文件中：复制文件 一、明确体系 源：文件--&gt;读取流--&gt;(InputStream和Reader) 是否是文本：否--&gt;InputStream 目的：文件--&gt;写入流--&gt;(OutputStream Writer) 是否纯文本：否--&gt;OutputStream 二、 明确设备 源：InputStream 设备：硬盘上一个媒体文件 --&gt; 子类对象为：FileInputStream FileInputStream fis = new FileInputStream(&quot;Goods.txt&quot;); 是否提高效率：是--&gt;加入InputStream中的缓冲区：BufferedInputStream BufferedInputStream bufi = new BufferedInputStream(fis); 目的：OutputStream 设备：键盘上一个媒体文件 --&gt; 子类对象：FileOutputStream FileOutputStream fos = new FileOutputStream(&quot;goods1.txt&quot;); 是否提高效率：是--&gt;加入OutputStream的缓冲区：BufferedOutputStream BufferedOutputStream bufo = new BufferedOutputStream(fw); 示例3：将键盘录入的数据保存到一个文本文件中 一、明确体系 源：键盘--&gt;读取流--&gt;(InputStream和Reader) 是否是文本：是--&gt;Reader 目的：文件--&gt;写入流--&gt;(OutputStream Writer) 是否纯文本：是--&gt;Writer 二、 明确设备 源：InputStream 设备：键盘 --&gt; 对用对象为：System.in --&gt; InputStream 为了操作方便，转成字符流Reader --&gt; 使用Reader中的转换流：InputStreamReader InputStreamReader isr = new InputStreamReader(System.in); 是否提高效率：是--&gt;加入Reader中的缓冲区：BufferedReader BufferedReader bufr = new BufferedReader(isr); 目的：Writer 设备：键盘上一个文本文件 --&gt; 子类对象：FileWriter FileWriter fw = new FileWriter(&quot;goods1.txt&quot;); 是否提高效率：是--&gt;加入Writer的缓冲区：BufferedWriter BufferedWriter bufw = new BufferedWriter(fw); 置顶编码表12345678910111213141516171819202122import java.io.*; public class IOStreamLaw &#123; /** * @param args */ public static void main(String[] args) throws IOException &#123; //键盘的最常见写法 BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;goods1.txt&quot;),&quot;UTF-8&quot;)); String line = null; while((line=bufr.readLine())!=null)&#123; if(&quot;over&quot;.equals(line)) break; bufw.write(line.toUpperCase()); bufw.newLine(); bufw.flush(); &#125; bufr.close(); &#125; &#125; 字节流参考https://www.jianshu.com/p/c4d3ef8004a7","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之泛型","slug":"javabase_E","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/03/01/javabase_E/","link":"","permalink":"http://zhangbuzola.cn/2018/03/01/javabase_E/","excerpt":"","text":"泛型程序设计泛型泛型就是：任意的数据类型。 泛型是把类型参数化，用来规定一个类、接口或者方法所能接受的数据的类型，就像在声明方法时指定参数一样，我们在声明一个类、接口或者方法的时候，也可以指定其类型参数。 出现原因：java数据类型：基本类型与包装类 自动装箱 把基本类型用她们对应的引用类型包装起来，使她们具有对象的特质。可以调用toString(),hashCode()等类方法 12345Integer i = 1;// 编译器会调用valueOf方法Integer i = Integer.valueOf(1); 拆箱 跟自动装箱的方向相反，将引用类型转换为基本类型。 自动装箱和拆箱都由编译器来完成。 向上转型 任何的一个类都可以向上转型为其父类，直到Object类。但是向上转型会失去一些方法。？向上转型是如何发生的，编译器为什么认可这种丢失犯法的行为。 原因就是这种丢失是安全的，父类所有的public方法，都会在子类实现（重写或者继承），所以一个子类转型到父类类型之后，可以当做一个正常的父类对象使用，不需要担心某个方法未被实现。 1Father f1 = new Son(); // 向上转型 向下转型 父类对象转换为子类对象 12Father f1 = new Son();Son s1 = (Son)f1; // 这就叫 downcasting (向下转型) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.wensefu.other1; public class Girl &#123; public void smile()&#123; System.out.println(&quot;girl smile()...&quot;); &#125; &#125; class MMGirl extends Girl&#123; @Override public void smile() &#123; System.out.println(&quot;MMirl smile sounds sweet...&quot;); &#125; public void c()&#123; System.out.println(&quot;MMirl c()...&quot;); &#125; &#125; class Main&#123; public static void main(String[] args) &#123; Girl g1=new MMGirl(); //向上转型 g1.smile(); MMGirl mmg=(MMGirl)g1; //向下转型,编译和运行皆不会出错 mmg.smile(); mmg.c(); Girl g2=new Girl(); // MMGirl mmg1=(MMGirl)g2; //不安全的向下转型,编译无错但会运行会出错 // mmg1.smile(); // mmg1.c(); /*output: * CGirl smile sounds sweet... * CGirl smile sounds sweet... * CGirl c()... * Exception in thread &quot;main&quot; java.lang.ClassCastException: com.wensefu.other1.Girl * at com.wensefu.other1.Main.main(Girl.java:36) */ if(g2 instanceof MMGirl)&#123; MMGirl mmg1=(MMGirl)g2; mmg1.smile(); mmg1.c(); &#125; &#125; &#125; 好处 提高安全性：将运行期间的错误转换到编译器，如果我们在对一个对象所赋的值不符合其泛型的贵姓，就会编译错误。 避免强转：比如我们在使用List的时候，如果我们不使用泛型，当从List中取出元素的时候，其类型会是默认的Object，我们必须向下转型为String才能使用。 123List l = new ArrayList();l.add(&quot;abc&quot;);String s = (String)l.get(0); 而使用泛型，就可以保证存入和取出的都是String类型, 不必在进行cast了。比如: 123List&lt;String&gt; l = new ArrayList&lt;&gt;();l.add(&quot;abc&quot;);String s = l.get(0); 举例： 1234567891011121314151617181920212223242526// 设计一个简单的Box类public class Box &#123; private String object; public void set(String object) &#123; this.object = object; &#125; public String get() &#123; return object; &#125;&#125;/**Box类中只能装String类型的元素， * 但是如果我们希望Box能装下不止String一种类型的元素， * 我们就需要重写很多个Box类去适应不同的数据类型。代码得不到复用。 *泛型**可以很好的解决这个问题**/public Class Box&lt;T&gt; &#123; private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 泛型类和泛型方法类型参数（又称类型变量）用作占位符，指示在运行时为类分配类型。根据需要，可能有一个或多个类型参数，并且可以用于整个类。根据惯例，类型参数是单个大写字母，该字母用于指示所定义的参数类型。下面列出每个用例的标准类型参数： 1234567E：元素K：键N：数字T：类型V：值S、U、V 等：多参数情况中的第 2、3、4 个类型? 表示不确定的java类型（无限制通配符类型） 123456789101112131415161718public class Util &#123; public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123; return p1.getKey().equals(p2.getKey()) &amp;&amp; p1.getValue().equals(p2.getValue()); &#125;&#125;public class Pair&lt;K, V&gt; &#123; private K key; private V value; public Pair(K key, V value) &#123; this.key = key; this.value = value; &#125; public void setKey(K key) &#123; this.key = key; &#125; public void setValue(V value) &#123; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125;&#125; 说明 泛型方法的声明，必须在方法的修饰符之后，返回值之前。 方法参数列表，以及方法体中用到的所有泛型变量，都必须声明。 边界符12345678910111213141516171819202122232425public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) &#123; int count = 0; for (T e : anArray) if (e &gt; elem) // compiler error ++count; return count;&#125;// 如此做是错误的。因为除了一些原始类型，其他类是不能使用操作符&gt;&lt;等的。// 所以编译器会报错。解决方法，使用边界符public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) &#123; int count = 0; for (T e : anArray) if (e &gt; elem) // compiler error ++count; return count;&#125;public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123; int count = 0; for (T e : anArray) if (e.compareTo(elem) &gt; 0) ++count; return count;&#125; 通配符 无边界通配符(&lt;?&gt;) 固定上边界通配符(&lt;? extends E&gt;) 固定下边界通配符(&lt;? super E&gt;) 通配符&lt;?&gt;和参数类型的区别在于：对编译器来说，所有的T代表的都是同一种类型，比如public &lt;T&gt; List&lt;T&gt; fill(T ... t);中的T都是代表同一种类型。要么是String，要么是Integer。 但是&lt;?&gt;没有这种限制，Plate&lt;?&gt;单纯的表示：盘子里面放了一个东西，是什么我不知道。 12345678910111213141516171819202122232425262728293031323334353637383940// 例子class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Orange extends Fruit &#123;&#125;// Fruit有两个子类：Apple和Orangepublic class GenericReading &#123; static List&lt;Apple&gt; apples = Arrays.asList(new Apple()); static List&lt;Fruit&gt; fruit = Arrays.asList(new Fruit()); static class Reader&lt;T&gt; &#123; T readExact(List&lt;T&gt; list) &#123; return list.get(0); &#125; &#125; static void f1() &#123; Reader&lt;Fruit&gt; fruitReader = new Reader&lt;Fruit&gt;(); // Errors: List&lt;Fruit&gt; cannot be applied to List&lt;Apple&gt;. // Fruit f = fruitReader.readExact(apples); &#125; public static void main(String[] args) &#123; f1(); &#125;&#125;// 上面f1函数中，获取子类的相关信息，编译器会报错，原因是：List&lt;Apple&gt;和List&lt;Orange&gt;是没有任何的关系的。// 如何解决static class CovariantReader&lt;T&gt; &#123; T readCovariant(List&lt;? extends T&gt; list) &#123; return list.get(0); &#125;&#125;static void f2() &#123; CovariantReader&lt;Fruit&gt; fruitReader = new CovariantReader&lt;Fruit&gt;(); Fruit f = fruitReader.readCovariant(fruit); Fruit a = fruitReader.readCovariant(apples);&#125;public static void main(String[] args) &#123; f2();&#125;// 使用通配符 PECS原则&lt;? extends T&gt; 可以成功的从list里面取get元素，但是能不能add添加元素呢？ 1234567891011121314public class GenericsAndCovariance &#123; public static void main(String[] args) &#123; // Wildcards allow covariance: List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); // Compile Error: can&apos;t add any type of object: // flist.add(new Apple()) // flist.add(new Orange()) // flist.add(new Fruit()) // flist.add(new Object()) flist.add(null); // Legal but uninteresting // We Know that it returns at least Fruit: Fruit f = flist.get(0); &#125;&#125; 答案是否定，Java编译器不允许我们这样做，为什么呢？对于这个问题我们不妨从编译器的角度去考虑。因为List&lt;? extends Fruit&gt; flist它自身可以有多种含义。 123List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Fruit&gt;();List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Orange&gt;(); 当我们add一个元素的时候，flist可能指向的是apple或者orange。当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。 所以对于实现了&lt;? extends T&gt;的集合类只能将它视为Producer向外提供(get)元素，而不能作为Consumer来对外获取(add)元素。 如果要add元素，解决办法是&lt;? super T&gt; 123456789101112131415161718192021public class GenericWriting &#123; static List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); static List&lt;Fruit&gt; fruit = new ArrayList&lt;Fruit&gt;(); static &lt;T&gt; void writeExact(List&lt;T&gt; list, T item) &#123; list.add(item); &#125; static void f1() &#123; writeExact(apples, new Apple()); writeExact(fruit, new Apple()); &#125; static &lt;T&gt; void writeWithWildcard(List&lt;? super T&gt; list, T item) &#123; list.add(item) &#125; static void f2() &#123; writeWithWildcard(apples, new Apple()); writeWithWildcard(fruit, new Apple()); &#125; public static void main(String[] args) &#123; f1(); f2(); &#125;&#125; 这样我们可以往容器里面添加元素了，但是使用super的坏处是以后不能get容器里面的元素了，原因很简单，我们继续从编译器的角度考虑这个问题，对于List&lt;? super Apple&gt; list，它可以有下面几种含义： 123List&lt;? super Apple&gt; list = new ArrayList&lt;Apple&gt;();List&lt;? super Apple&gt; list = new ArrayList&lt;Fruit&gt;();List&lt;? super Apple&gt; list = new ArrayList&lt;Object&gt;(); 当我们尝试通过list来get一个Apple的时候，可能会get得到一个Fruit，这个Fruit可以是Orange等其他类型的Fruit。 所以PECS原则就是： “Producer Extends, Consumer Super” 类型擦除类型擦除就是说Java泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息，这样到了运行期间实际上JVM已经知道泛型所代表的具体类型。 编译通过后，准备进入JVM运行时，就不再有类型参数的概念，换句话说：每定义一个泛型类型，JVM会自动提供一个对应的原生类； 为什么会用类型擦除 在Java诞生10年后，才想实现类似于C++模板的概念，即泛型； Java的类库是Java生态中非常宝贵的财富，必须保证向后兼容（即现有的代码和类文件依旧合法）和迁移兼容（泛化的代码和非泛化的代码可互相调用）基于上面这两个背景和考虑，Java设计者采取了“类型擦除”这种折中的实现方式。 java泛型依赖编译器实现，只存在于编译期间，JVM中没有泛型的概念。编译器的工作就是：set方法编译期检查；get方法返回值进行转型，编译器插入一个checkcast语句。 类型擦除12345678910111213141516171819202122232425public class Node&lt;T&gt; &#123; private T data; private Node&lt;T&gt; next; public Node(T data, Node&lt;T&gt; next) &#123; this.data = data; this.next = next; &#125; public T getData() &#123; return data; &#125;&#125;// 编译器做完相关的类型检查之后，实际上到了运行期间就编程了：public class Node &#123; private Object data; private Node next; public Node(Object data, Node next) &#123; this.data = data; this.next = next; &#125; public Object getData() &#123; return data; &#125; // ...&#125;// 意味着声明Node&lt;String&gt;或者是Node&lt;Integer&gt;，到了运行期间，JVM统统视为Node&lt;Object&gt;。 类型擦除会带来一些问题。 问题 问题一 java不允许创建泛型数组，类似下面这样的做法编译器会报错 12List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];// compile-time error 为什么呢？采用逆向思维，站在编译器的角度考虑问题 123Object[] strings = new String[2];strings[0] = &quot;hi&quot;; // OKstrings[1] = 100; // An ArrayStoreException is thrown. 字符串数组不能存在整型元素，而且这样的错误往往要在运行期间才能被发现，编译器是无法识别的。假设java支持泛型数组的创建会有什么后果。 1234Object[] stringLists = new List&lt;String&gt;[]; // compiler error, but pretend it&apos;s allowedstringLists[0] = new ArrayList&lt;String&gt;(); // OK// An ArrayStoreException should be thrown, but the runtime can&apos;t detect it.stringLists[1] = new ArrayList&lt;Integer&gt;() 假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道new ArrayList()和new ArrayList()的区别。类似这样的错误假如出现才实际的应用场景中，将非常难以察觉。 1234567public class ErasedTypeEquivalence &#123; public static void main(String[] args) &#123; Class c1 = new ArrayList&lt;String&gt;().getClass(); Class c2 = new ArrayList&lt;Integer&gt;().getClass(); System.out.println(c1 == c2); // true &#125;&#125; 问题二 继续复用我们上面的Node的类，对于泛型代码，Java编译器实际上还会偷偷帮我们实现一个Bridge method。 123456789101112131415public class Node&lt;T&gt; &#123; public T data; public Node(T data) &#123; this.data = data; &#125; public void setData(T data) &#123; System.out.println(&quot;Node.setData&quot;); this.data = data; &#125;&#125;public class MyNode extends Node&lt;Integer&gt; &#123; public MyNode(Integer data) &#123; super(data); &#125; public void setData(Integer data) &#123; System.out.println(&quot;MyNode.setData&quot;); super.setData(data); &#125;&#125; 看完上面的分析之后，你可能会认为在类型擦除后，编译器会将Node和MyNode变成下面这样： 123456789101112131415public class Node &#123; public Object data; public Node(Object data) &#123; this.data = data; &#125; public void setData(Object data) &#123; System.out.println(&quot;Node.setData&quot;); this.data = data; &#125;&#125;public class MyNode extends Node &#123; public MyNode(Integer data) &#123; super(data); &#125; public void setData(Integer data) &#123; System.out.println(&quot;MyNode.setData&quot;); super.setData(data); &#125;&#125; 实际上不是这样的，我们先来看一下下面这段代码，这段代码运行的时候会抛出ClassCastException异常，提示String无法转换成Integer： 1234MyNode mn = new MyNode(5);Node n = mn; // A raw type - compiler throws an unchecked warningn.setData(&quot;Hello&quot;); // Causes a ClassCastException to be thrown.// Integer x = mn.data; 如果按照我们上面生成的代码，运行到第3行的时候不应该报错(注意我注释掉了第4行)，因为MyNode中不存在setData(String data)方法，所以只能调用父类Node的setData(Object data)方法，既然这样上面的第3行代码不应该报错，因为String当然可以转换成Object了，那ClassCastException到底是怎么抛出的？ 实际上Java编译器对上面代码自动还做了一个处理： 1234567891011class MyNode extends Node &#123; // Bridge method generated by the compiler public void setData(Object data) &#123; setData((Integer) data); &#125; public void setData(Integer data) &#123; System.out.println(&quot;MyNode.setData&quot;); super.setData(data); &#125; // ...&#125; 这也就是为什么上面会报错的原因了，setData((Integer) data);的时候String无法转换成Integer。所以上面第2行编译器提示unchecked warning的时候，我们不能选择忽略，不然要等到运行期间才能发现异常。如果我们一开始加上Node n = mn就好了，这样编译器就可以提前帮我们发现错误。 问题三 正如我们上面提到的，Java泛型很大程度上只能提供静态类型检查，然后类型的信息就会被擦除，所以像下面这样利用类型参数创建实例的做法编译器不会通过： 1234public static &lt;E&gt; void append(List&lt;E&gt; list) &#123; E elem = new E(); // compile-time error list.add(elem);&#125; 但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题： 1234public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123; E elem = cls.newInstance(); // OK list.add(elem);&#125; 我们可以像下面这样调用： 12List&lt;String&gt; ls = new ArrayList&lt;&gt;();append(ls, String.class); 实际上对于上面这个问题，还可以采用Factory和Template两种设计模式解决，感兴趣的朋友不妨去看一下Thinking in Java中第15章中关于Creating instance of types(英文版第664页)的讲解，这里我们就不深入了。 问题四 我们无法对泛型代码直接使用instanceof关键字，因为Java编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的JVM在运行时期无法识别出ArrayList和ArrayList的之间的区别： 123456public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123; if (list instanceof ArrayList&lt;Integer&gt;) &#123; // compile-time error // ... &#125;&#125;=&gt; &#123; ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt;, LinkedList&lt;Character&gt;, ... &#125; 和上面一样，我们可以使用通配符重新设置bounds来解决这个问题： 12345public static void rtti(List&lt;?&gt; list) &#123; if (list instanceof ArrayList&lt;?&gt;) &#123; // OK; instanceof requires a reifiable type // ... &#125;&#125; 工厂模式接下来我们利用泛型来简单的实现一下工厂模式，首先我们先声明一个接口Factory： 1234package typeinfo.factory;public interface Factory&lt;T&gt; &#123; T create();&#125; 接下来我们来创建几个实体类FuelFilter和AirFilter以及FanBelt和GeneratorBelt。 123456789101112131415class Filter extends Part &#123;&#125;class FuelFilter extends Filter &#123; public static class Factory implements typeinfo.factory.Factory&lt;FuelFilter&gt; &#123; public FuelFilter create() &#123; return new FuelFilter(); &#125; &#125;&#125;class AirFilter extends Filter &#123; public static class Factory implements typeinfo.factory.Factory&lt;AirFilter&gt; &#123; public AirFilter create() &#123; return new AirFilter(); &#125; &#125;&#125; 123456789101112131415class Belt extends Part &#123;&#125;class FanBelt extends Belt &#123; public static class Factory implements typeinfo.factory.Factory&lt;FanBelt&gt; &#123; public FanBelt create() &#123; return new FanBelt(); &#125; &#125;&#125;class GeneratorBelt extends Belt &#123; public static class Factory implements typeinfo.factory.Factory&lt;GeneratorBelt&gt; &#123; public GeneratorBelt create() &#123; return new GeneratorBelt(); &#125; &#125;&#125; Part类的实现如下，注意我们上面的实体类都是Part类的间接子类。在Part类我们注册了我们上面的声明的实体类。所以以后我们如果要创建相关的实体类的话，只需要在调用Part类的相关方法了。这么做的一个好处就是如果的业务中出现了CabinAirFilter或者PowerSteeringBelt的话，我们不需要修改太多的代码，只需要在Part类中将它们注册即可。 123456789101112131415161718class Part &#123; static List&lt;Factory&lt;? extends Part&gt;&gt; partFactories = new ArrayList&lt;Factory&lt;? extends Part&gt;&gt;(); static &#123; partFactories.add(new FuelFilter.Factory()); partFactories.add(new AirFilter.Factory()); partFactories.add(new FanBelt.Factory()); partFactories.add(new PowerSteeringBelt.Factory()); &#125; private static Random rand = new Random(47); public static Part createRandom() &#123; int n = rand.nextInt(partFactories.size()); return partFactories.get(n).create(); &#125; public String toString() &#123; return getClass().getSimpleName(); &#125;&#125; 最后我们来测试一下： 1234567public class RegisteredFactories &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Part.createRandom()); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础之volatile关键字","slug":"java基础之valitile","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2018/02/28/java基础之valitile/","link":"","permalink":"http://zhangbuzola.cn/2018/02/28/java基础之valitile/","excerpt":"","text":"volatile之前在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。 在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 举个简单的例子：在java中，执行下面这个语句： 1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？ 原子性在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 可见性对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 有序性在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 happens-before下面就来具体介绍下happens-before原则（先行发生原则）： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始这8条原则摘自《深入理解Java虚拟机》。 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 volatile关键字一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 volatile保证原子性吗？从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？ 下面看一个例子： 1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 如何保证原子性把上面的代码改成以下任何一种都可以达到效果： 采用synchronized：1234567891011121314151617181920212223public class Test &#123; public int inc = 0; public synchronized void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用Lock：1234567891011121314151617181920212223242526272829public class Test &#123; public int inc = 0; Lock lock = new ReentrantLock(); public void increase() &#123; lock.lock(); try &#123; inc++; &#125; finally&#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用AtomicInteger：1234567891011121314151617181920212223public class Test &#123; public AtomicInteger inc = new AtomicInteger(); public void increase() &#123; inc.getAndIncrement(); &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 volatile能保证有序性吗？在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 volatile的原理和实现机制前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他CPU中对应的缓存行无效。 使用volatile关键字的场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 应用场景下面列举几个Java中使用volatile的几个场景。 状态标记量1234567891011121314151617181920volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125; volatile boolean inited = false;//线程1:context = loadContext(); inited = true; //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context); double check1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"leetcode刷题7","slug":"leetcode-Array-7","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2018/01/29/leetcode-Array-7/","link":"","permalink":"http://zhangbuzola.cn/2018/01/29/leetcode-Array-7/","excerpt":"","text":"485. Max Consecutive Ones题目描述Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: 12345Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last threedigits are consecutive 1s.The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 解题思路12345678910111213141516171819202122class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int len = nums.length; if(len == 1 &amp;&amp; nums[0] == 1) &#123; return 1; &#125; int count = 0; int maxCount = 0; int i = 0; while(i &lt; len)&#123; if(nums[i] == 1) &#123; count++; &#125; else &#123; maxCount = Math.max(count, maxCount); count = 0; &#125; i++; &#125; maxCount = Math.max(count, maxCount); return maxCount; &#125;&#125; 1234567891011121314class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int max = 0; int sum = 0; for(int i = 0 ; i&lt; nums.length; i ++)&#123; sum += nums[i]; if(nums[i] == 0) sum = 0; else max = Math.max(max, sum); &#125; return max; &#125;&#125; 448. Find All Numbers Disappeared in an Array题目描述Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 1234Input:[4,3,2,7,8,2,3,1]Output:[5,6] 解题思路12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * *//** * @author zolanunu * */public class FindAllNumbersDisappearedInAnArray &#123; public static List&lt;Integer&gt; findDisappearedNumber(int[] nums) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++) &#123; int val = Math.abs(nums[i]) - 1; //System.out.println(val); if(nums[val] &gt; 0) &#123; nums[val] = -nums[val]; System.out.print(&quot;nums[val]: &quot; + nums[val] + &quot; &quot;); &#125; &#125; System.out.println(); for(int i = 0; i &lt; nums.length; i++) &#123; System.out.print(nums[i] + &quot; &quot;); &#125; for(int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] &gt; 0) &#123; ret.add(i+1); &#125; &#125; return ret; &#125; public static void main(String[] args) &#123; int[] nums = &#123;4,3,2,7,8,2,3,1&#125;; System.out.println(Math.abs(2)); findDisappearedNumber(nums); &#125;&#125; 442. Find All Duplicates in an Array题目描述Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? Example: 1234Input:[4,3,2,7,8,2,3,1]Output:[2,3] 解题思路这类问题的一个重要条件就是1 ≤ a[i] ≤ n (n = size of array)，不然很难在O(1)空间和O(n)时间内完成。首先来看一种正负替换的方法，这类问题的核心是就是找nums[i]和nums[nums[i] - 1]的关系，我们的做法是，对于每个nums[i]，我们将其对应的nums[nums[i] - 1]取相反数，如果其已经是负数了，说明之前存在过，我们将其加入结果res中即可，参见代码如下： 123456789101112131415161718192021222324252627package com.leetcode.coding;import java.util.ArrayList;import java.util.List;/** * @author zolanunu * */public class FindAllDuplicatesInAnArray &#123; public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; int len = nums.length; if(len == 1) &#123; return null; &#125; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; len; i++) &#123; int temp = Math.abs(nums[i]) - 1; if(nums[temp] &lt; 0) &#123; ret.add(temp+1); &#125; nums[temp] = -nums[temp]; &#125; return ret; &#125;&#125; 414. Third Maximum Number题目描述Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: 123Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. Example 2: 123Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. Example 3: 1234Input: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 解题思路1234567891011121314151617181920212223242526272829303132package com.leetcode.coding;/** * @author zolanunu * */public class ThirdMaximumNumber &#123; public static int thirdMax(int[] nums) &#123; Integer max1 = null; Integer max2 = null; Integer max3 = null; for (Integer n : nums) &#123; if (n.equals(max1) || n.equals(max2) || n.equals(max3)) continue; if (max1 == null || n &gt; max1) &#123; max3 = max2; max2 = max1; max1 = n; &#125; else if (max2 == null || n &gt; max2) &#123; max3 = max2; max2 = n; &#125; else if (max3 == null || n &gt; max3) &#123; max3 = n; &#125; &#125; return max3 == null ? max1 : max3; &#125; public static void main(String[] args) &#123; int[] a = &#123;1,2,-2147483648&#125;; //System.out.println(Integer.MIN_VALUE &lt; -2147483648); System.out.println(thirdMax(a)); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://zhangbuzola.cn/tags/算法与数据结构/"},{"name":"leetcode","slug":"leetcode","permalink":"http://zhangbuzola.cn/tags/leetcode/"}]},{"title":"并发编程中:原子性、可见性、有序性","slug":"java基础之程序原子性","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/01/28/java基础之程序原子性/","link":"","permalink":"http://zhangbuzola.cn/2018/01/28/java基础之程序原子性/","excerpt":"","text":"在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念： 原子性原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10; //线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 但是这个可见性是如何实现的呢？？ 有序性有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： 1234int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 语句执行的可能顺序是： 语句2 语句1 语句3 语句4 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://zhangbuzola.cn/tags/并发编程/"}]},{"title":"leetcode刷题6","slug":"leetcode-Array-6","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/01/28/leetcode-Array-6/","link":"","permalink":"http://zhangbuzola.cn/2018/01/28/leetcode-Array-6/","excerpt":"","text":"768. Max Chunks To Make Sorted题目描述Given an array arr that is a permutation of [0, 1, …, arr.length - 1], we split the array into some number of “chunks” (partitions), and individually sort each chunk. After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made? Example 1: 12345Input: arr = [4,3,2,1,0]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&apos;t sorted. Example 2: 12345Input: arr = [1,0,2,3,4]Output: 4Explanation:We can split into two chunks, such as [1, 0], [2, 3, 4].However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. Note: arr will have length in range [1, 10]. arr[i] will be a permutation of [0, 1, …, arr.length - 1]. 将数组arr拆分成若干部分，使得每一部分分别排序后，重新组合在一起的数组递增有序。 求最多可以分成多少个部分。 解题思路贪心算法（Greedy Algorithm） 记数组arr长度为N，下标x从N - 1到0逐一递减： 若min(arr[x .. N - 1]) &gt; max(arr[0 .. x - 1])，则令结果+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * */package com.leetcode.coding;/** * @author zolanunu * */public class MaxChunksToMakeSortedII &#123; public int maxChunksToSorted(int[] arr) &#123; int len = arr.length; int ans = 1; for (int x = len-2; x &gt;= 0; x--) &#123; if(min(arr, x+1, arr.length-1) &gt; max(arr, 0, x))&#123; // 版本二是：数组arr中有重复元素 变化仅仅是这里的判定条件 // 若min(arr[x .. N - 1]) &gt;= max(arr[0 .. x - 1])，则令结果+1 ans++; &#125; &#125; return ans; &#125; public int min(int[] arr, int s, int e) &#123; if(s == e) &#123; return arr[s]; &#125; int min = arr[s]; for(int i = s+1; i &lt;= e; i++) &#123; if(arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; return min; &#125; public int max(int[] arr, int s, int e) &#123; if(s == e) &#123; return arr[s]; &#125; int max = arr[s]; for(int i = s+1; i &lt;= e; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; return max; &#125;&#125; 766. Toeplitz Matrix题目描述A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Example 1: 123456789Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]Output: TrueExplanation:123451239512In the above grid, the diagonals are &quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;, and in each diagonalall elements are the same, so the answer is True. Example 2: 1234Input: matrix = [[1,2],[2,2]]Output: FalseExplanation:The diagonal &quot;[1, 2]&quot; has different elements. Note: matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. 解题思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * */package com.leetcode.coding;/** * @author zolanunu * */public class ToeplitzMatrix &#123; public boolean isToeplitzMatrix(int[][] matrix) &#123; int row = matrix.length, col = matrix[0].length; if(col == 1 || row == 1) &#123; return true; &#125; if(isLeft(matrix, row, col) &amp;&amp; isRight(matrix, row, col) &amp;&amp; isDiagonal(matrix, row, col)) &#123; return true; &#125; return false; &#125; public boolean isRight(int[][] matrix, int row, int col) &#123; for(int i = 1; i &lt; col; i++) &#123; int j = i+1, k = 1; while(j &lt; col &amp;&amp; k &lt; row) &#123; if(matrix[0][i] == matrix[k++][j++]) &#123; continue; &#125;else &#123; return false; &#125; &#125; &#125; return true; &#125; public boolean isLeft(int[][] matrix, int row, int col) &#123; for(int i = 1; i &lt; row; i++) &#123; int j = i+1, k = 1; while(j &lt; row &amp;&amp; k &lt; col) &#123; if(matrix[i][0] == matrix[j++][k++]) &#123; continue; &#125; else &#123; return false; &#125; &#125; &#125; return true; &#125; public boolean isDiagonal(int[][] matrix, int row, int col) &#123; int j = 1, k = 1; while(j &lt;row &amp;&amp; k &lt; col) &#123; if(matrix[0][0] == matrix[j++][k++]) &#123; continue; &#125; else &#123; return false; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123;&#123;1,2&#125;,&#123;2,2&#125;&#125;; ToeplitzMatrix toeplitzMatrix = new ToeplitzMatrix(); System.out.println(toeplitzMatrix.isToeplitzMatrix(matrix)); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://zhangbuzola.cn/tags/算法与数据结构/"},{"name":"leetcode","slug":"leetcode","permalink":"http://zhangbuzola.cn/tags/leetcode/"}]},{"title":"java集合框架学习之HashMap","slug":"java集合之HashMap","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/01/21/java集合之HashMap/","link":"","permalink":"http://zhangbuzola.cn/2018/01/21/java集合之HashMap/","excerpt":"","text":"HashMap简介下面对java8中的HashMap来分析，了解HashMap是如何实现的以及其中有哪些需要注意事项，主要用在哪些场景中，和其他集合有什么区别，以及和java7中的hashmap的实现区别。 HashMap的继承关系如下： 首先先对HashMap有一个大致的了解。 HashMap实质上是一个哈希表，存储的内容是key-value的键值对。key和value都可以是null，但是只能有一个。 1.8采用的是数组+链表+红黑树，在链表过长的时候可以通过转换成红黑树提升访问性能 继承于AbstractMap，实现了Map，Cloneable，java.io.Serialized接口 123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable HashMap的实现不是同步的，这意味着不是线程安全的。HashMap中的映射不是有序的。 HashMap的实例有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行rehash操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 通常，默认加载因子是0.75, 这是在时间和空间成本上寻求一种折衷。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。 HashMap是一种支持快速存取的数据结构。 HashMap源码成员变量123456789101112131415161718192021222324//默认初始化map的容量：16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//map的最大容量：2^30static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认的填充因子：0.75，能较好的平衡时间与空间的消耗static final float DEFAULT_LOAD_FACTOR = 0.75f;//将链表(桶)转化成红黑树的临界值static final int TREEIFY_THRESHOLD = 8;//将红黑树转成链表(桶)的临界值static final int UNTREEIFY_THRESHOLD = 6;//转变成树的table的最小容量，小于该值则不会进行树化static final int MIN_TREEIFY_CAPACITY = 64;//上图所示的数组，长度总是2的幂次transient Node&lt;K,V&gt;[] table;//map中的键值对集合transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;//map中键值对的数量transient int size;//用于统计map修改次数的计数器，用于fail-fast抛出ConcurrentModificationExceptiontransient int modCount;//大于该阈值，则重新进行扩容，threshold = capacity(table.length) * load factorint threshold;//填充因子final float loadFactor; 其中，HashMap的数组是Node类型的，不是Entry的。 Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。 12345678910111213141516171819202122232425262728293031323334353637383940414243static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // key &amp; value 的 hash值 final int hash; final K key; V value; //指向下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) &#123; return true; &#125; return false; &#125;&#125; 构造函数12345678910111213141516171819202122232425public HashMap() &#123; //其他成员变量也都是默认的 this.loadFactor = DEFAULT_LOAD_FACTOR;&#125;public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor;//tableSizeFor()是用来将初始化容量转化大于输入参数且最近的2的整数次幂的数，比如initialCapacity = 7，那么转化后就是8。 this.threshold = tableSizeFor(initialCapacity);&#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; tableSizeFor()，将初始化容量转化大于或等于最接近输入参数的2的整数次幂的数: 12345678910static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt; 1; n |= n &gt;&gt; 2; n |= n &gt;&gt; 4; n |= n &gt;&gt; 8; n |= n &gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;// | 或运算符 &gt;&gt;&gt; 无符号右移，忽略符号位 putMapEntries()函数 123456789101112131415161718192021222324//evict表示是不是初始化map，false表示是初始化mapfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; //获取m中键值对的数量 int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; //计算map的容量，键值对的数量 = 容量 * 填充因子 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); //如果容量大于了阈值，则重新计算阈值。 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; //如果table已经有，且键值对数量大于了阈值，进行扩容 else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; 主要的APIget()1234567891011121314151617181920212223242526272829public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //先是判断一通table是否为空以及根据hash找到存放的table数组的下标，并赋值给临时变量 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //总是先检查数组下标第一个节点是否满足key，满足则返回 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //如果第一个与key不相等，则循环查看桶 if ((e = first.next) != null) &#123; //检查是否为树节点，是的话采用树节点的方法来获取对应的key的值 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //do-while循环判断，直到找到为止 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; put()来一个put方法很清晰的流程图 接下来就是详细的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; /** * Implements Map.put and related methods * @param hash key的hash值 * @param key * @param value * @param onlyIfAbsent 如果为true，则在有值的时候不会更新 * @param evict false表示在创建map */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果为空，则扩容。注意这里的赋值操作，关系到下面 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果tab对应的数组位置为空，则创建新的node，并指向它 if ((p = tab[i = (n - 1) &amp; hash]) == null) // newNode方法就是返回Node：return new Node&lt;&gt;(hash, key, value, next); tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //如果比较hash值和key的值都相等，说明要put的键值对已经在里面，赋值给e if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //如果p节点是树节点，则执行插入树的操作 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //不是树节点且数组中第一个也不是，则在桶中查找 else &#123; for (int binCount = 0; ; ++binCount) &#123; //找到了最后一个都不满足的话，则在最后插入节点。注意这里的e = p.next，赋值兼具判断都在if里了 if ((e = p.next) == null) p.next = newNode(hash, key, value, null); //之前field说明中的，如果桶中的数量大于树化阈值，则转化成树，第一个是-1 if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; &#125; //在桶中找到了对应的key，赋值给e，退出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //没有找到，则继续向下一个节点寻找 p = e; &#125; &#125; //上面循环中找到了e，则根据onlyIfAbsent是否为true来决定是否替换旧值 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //钩子函数，用于给LinkedHashMap继承后使用，在HashMap里是空的 afterNodeAccess(e); return oldValue; &#125; &#125; //修改计数器+1 ++modCount; //实际大小+1， 如果大于阈值，重新计算并扩容 if (++size &gt; threshold) resize(); //钩子函数，用于给LinkedHashMap继承后使用，在HashMap里是空的 afterNodeInsertion(evict); return null;&#125; resize()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// resize() 对map进行扩容final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; //扩容/缩容前的容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧的阈值 int oldThr = threshold; int newCap, newThr = 0; //说明之前已经初始化过map if (oldCap &gt; 0) &#123; //达到了最大的容量，则将阈值设为最大，并且返回旧的table if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果两倍的旧容量小于最大的容量且旧容量大于等于默认初始化容量，则旧的阈值也扩大两倍。 //oldCap &lt;&lt; 1，其实就是*2的意思，不过位运算效率更高。 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //旧容量为0且旧阈值大于0，则赋值给新的容量(应该是针对初始化的时候指定了其容量的构造函数出现的这种情况) else if (oldThr &gt; 0) newCap = oldThr; //这种情况就是调用无参数的构造函数 else &#123; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 新阈值为0，则通过：新容量*填充因子 来计算 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; //根据新的容量来初始化table，并赋值给table @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //如果旧的table里面有存放节点，则初始化给新的table if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; //将下标为j的数组赋给临时节点e if ((e = oldTab[j]) != null) &#123; //清空 oldTab[j] = null; //如果该节点没有指向下一个节点，则直接通过计算hash和新的容量来确定新的下标，并指向e if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果为树节点，按照树节点的来拆分 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //e还有其他的节点，将该桶拆分成两份(不一定均分) else &#123; //loHead是拆分后的，链表的头部，tail为尾部 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //根据e的hash值和旧的容量做位与运算是否为0来拆分，注意之前是 e.hash &amp; (oldCap - 1) if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; resize()方法对整个数组以及桶进行了遍历，极其耗费性能，所以再次强调在我们明确知道map要用的容量的时候，使用指定初始化容量的构造函数。 remove()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public V remove(Object key) &#123; Node&lt;K,V&gt; e; //与之前的put、get一样，remove也是调用其他的方法 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;/** * Implements Map.remove and related methods * * @param hash key的hash值 * @param key * @param value 与下面的matchValue结合，如果matchValue为false，则忽略value * @param matchValue 为true，则判断是否与value相等 * @param movable 主要跟树节点的remove有关，为false，则不移动其他的树节点 */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //老规矩，还是先判断table是否为空之类的逻辑，注意赋值操作 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; //对下标节点进行判断，如果相同，则赋给临时节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; //为树节点，则按照树节点的操作来进行查找并返回 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; //do-while循环查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //如果找到了key对应的node，则进行删除操作 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; //为树节点，则进行树节点的删除操作 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); //如果p == node，说明该key所在的位置为数组的下标位置，所以下标位置指向下一个节点即可 else if (node == p) tab[index] = node.next; //否则的话，key在桶中，p为node的上一个节点，p.next指向node.next即可 else p.next = node.next; //修改计数器 ++modCount; --size; //钩子函数，与上同 afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; ​ 这里提到里的remove的话，肯定与之联想到的就是其抛出ConcurrentModificationException。举个栗子： 12345678Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;GoddessY&quot;, 1);map.put(&quot;Joemsu&quot;, 2);for (String a : map.keySet()) &#123; if (&quot;GoddessY&quot;.equals(a)) &#123; map.remove(a); &#125;&#125; treeifyBin()12345678910111213141516171819202122232425final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; //这里MIN_TREEIFY_CAPACITY派上了用场，及时单个桶数量达到了树化的阈值，总的容量没到，也不会进行树化 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; // 返回树节点 return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); //为空说明是第一个节点，作为树的根节点 if (tl == null) hd = p; //设置树的前后节点 else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); //对整棵树进行处理，形成红黑树 if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125; 数据结构HashMap的结构 和其他集合的区别ConcurrentHashMap比较下面是CurrentHashMap的存储结构 ConcurrentHashMap线程安全，速度慢，分段锁，不是整体锁 HashMap线程不安全，速度快 concurrentHashMap适合用在并发编程中，其实就是在要求线程安全的时候用 HashTable比较 hashtable在jdk1.1中出现，hashmap则是在止呕jdk1.2的版本中出现，hashmap比hashtable出现得晚一些。 继承体系有些不同。虽然都实现了Map，Cloneable，Serializable三个接口，但是HashMap继承自抽象类AbstractMap，而hashtable继承自抽象类Dictionary。其中Dictionary类已经是一个废弃的类了。HashTable比HashMap多了两个公开方法。一个是elements，这来自于抽象类Dictionary，鉴于该类已经废弃，所以这个方法也就没什么用处了。另一个多出来的方法是contains，这个多出来的方法也没什么用，因为它跟containsValue方法功能是一样的。 从公开的方法上来看，这两个类提供的，是一样的功能。都提供键值映射的服务，可以增、删、查、改键值对，可以对建、值、键值对提供遍历视图。支持浅拷贝，支持序列化 hashmap是支持null键和null值，而hashtable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。 HashMap/HashTable内部用Entry数组实现哈希表，而对于映射到同一个哈希桶（数组的同一个位置）的键值对，使用Entry链表来存储(解决hash冲突)。 HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。就是说hashtable会尽量使用素数，奇数。而hashmap则总是使用2的幂作为哈希表的大小。因为当哈希表的大小为素数的时候，简单的取模哈希的结果会比较均匀。但是hashmap在取模计算的话，模数是2的幂，可以直接使用位运算来得到结果，效率要大于高于做除法。所以从hash计算的效率上，hashmap更优。事实就是HashMap为了加快hash的速度，将哈希表的大小固定为了2的幂。当然这引入了哈希分布不均匀的问题，所以HashMap为解决这问题，又对hash算法做了一些改动。 123456789101112131415161718192021222324252627282930313233343536// hash 不能超过Integer.MAX_VALUE 所以要取其最小的31个bitint hash = hash(key);int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 直接计算key.hashCode()private int hash(Object k) &#123; // hashSeed will be zero if alternative hashing is disabled. return hashSeed ^ k.hashCode();&#125; 以下代码及注释来自java.util.HashMapint hash = hash(key);int i = indexFor(hash, table.length); // 在计算了key.hashCode()之后，做了一些位运算来减少哈希冲突final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; // 取模不再需要做除法static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;; return h &amp; (length-1);&#125; HashMap由于使用了2的幂次方，所以在取模运算时不需要做除法，只需要位的与运算就可以了。但是由于引入的hash冲突加剧问题，HashMap在调用了对象的hashCode方法之后，又做了一些位运算在打散数据。 HashTable是同步的，HashMap不是，也就是说HashTable在多线程使用的情况下，不需要做额外的同步，而HashMap则不行。 hashtable已经被淘汰了。 HashSet比较 HashSet里面有一个HashMap（适配器模式） 12345678910111213141516//HashSet是对HashMap的简单包装public class HashSet&lt;E&gt;&#123; ...... private transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125; hashset也是无序的 TreeMap比较HashMap：数组方式存储key/value，线程非安全，允许null作为key和value，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，key的hash值是先计算key的hashcode值，然后再进行计算，每次容量扩容会重新计算所以key的hash值，会消耗资源，要求key必须重写equals和hashcode方法 默认初始容量16，加载因子0.75，扩容为旧容量乘2，查找元素快，如果key一样则比较value，如果value不一样，则按照链表结构存储value，就是一个key后面有多个value； TreeMap：基于红黑二叉树的NavigableMap的实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出 LinkedHashMap比较 LinkedHashMap也是一个HashMap,但是内部维持了一个双向链表,可以保持顺序 事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。 迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可 其他补充table数组大小在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考 http://blog.csdn.net/liuqiyao_01/article/details/14475159 Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。 HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 确定哈希桶数组索引位置不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): 1234567891011方法一：static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;方法二：static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 线程不安全例子1234567891011121314151617181920public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， &quot;C&quot;); new Thread(&quot;Thread1&quot;) &#123; public void run() &#123; map.put(7, &quot;B&quot;); System.out.println(map); &#125;; &#125;.start(); new Thread(&quot;Thread2&quot;) &#123; public void run() &#123; map.put(3, &quot;A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 参考http://www.importnew.com/28263.html https://www.cnblogs.com/skywang12345/p/3310835.html http://www.cnblogs.com/joemsu/p/7724623.html https://zhuanlan.zhihu.com/p/21673805","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"Collections","slug":"Collections","permalink":"http://zhangbuzola.cn/tags/Collections/"},{"name":"HashMap","slug":"HashMap","permalink":"http://zhangbuzola.cn/tags/HashMap/"}]},{"title":"leetcode刷题5","slug":"leetcode-Array-5","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2018/01/17/leetcode-Array-5/","link":"","permalink":"http://zhangbuzola.cn/2018/01/17/leetcode-Array-5/","excerpt":"","text":"755. Pour Water题目描述We are given an elevation map, heights[i] representing the height of the terrain at that index. The width at each index is 1. After V units of water fall at index K, how much water is at each index? Water first drops at index K and rests on top of the highest terrain or water at that index. Then, it flows according to the following rules: If the droplet would eventually fall by moving left, then move left. Otherwise, if the droplet would eventually fall by moving right, then move right. Otherwise, rise at it’s current position. Here, “eventually fall” means that the droplet will eventually be at a lower level if it moves in that direction. Also, “level” means the height of the terrain plus any water in that column.We can assume there’s infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block. Example: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3Output: [2,2,2,3,2,2,2]Explanation:# ## ## # ########### 0123456 &lt;- indexThe first drop of water lands at index K = 3:# ## w ## # ########### 0123456 When moving left or right, the water can only move to the same level or a lower level.(By level, we mean the total height of the terrain plus any water in that column.)Since moving left will eventually make it fall, it moves left.(A droplet &quot;made to fall&quot; means go to a lower height than it was at previously.)# ## ## w# ########### 0123456 Since moving left will not make it fall, it stays in place. The next droplet falls:# ## w ## w# ########### 0123456 Since the new droplet moving left will eventually make it fall, it moves left.Notice that the droplet still preferred to move left,even though it could move right (and moving right makes it fall quicker.)# ## w ## w# ########### 0123456 # ## ##ww# ########### 0123456 After those steps, the third droplet falls.Since moving left would not eventually make it fall, it tries to move right.Since moving right would eventually make it fall, it moves right.# ## w ##ww# ########### 0123456 # ## ##ww#w########### 0123456 Finally, the fourth droplet falls.Since moving left would not eventually make it fall, it tries to move right.Since moving right would not eventually make it fall, it stays in place:# ## w ##ww#w########### 0123456 The final answer is [2,2,2,3,2,2,2]: # ####### ####### 0123456 Example: 12345Input: heights = [1,2,3,4], V = 2, K = 2Output: [2,3,3,4]Explanation:The last droplet settles at index 1, since moving furtherleft would not cause it to eventually fall to a lower height. Example: 12Input: heights = [3,1,3], V = 5, K = 1Output: [4,4,4] Note: heights will have length in [1, 100] and contain integers in [0, 99]. V will be in range [0, 2000]. K will be in range [0, heights.length - 1]. 题目大意： 给定一个组高度值，代表一个水槽的底部高度分布情况。在K点处倒入V体积的水，求倒水之后的高度分布。 倒入的每一体积的水按照如下规则进行流动 如果在K点左侧存在地势较低且可达的位置，则水优先向左流动。否则，在K点右侧存在地势较低且可达的位置，则水向右侧流动。否则，水停留在K处。 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.leetcode.coding;public class PourWater &#123; /** * 底部高度分布不同的水槽中倒水，求最后的水槽高度分布 * */ /** * 思路：倒入的每一体积的水按照如下规则进行流动 * 如果在K点左侧存在地势较低且可达的位置，则水优先向左流动。 * 否则，在K点右侧存在地势较低且可达的位置，则水向右侧流动。 * 否则，水停留在K处。 * */ /** * @Title: findLeftIndex * @Description: 找到左端的低处 * @param: * @return: * @throws */ public int findLeftMinIndex(int[] heights, int k) &#123; int minIndex = k, minHeight = heights[k]; for(int i = k-1; i &gt;= 0; i--) &#123; if(heights[i] &lt; minHeight) &#123; minIndex = i; minHeight = heights[i]; &#125; else if(heights[i] &gt; minHeight) &#123; break; &#125; &#125; return minIndex; &#125; /** * @Title: findRightMinIndex * @Description: TODO(这里用一句话描述这个方法的作用) * @param: * @return: void * @throws */ public int findRightMinIndex(int[] heights, int k) &#123; // TODO Auto-generated method stub int minIndex = k, minHeight = heights[k]; for(int i = k+1; i &lt; heights.length; i++) &#123; if(heights[i] &lt; minHeight) &#123; minIndex = i; minHeight = heights[i]; &#125; else if(heights[i] &gt; minHeight) &#123; break; &#125; &#125; return minIndex; &#125; public int[] pourWater(int[] heights, int V, int K) &#123; for(int i = 0; i &lt; V; i++) &#123; int leftMinIndex = findLeftMinIndex(heights, K); if(leftMinIndex &lt; K) &#123; heights[leftMinIndex]++; &#125; else &#123; int rightMinIndex = findRightMinIndex(heights, K); if(rightMinIndex &gt; K) &#123; heights[rightMinIndex]++; &#125; else &#123; heights[K]++; &#125; &#125; &#125; return heights; &#125;&#125; 747. Largest Number At Least Twice of Others题目描述In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: 1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. Example 2: 123Input: nums = [1, 2, 3, 4]Output: -1Explanation: 4 isn&apos;t at least as big as twice the value of 3, so we return -1. Note: nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99]. 题意：找到数组中最大元素，并且确定最大元素至少比其他元素大两倍以上，满足则返回最大元素的下标，否则，返回-1。 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * */package com.leetcode.coding;/** * @author Skygazer * */public class LargestNumberTwiceThanOthers &#123; public int domainantIndex(int[] nums) &#123; int maxIndex = max(nums); System.out.println(maxIndex); for(int i = 0; i &lt; nums.length; i++) &#123; if(i != maxIndex) &#123; if(nums[i] * 2 &gt; nums[maxIndex]) &#123; return -1; &#125; &#125; else &#123; continue; &#125; &#125; return maxIndex; &#125; /** * 思路一： 蛮力法，找到最大元素以后，再一一比对是否满足条件 * 思路二： 排序后，如果最大元素能大于或者等于第二大的元素的两倍，则满足条件。 * */ public int max(int[] nums) &#123; int maxIndex = 0; for(int i = 1; i &lt; nums.length; i++) &#123; if(nums[i] &gt; nums[maxIndex]) &#123; maxIndex = i; &#125; &#125; return maxIndex; &#125; public static void main(String[] args) &#123; LargestNumberTwiceThanOthers l = new LargestNumberTwiceThanOthers(); int[] nums = &#123;0,0,0,1&#125;; int i = l.domainantIndex(nums); System.out.println(i); &#125;&#125; 561. Array Partition I题目描述Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 123Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. 解题思路排序，下标为偶数的元素求和即为所求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * */package com.leetcode.coding;import org.omg.CORBA.PUBLIC_MEMBER;/** * @author zolanunu * */public class ArrayPartitionI &#123; public int arrayPartitionI(int[] nums) &#123; heapSort(nums); int sum = 0; for(int i = 0; i &lt; nums.length; i += 2) &#123; sum = sum + nums[i]; &#125; return sum; &#125; public int[] sort(int[] nums) &#123; // 排序，利用简单选择排序 return sort(nums, nums.length); &#125; public int[] sort(int[] nums, int n) &#123; int key, temp; if(nums.length &lt;= 1) &#123; return nums; &#125; for(int i = 0; i &lt; n; i++) &#123; key = selectMinK(nums, n, i); if(key != i) &#123; temp = nums[i]; nums[i] = nums[key]; nums[key] = temp; &#125; &#125; return nums; &#125; public int selectMinK(int[] nums, int n, int i) &#123; int k = i; for(int j = i + 1; j &lt; n; j++) &#123; if(nums[j] &lt; nums[k]) &#123; k = j; &#125; &#125; return k; // 几下最小元素的下标 &#125; // 堆排序 public void heapAdjust(int[] a, int p, int len) &#123; int temp = a[p]; //保存当前父亲节点 int child = 2 * p + 1; // 左孩子 while(child &lt; len) &#123; // 如果有右孩子节点，并且右孩子节点的值大于左孩子节点，则选择右孩子节点 if(child + 1&lt;len &amp;&amp;a[child] &lt; a[child + 1]) &#123; child++; &#125; // 如果父亲节点的值已经大于孩子节点的值，则直接结束 if(temp &gt;= a[child]) &#123; break; &#125; // 把孩子节点的值赋值给父亲节点 a[p] = a[child]; p = child; child = 2 * child + 1; &#125; a[p] = temp; &#125; public void heapSort(int[] a) &#123; for(int i = a.length / 2; i &gt;= 0; i--) &#123; heapAdjust(a, i, a.length); &#125; // 进行第n-1次循环，完成排序 for(int i = a.length -1; i &gt; 0; i--) &#123; // 最后一个元素和第一个元素交换 int temp = a[i]; a[i] = a[0]; a[0] = temp; // 筛选R[0]节点，得到第i-1个节点的堆 heapAdjust(a, 0, i); //System.out.format(&quot;第%d趟： \\t&quot;, a.length-i); //printPart(a, 0, a.length-1); &#125; &#125; public static void main(String[] args) &#123; ArrayPartitionI arrayPartitionI = new ArrayPartitionI(); int[] nums = &#123;5, 4, 2, 3&#125;; int sum = arrayPartitionI.arrayPartitionI(nums); System.out.println(&quot;sum = &quot; + sum); &#125;&#125; MinCostClimbingStairs题目描述On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: 123Input: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: 123Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. 题意：有n级台阶，每次可以向上跳1至2级，上台阶的总花费为sum(cost[i])， i为所有踩过的台阶。 求最小花费。 解题思路利用动态规划 dp[x] = min(dp[x-1], dp[x-2])+cost[x] 1234567891011121314151617181920/** * */package com.leetcode.coding;/** * @author zolanunu * */public class MinCostClimbingStairs &#123; public int minCostClimbingStairs(int[] cost) &#123; int[] dp = new int[cost.length]; dp[0] = cost[0]; dp[1] = cost[1]; for(int i = 2; i &lt; cost.length; i++) &#123; dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i]; &#125; return Math.min(dp[cost.length-1], dp[cost.length-2]); &#125;&#125; 661. Image Smoother题目描述Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: 123456789101112Input:[[1,1,1], [1,0,1], [1,1,1]]Output:[[0, 0, 0], [0, 0, 0], [0, 0, 0]]Explanation:For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0For the point (1,1): floor(8/9) = floor(0.88888889) = 0 Note: The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150]. 大意：给定二维矩阵，表示图像的灰度。对图像进行平滑处理，将每一个像素的值换成其周围9个单元格的平均值。 解题思路123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[][] imageSmoother(int[][] M) &#123; if (M == null) return null; int rows = M.length; if (rows == 0) return new int[0][]; int cols = M[0].length; int result[][] = new int[rows][cols]; for (int row = 0; row &lt; rows; row++) &#123; for (int col = 0; col &lt; cols; col++) &#123; int count = 0; int sum = 0; for (int incR : new int[]&#123;-1, 0, 1&#125;) &#123; for (int incC : new int[]&#123;-1, 0, 1&#125;) &#123; if (isValid(row + incR, col + incC, rows, cols)) &#123; count++; sum += M[row + incR][col + incC]; &#125; &#125; &#125; result[row][col] = sum / count; &#125; &#125; return result; &#125; private boolean isValid(int x, int y, int rows, int cols) &#123; return x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols; &#125;&#125; 643. Maximum Average Subarray I题目描述Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. Example 1: 123Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Note: 1 &lt;= k &lt;= n &lt;= 30,000. Elements of the given array will be in the range [-10,000, 10,000]. 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * */package com.leetcode.coding;/** * @author zolanunu * */public class MaximumAverageSubarrayI &#123; public static double findMaxAverage(int[] nums, int k) &#123; if(k &gt; nums.length || nums.length == 0 || k &lt;= 0) &#123; return 0.0; &#125; double maxAverage = Integer.MIN_VALUE; for(int i = 0; i &lt; nums.length-k+1; i++) &#123; int sum = 0; //System.out.println(i + &quot;, &quot; + maxAverage); for(int j = i; j &lt; i+k; j++) &#123; sum = sum + nums[j]; &#125; //System.out.println(i + &quot;, &quot;+ sum); if(sum / (double)k &gt; maxAverage) &#123; maxAverage = sum / (double)k; &#125; &#125; return maxAverage; &#125; public double findMaxAverage1(int[] nums, int k) &#123; double sum = 0.0; for(int i =0; i &lt; k; i++) &#123; sum = sum + nums[i]; &#125; double res = sum; for(int i =k; i &lt; nums.length; i++) &#123; sum += nums[i] - nums[i -k]; res = Math.max(res, sum); &#125; return res/(double)k; &#125; public static void main(String[] args) &#123; int[] nums = &#123;1,12,-5,-6,50,3&#125;; double x = findMaxAverage(nums, 4); System.out.println(x); &#125;&#125; 628. Maximum Product of Three Numbers题目描述Given an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: 12Input: [1,2,3]Output: 6 Example 2: 12Input: [1,2,3,4]Output: 24 Note: The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer. 解题思路123456789101112131415161718192021/** * */package com.leetcode.coding;import java.util.Arrays;/** * @author zolanunu * */public class MaximumProductofThreeNumbers &#123; public int maximumProduct(int[] nums) &#123; if(nums.length &lt; 3) &#123; return 0; &#125; // 首先对数组进行排序 Arrays.sort(nums); return Math.max(nums[0]*nums[1]*nums[nums.length-1], nums[nums.length-1]*nums[nums.length-2]*nums[nums.length-3]); &#125;&#125; 560. Subarray Sum Equals K题目描述Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: 12Input:nums = [1,1,1], k = 2Output: 2 Note: The length of the array is in range [1, 20,000]. 解题思路最直观的想法是遍历数组并依次加当前位置的数字，同时用数组sum记录下当前位置之前所有数字的相加和，这样下标[i, j)之间的数字之和就可以用sum[j]-sum[i]来计算，然后通过双层循环，遍历所有情况来统计满足条件的子数组个数。具体代码： 12345678910111213141516171819public int subarraySum(int[] nums, int k) &#123; if(nums.length == 0) &#123; return 0; &#125; //int num = 0; int se = nums.length, cnt = 0; int[] sum = new int[se+1]; for(int i = 0; i &lt; se; i++) &#123; sum[i+1] = sum[i] + nums[i]; &#125; for(int i = 0; i &lt; se; i++) &#123; for(int j = i + 1; j &lt;= se; j++) &#123; if(sum[j] - sum[i] == k) &#123; cnt++; &#125; &#125; &#125; return cnt;&#125; 用sum表示从数组开始位置到当前位置的数字相加和，有了第523题的经验，我们还可以用Hash Table来存储sum出现的次数，如果当前位置之前有相加和为sum-k的位置，则这两个位置之间的数字相加和为k，以当前位置结尾的相加和为k的子数组个数为hash[sum-k]，这样遍历整个数组即可得出满足条件的子数组个数。具体代码： 12345678910111213141516class Solution &#123; public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, cnt = 0; unordered_map&lt;int, int&gt; hash; hash[0] = 1; for(auto n:nums) &#123; sum += n; cnt += hash[sum-k]; ++hash[sum]; &#125; return cnt; &#125; &#125;; 611. Valid Triangle Number## Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. Example 1: 1234567Input: [2,2,3,4]Output: 3Explanation:Valid combinations are: 2,3,4 (using the first 2)2,3,4 (using the second 2)2,2,3 Note: The length of the given array won’t exceed 1000. The integers in the given array are in the range of [0, 1000]. 解题思路这道题是让找能够组成三角形的三个数，如果出现重复的数字，把它们当作不同的数字对待，像例子中的2，2，3，4，第一个2与第二个2分别与3,4,组成三角形。可以用三个指针来遍历这个数组，分别是i,j,k开始的时候j=i+1，k=i+2，当nums[i]+nums[j]&gt;nums[k]时，开始计数，每一轮k都加1，并且res每次增加k-j，因为开始的时候对nums数组排序，则数组中的数字是递增的（不一定单调），那么nums[i]+nums[j]&gt;nums[k]时，必然有nums[i]+nums[j+1]&gt;nusm[k]，nums[i]+nums[j+2]&gt;nums[k]….直到j=k-1，所以res增加k-j，最后返回结果即可，时间复杂度为O（n*n)。 12345678910111213141516171819202122232425262728293031323334/** * */package com.leetcode.coding;import java.util.Arrays;/** * @author zolanunu * */public class ValidTrangleNumber &#123; public int triangleNumber(int[] nums) &#123; Arrays.sort(nums); int size = nums.length; int ans = 0; for (int i = 0; i &lt; size - 2; i++) &#123; for (int j = i + 1; j &lt; size - 1; j++) &#123; int k = binarySearch(nums, j + 1, nums[i] + nums[j]); ans += k - j - 1; &#125; &#125; return ans; &#125; public int binarySearch(int[] nums, int start, int target) &#123; int left = start, right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] &gt;= target) right = mid - 1; else left = mid + 1; &#125; return left; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"},{"name":"leetcode","slug":"leetcode","permalink":"http://zhangbuzola.cn/tags/leetcode/"}]},{"title":"java基础学习之多线程","slug":"javabase_thread","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2018/01/17/javabase_thread/","link":"","permalink":"http://zhangbuzola.cn/2018/01/17/javabase_thread/","excerpt":"","text":"多线程线程和进程一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。 开了一个QQ，开了一个进程；开了微信，开了一个进程。 单进程单线程：一个人在一个桌子上吃菜。 单进程多线程：多个人在同一个桌子上一起吃菜。 多进程单线程：多个人每个人在自己的桌子上吃菜 进程是CPU资源分配的最小单元，线程是CPU调度的最小单位。 参考了知乎上大神的讲解。首先先说明几点基础概念或者背景知识吧。发现自己看东西总是喜欢刨根问底，纠结于小细节。 电脑构成：CPU+RAM+显卡+光驱等外设 基础秒懂的：CPU运行速度很快，太快了，只有寄存器才能勉强和CPU的执行速度同步。RAM都不行。所以，要执行多个任务的时候，需要按照一定的优先级策略轮流执行任务。 执行代码过程：得到CPU时候，相关资源（GPS，显卡）必须到位，然后CPU执行。执行完毕或者分配给他的CPU执行时间用完，需要切换，切换之前需要做的最后一步工作是保存程序上下文（这个是下次被CPU调度执行的执行环境，所以需要保存起来）。 程序上下文：除了CPU以外所有构成这个程序的执行环境 前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。 进程：CPU加载上下文+CPU执行+CPU保存上下文 但是由于进程描述的颗粒度太大，每次有上下文的掉进调出，保存，但是一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际是分成a,b,c等多个小组合。 所以程序A的执行过程变成了： A得到CPU-&gt;加载A的上下文，执行a小段，执行b小段，执行c小段，保存A的上下文。 abc就是线程，共享A的上下文。 进程和线程都是一个时间段的描述，是CPU工作时间段的描述，只是颗粒大小不同。 多线程问题多线程有什么用 发挥多核CPU的优势 防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 便于建模 假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 创建线程的方式 继承Thread类 实现Runnable接口 1234567891011121314151617181920212223242526272829303132333435363738394041// 第一种方法public class ThreadDemo1() &#123; public static void main(String[] args) &#123; Demo d = new Demo(); d.start(); for(int i=0;i&lt;60;i++)&#123; System.out.println(Thread.currentThread().getName()+i); &#125;&#125;class Demo extends Thread&#123;public void run()&#123;for(int i=0;i&lt;60;i++)&#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125; &#125;&#125;// 第二种方法public class ThreadDemo2 &#123;public static void main(String[] args)&#123; Demo2 d =new Demo2(); Thread t = new Thread(d); t.start();for(int x=0;x&lt;60;x++)&#123; System.out.println(Thread.currentThread().getName()+x); &#125; &#125;&#125;class Demo2 implements Runnable&#123;public void run()&#123;for(int x=0;x&lt;60;x++)&#123; System.out.println(Thread.currentThread().getName()+x); &#125; &#125;&#125; 哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。 这2种方式都可以用来创建线程去执行子任务，具体选择哪一种方式要看自己的需求。直接继承Thread类的话，可能比实现Runnable接口看起来更加简洁，但是由于Java只允许单继承，所以如果自定义类需要继承其他类，则只能选择实现Runnable接口。 start和run方法调用了start方法，才会表现多线程的特性，不同线程的run方法里面的代码交替执行。如果只是run方法被调用，那么代码是同步执行的，必须等待一个线程的run方法里面的代码全部执行完毕之后，另一个线程才可以执行其run方法里面的代码。 Runnable和Callable接口Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 CyclicBarrier和CountDownLatch的区别两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： （1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行 （2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 （3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。 Volatile关键字理解Volatile关键字的重要前提是理解java内存模式。 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。 代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 线程安全如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 不安全原因问题原因:当多条语句在操作同一个线程共享数据的时候，一个线程对多条语句只执行了一部分，还没有完全执行完，另一个线程参与进来执行，导致共享数据的错误。 解决办法： 对多条操作共享数据的语句，只能让一个线程都执行完，执行过程中，其他线程不能执行。 安全级别 不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet 相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类。 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类。 线程运行异常异常如果没有被捕获的话，线程会被停止执行。如果某个线程持有某个对象的监视器，这个监视器会被立即释放。 线程间共享数据？？生产者和消费者模型作用 平衡，提升整个系统的运行效率； 解耦，附带作用。意味着生产者和消费者之间的联系少，联系越少越可以独立发展而不需要收到相互的制约。 ThreadLocal有什么用简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的。 ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁。 怎么检测一个线程是否持有对象监视器我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。 synchronized和ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。 什么是多线程的上下文切换CPU控制权有一个已经正在执行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。 由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子：比如一个线程A正在读取一个文件的内容，正读到文件的一半，此时需要暂停线程A，转去执行线程B，当再次切换回来执行线程A的时候，我们不希望线程A又从文件的开头来读取。 因此需要记录线程A的运行状态，那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。 说简单点的：对于线程的上下文切换实际上就是: 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。 虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。 如果提交任务的时候，线程池队列已经满了，会发生什么如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。 java内存模型 Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 定义了几个原子操作，用于操作主内存和工作内存中的变量 定义了volatile变量的使用规则 happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的。 什么是CASCAS，全称为Compare and Set，即比较-设置。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。 什么是乐观锁和悲观锁 乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 单例模式的线程安全性老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： 饿汉式单例模式的写法：线程安全 懒汉式单例模式的写法：非线程安全 双检锁单例模式的写法：线程安全 线程状态在正式学习Thread类中的具体方法之前，我们先来了解一下线程有哪些状态，这个将会有助于后面对Thread类中的方法的理解。 创建（new）状态: 准备好了一个多线程的对象 就绪（runnable）状态: 调用了start()方法, 等待CPU进行调度 运行（running）状态: 执行run()方法 阻塞（blocked）状态: 暂时停止执行, 可能将资源交给其它线程使用 终止（dead）状态: 线程销毁 当需要新起一个线程来执行某个子任务时，就创建了一个线程。但是线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源，在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。 当线程进入就绪状态后，不代表立刻就能获取CPU执行时间，也许此时CPU正在执行其他的事情，因此它要等待。当得到CPU执行时间之后，线程便真正进入运行状态。 线程在运行状态过程中，可能有多个原因导致当前线程不继续运行下去，比如用户主动让线程睡眠（睡眠一定的时间之后再重新执行）、用户主动让线程等待，或者被同步块给阻塞，此时就对应着多个状态：time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、blocked（阻塞）。 当由于突然中断或者子任务执行完毕，线程就会被消亡。 下面这副图描述了线程从创建到消亡之间的状态： sleep和wait方法 sleep是Thread类的方法,wait是Object类中定义的方法. Thread.sleep不会导致锁行为的改变, 如果当前线程是拥有锁的, 那么Thread.sleep不会让线程释放锁. Thread.sleep和Object.wait都会暂停当前的线程. OS会将执行时间分配给其它线程. 区别是, 调用wait后, 需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间. sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，但是wait方法会放弃。 sleep方法注意事项调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。 终止线程 退出标志，使线程正常退出，run方法完成以后 使用stop方法强行终止（不推荐），因为可能会有无法预料的结果 使用interrupt方法中断线程 join方法在很多情况下，主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。方法join()的作用是等待线程对象销毁。 12345678910111213141516171819202122public class Thread4 extends Thread&#123; public Thread4(String name) &#123; super(name); &#125; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(getName() + &quot; &quot; + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 启动子进程 new Thread4(&quot;new thread&quot;).start(); for (int i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; Thread4 th = new Thread4(&quot;joined thread&quot;); th.start(); th.join(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125;&#125; 执行结果 1234567891011121314151617181920main 0main 1main 2main 3main 4new thread 0new thread 1new thread 2new thread 3new thread 4joined thread 0joined thread 1joined thread 2joined thread 3joined thread 4main 5main 6main 7main 8main 9 线程常用方法123456789101112131415public void start()public void run()public final void setName(String name)public final void setPriority(int priority)public final void setDaemon(boolean on) // 将该线程标记为守护线程或者用户线程public final void join(long millisec) // 等待该线程终止的时间最长是millisec毫秒public void interrupt()public final boolean isAlive()public static void yield()public static void sleep(long millisec)public static thread currentThread() 同步和死锁About more阅读《java多线程编程核心技术》 《java并发编程》","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"},{"name":"多线程","slug":"多线程","permalink":"http://zhangbuzola.cn/tags/多线程/"}]},{"title":"Moore Voting Algorithm","slug":"Boyer-Moore-Algorithm","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2018/01/01/Boyer-Moore-Algorithm/","link":"","permalink":"http://zhangbuzola.cn/2018/01/01/Boyer-Moore-Algorithm/","excerpt":"","text":"LeetCode有关于这个算法的求解，下面是针对这个算法给出的原理解释。方便理解。 问题描述给定一个无序数组，有n个元素，找出其中的一个多数元素，多数元素出现的次数大于⌊ n/2 ⌋，注意数组中也可能不存在多数元素。 一般解法 先对数组排序，然后取中间位置的元素，再对数据扫描一趟来判断此元素是否为多数元素。时间复杂度O(nlog(n))，空间复杂度O(1)。 使用一个hash表，对数组进行一趟扫描统计每个元素出现的次数，即可得到多数元素。时间复杂度O(n)，空间复杂度O(n)。 Moore Voting 算法算法步骤该算法时间复杂度为O(n)，空间复杂度为O(1)，只需要对原数组进行两趟扫描，并且简单易实现。第一趟扫描我们得到一个候选节点candidate，第二趟扫描我们判断candidate出现的次数是否大于⌊ n/2 ⌋。 第一趟扫描中，我们需要记录2个值： candidate，初值可以为任何数 count，初值为0 之后，对于数组中每一个元素，首先判断count是否为0，若为0，则把candidate设置为当前元素。之后判断candidate是否与当前元素相等，若相等则count+=1，否则count-=1。 算法原理为了解析算法的原理，我们只要考虑存在多数元素的情况即可，因为第二趟扫描可以检测出不存在多数元素的情况。 举个例子，我们的输入数组为[1,1,0,0,0,1,0]，那么0就是多数元素。首先，candidate被设置为第一个元素1，count也变成1，由于1不是多数元素，所以当扫描到数组某个位置时，count一定会减为0。在我们的例子中，当扫描到第四个位置时，count变成0. count 值变化过程： [1,2,1,0…… 当count变成0时，对于每一个出现的1，我们都用一个0与其进行抵消，所以我们消耗掉了与其一样多的0，而0是多数元素，这意味着当扫描到第四个位置时，我们已经最大程度的消耗掉了多数元素。然而，对于数组从第五个位置开始的剩余部分，0依然是其中的多数元素(注意，多数元素出现次数大于⌊ n/2 ⌋，而我们扫描过的部分中多数元素只占一般，那剩余部分中多数元素必然还是那个数字)。如果之前用于抵消的元素中存在非多数元素，那么数组剩余部分包含的多数元素就更多了。 类似的，假设第一个数字就是多数元素，那么当count减为0时，我们消耗掉了与多数元素一样多的非多数元素，那么同样道理，数组剩余部分中的多数元素数值不变。 这两种情况证明了关键的一点：数组中从candidate被赋值到count减到0的那一段可以被去除，余下部分的多数元素依然是原数组的多数元素。我们可以不断重复这个过程，直到扫描到数组尾部，那么count必然会大于0，而且这个count对应的candinate就是原数组的多数元素。 分布式Boyer-MooreBoyer-Moore还有一个优点，那就是可以使用并行算法实现。相关算法可见Finding the Majority Element in Parallel其基本思想为对原数组采用分治的方法，把数组划分成很多段(每段大小可以不相同)，在每段中计算出candidate-count二元组，然后得到最终结果。 举个例子，原数组为[1,1,0,1,1,0,1,0,0]划分1： [1,1,0,1,1] –&gt; (candidate,count)=(1,3) 划分2： [0,1,0,0] –&gt; (candidate,count)=(0,2) 根据(1,3)和(0,2)可得，原数组的多数元素为1. 正因为这个特性，考虑若要从一个非常大的数组中寻找多数元素，数据量可能多大数百G，那么我们甚至可以用MapReduce的方式来解决这个问题。 算法实践1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * */package com.leetcode.coding;import java.util.ArrayList;import java.util.List;/** * @author zolanunu * */public class MajorityElementII &#123; /** * n个元素的数组，找出出现次数超过[n/3]的数字。 * 要求线性时间和O(1)的空间复杂度 * 提示：一共有多少个众数 * Moore投票算法 * */ public List&lt;Integer&gt; majorityElement(int[] nums) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(nums.length == 0 || nums == null) &#123; return list; &#125; if(nums.length == 1) &#123; list.add(nums[0]); return list; &#125; int candidate1 = nums[0], candidate2 = 0, count1 = 1, count2 = 0; for(int i = 0; i &lt; nums.length; i++) &#123; if(candidate1 == nums[i]) &#123; count1 = count1 + 1; &#125; else if(candidate2 == nums[i]) &#123; count2 = count2 + 1; &#125; else if(count1 == 0) &#123; candidate1 = nums[i]; count1 = 1; &#125; else if(count2 == 0) &#123; candidate2 = nums[i]; count2 = 1; &#125; else &#123; count1 = count1 - 1; count2 = count2 - 1; &#125; &#125; count1 = 0; count2 = 0; for(int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] == candidate1) &#123; count1++; &#125; else if(candidate2 == nums[i]) &#123; count2++; &#125; &#125; if(count1 &gt; nums.length / 3) &#123; list.add(candidate1); &#125; if(count2 &gt; nums.length / 3) &#123; list.add(candidate2); &#125; return list; &#125; public static void main(String[] args) &#123; &#125;&#125; 参考http://blog.csdn.net/kimixuchen/article/details/52787307","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://zhangbuzola.cn/tags/算法与数据结构/"}]},{"title":"MySQL之join关键字","slug":"mysql_join","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2017/12/29/mysql_join/","link":"","permalink":"http://zhangbuzola.cn/2017/12/29/mysql_join/","excerpt":"","text":"joinINNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 12345SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P = Orders.Id_PORDER BY Persons.LastName","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangbuzola.cn/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangbuzola.cn/tags/MySQL/"}]},{"title":"FP-growth算法","slug":"MLInaction_c12_FPgrowth","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2017/12/29/MLInaction_c12_FPgrowth/","link":"","permalink":"http://zhangbuzola.cn/2017/12/29/MLInaction_c12_FPgrowth/","excerpt":"","text":"使用FP-growth算法来高效发现频繁项集Fp-growth算法是基于Apriori构建的，但是采用了高级的数据结构减少扫描次数，大大加快了算法速度。FP-growth算法只需要对数据库进行两次扫描。apriori算法是每次找潜在的频繁项集都会扫描数据集判定模式是否频繁。因此FP-growth算法的速度要比apriori算法快。 FP-growth算法发现频繁项集的基本过程如下： 构建FP树 从FP树中挖掘频繁项集 FP-growth算法优缺点： 优点：一般要快于apriori 缺点：实现比较困难，在某些数据集上性能会下降 使用数据集类型： 离散型数据 FP树：用于编码数据集的有效方式FP（frequent Pattern） 与搜索树不同的是，一个元素项可以在一棵FP树种出现多次。FP树辉存储项集的出现频率，而每个项集会以路径的方式存储在数中。存在相似元素的集合会共享树的一部分。只有当集合之间完全不同时，树才会分叉。 树节点上给出集合中的单个元素及其在序列中的出现次数，路径会给出该序列的出现次数。 FP-growth算法的工作流程如下。首先构建FP树，然后利用它来挖掘频繁项集。为构建FP树，需要对原始数据集扫描两遍。第一遍对所有元素项的出现次数进行计数。数据库的第一遍扫描用来统计出现的频率，而第二遍扫描中只考虑那些频繁元素。 下面是对应的数据样本和对应的FP-树 对应的FP树是：下面具体解释这个树的构建 样本元素项z出现了5次，集合{r, z}出现了1次。于是可以得出结论：z一定是自己本身或者和其他符号一起出现了4次。集合{t, s, y, x, z}出现了2次，集合{t, r, y, x, z}出现了1次，z本身单独出现1次。就像这样，FP树的解读方式是读取某个节点开始到根节点的路径。路径上的元素构成一个频繁项集，开始节点的值表示这个项集的支持度。根据图5，我们可以快速读出项集{z}的支持度为5、项集{t, s, y, x, z}的支持度为2、项集{r, y, x, z}的支持度为1、项集{r, s, x}的支持度为1。FP树中会多次出现相同的元素项，也是因为同一个元素项会存在于多条路径，构成多个频繁项集。但是频繁项集的共享路径是会合并的，如图中的{t, s, y, x, z}和{t, r, y, x, z} 和之前一样，我们取一个最小阈值，出现次数低于最小阈值的元素项将被直接忽略。本例子中将最小支持度设为3，所以q和p没有在FP中出现。 构建FP树FP的数据结构123456789101112131415class treeNode: def __init__(self, namevalue, numOccur, parentNode): self.name = namevalue self.count = numOccur self.nodeLink = None # 用来链接相似的元素项 self.parent = parentNode self.children = &#123;&#125; # 存放节点的子节点 def inc(self, numOccur):# count变量变化 self.count += numOccur def disp(self, ind = 1):# 将树以文本行为表现出来 print (&apos; &apos; * ind), self.name, &apos; &apos;, self.count for child in self.children.values(): child.disp(ind+1) 每个树节点由五个数据项组成： name：节点元素名称，在构造时初始化为给定值 count：出现次数，在构造时初始化为给定值 nodeLink：指向下一个相似节点的指针，默认为None parent：指向父节点的指针，在构造时初始化为给定值 children：指向子节点的字典，以子节点的元素名称为键，指向子节点的指针为值，初始化为空字典 成员函数： inc()：增加节点的出现次数值 disp()：输出节点和子节点的FP树结构 构建FP树构建FP树分为三个部分来进行。第一是头指针，第二是元素项排序，最后是构建FP树。 头指针结构FP-growth算法还需要一个称为头指针表的数据结构，其实很简单，就是用来记录各个元素项的总出现次数的数组，再附带一个指针指向FP树中该元素项的第一个节点。这样每个元素项都构成一条单链表。图示说明： 这里使用Python字典作为数据结构，来保存头指针表。以元素项名称为键，保存出现的总次数和一个指向第一个相似元素项的指针。 第一次遍历数据集会获得每个元素项的出现频率，去掉不满足最小支持度的元素项，生成这个头指针表。 元素项排序上文提到过，FP树会合并相同的频繁项集（或相同的部分）。因此为判断两个项集的相似程度需要对项集中的元素进行排序（不过原因也不仅如此，还有其它好处）。排序基于元素项的绝对出现频率（总的出现次数）来进行。在第二次遍历数据集时，会读入每个项集（读取），去掉不满足最小支持度的元素项（过滤），然后对元素进行排序（重排序）。 对示例数据集进行过滤和重排序的结果如下： FP树构建从空集开始，将过滤和重排序后的频繁项集一次添加到树中。如果树中已存在现有元素，则增加现有元素的值；如果现有元素不存在，则向树添加一个分支。对前两条事务进行添加的过程： 算法：构建FP树 1234567891011输入：数据集、最小值尺度输出：FP树、头指针表 遍历数据集，统计各元素项出现次数，创建头指针表 移除头指针表中不满足最小值尺度的元素项 第二次遍历数据集，创建FP树。对每个数据集中的项集： 初始化空FP树 对每个项集进行过滤和重排序 使用这个项集更新FP树，从FP树的根节点开始： 如果当前项集的第一个元素项存在于FP树当前节点的子节点中，则更新这个子节点的计数值 否则，创建新的子节点，更新头指针表 对当前项集的其余元素项和当前元素项的对应子节点递归3.3的过程 总函数：createTree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def createTree(dataSet, minSup=1): &apos;&apos;&apos; 创建FP树 &apos;&apos;&apos; # 第一次遍历数据集，创建头指针表 headerTable = &#123;&#125; for trans in dataSet: for item in trans: headerTable[item] = headerTable.get(item, 0) + dataSet[trans] # 移除不满足最小支持度的元素项 for k in headerTable.keys(): if headerTable[k] &lt; minSup: del(headerTable[k]) # 空元素集，返回空 freqItemSet = set(headerTable.keys()) if len(freqItemSet) == 0: return None, None # 增加一个数据项，用于存放指向相似元素项指针 for k in headerTable: headerTable[k] = [headerTable[k], None] retTree = treeNode(&apos;Null Set&apos;, 1, None) # 根节点 # 第二次遍历数据集，创建FP树 for tranSet, count in dataSet.items(): localD = &#123;&#125; # 对一个项集tranSet，记录其中每个元素项的全局频率，用于排序 for item in tranSet: if item in freqItemSet: # 注意这个[0]，因为之前加过一个数据项 localD[item] = headerTable[item][0] # 排序 if len(localD) &gt; 0: orderedItems = [v[0] for v in sorted(localD.items(), key=lambda p: p[1], reverse=True)] updateTree(orderedItems, retTree, headerTable, count) # 更新FP树 return retTree, headerTabledef updateTree(items, inTree, headerTable, count): if items[0] in inTree.children: # 有该元素项时计数值+1 inTree.children[items[0]].inc(count) else: # 没有这个元素项时创建一个新节点 inTree.children[items[0]] = treeNode(items[0], count, inTree) # 更新头指针表或前一个相似元素项节点的指针指向新节点 if headerTable[items[0]][1] == None: headerTable[items[0]][1] = inTree.children[items[0]] else: updateHeader(headerTable[items[0]][1], inTree.children[items[0]]) if len(items) &gt; 1: # 对剩下的元素项迭代调用updateTree函数 updateTree(items[1::], inTree.children[items[0]], headerTable, count)def updateHeader(nodeToTest, targetNode): while (nodeToTest.nodeLink != None): nodeToTest = nodeToTest.nodeLink nodeToTest.nodeLink = targetNode FP树挖掘频繁项集到现在为止大部分比较困难的工作已经处理完了。有了FP树之后，就可以抽取频繁项集了。这里的思路与Apriori算法大致类似，首先从单元素项集合开始，然后在此基础上逐步构建更大的集合。 从FP树中抽取频繁项集的三个基本步骤如下： 从FP树中获得条件模式基 conditional pattern base； 利用条件模式基，构建一个条件FP树； 迭代重复步骤1步骤2，直到树包含一个元素项为止。 Conditional pattern base首先从头指针表中的每个频繁元素项开始，对每个元素项，获得其对应的条件模式基（conditional pattern base）。条件模式基是以所查找元素项为结尾的路径集合。每一条路径其实都是一条前缀路径（prefix path）。简而言之，一条前缀路径是介于所查找元素项与树根节点之间的所有内容。 发现规律了吗，z存在于路径{z}中，因此前缀路径为空，另添加一项该路径中z节点的计数值5构成其条件模式基；r存在于路径{r, z}、{r, y, x, z}、{r, s, x}中，分别获得前缀路径{z}、{y, x, z}、{s, x}，另添加对应路径中r节点的计数值（均为1）构成r的条件模式基；以此类推。 前缀路径将在下一步中用于构建条件FP树，暂时先不考虑。如何发现某个频繁元素项的所在的路径？利用先前创建的头指针表和FP树中的相似元素节点指针，我们已经有了每个元素对应的单链表，因而可以直接获取。 12345678910111213141516171819202122def findPrefixPath(basePat, treeNode): &apos;&apos;&apos; 创建前缀路径 &apos;&apos;&apos; condPats = &#123;&#125; while treeNode != None: prefixPath = [] ascendTree(treeNode, prefixPath) if len(prefixPath) &gt; 1: condPats[frozenset(prefixPath[1:])] = treeNode.count treeNode = treeNode.nodeLink return condPats&apos;&apos;&apos;修改prefixPath的值，将当前节点leafNode添加到prefixPath的末尾，然后递归添加其父节点。最终结果，prefixPath就是一条从treeNode（包括treeNode）到根节点（不包括根节点）的路径。在主函数findPrefixPath()中再取prefixPath[1:]，即为treeNode的前缀路径。&apos;&apos;&apos;def ascendTree(leafNode, prefixPath): if leafNode.parent != None: prefixPath.append(leafNode.name) ascendTree(leafNode.parent, prefixPath) 创建一棵条件FP树的过程如下图： 递归查找频繁项集有了FP树和条件FP树，我们就可以在前两步的基础上递归得查找频繁项集。 递归的过程是这样的： 123456789输入：我们有当前数据集的FP树（inTree，headerTable） 初始化一个空列表preFix表示前缀 初始化一个空列表freqItemList接收生成的频繁项集（作为输出） 对headerTable中的每个元素basePat（按计数值由小到大），递归： 记basePat + preFix为当前频繁项集newFreqSet 将newFreqSet添加到freqItemList中 计算t的条件FP树（myCondTree、myHead） 当条件FP树不为空时，继续下一步；否则退出递归 以myCondTree、myHead为新的输入，以newFreqSet为新的preFix，外加freqItemList，递归这个过程 输入参数： inTree和headerTable是由createTree()函数生成的数据集的FP树 minSup: 最小支持度 preFix: 初始传入一个空集合（set([])），用于保存当前前缀 freqItemList：初始传入一个空列表（[]），用来储存生成的频繁项集 ‘’’def mineTree(inTree, headerTable, minSup, preFix, freqItemList): bigL = [v[0] for v in sorted(headerTable.items(), key=lambda p: p[1])] for basePat in bigL: newFreqSet = preFix.copy() newFreqSet.add(basePat) freqItemList.append(newFreqSet) condPattBases = findPrefixPath(basePat, headerTable[basePat][1]) myCondTree, myHead = createTree(condPattBases, minSup) if myHead != None: # 用于测试 print &apos;conditional tree for:&apos;, newFreqSet myCondTree.disp() mineTree(myCondTree, myHead, minSup, newFreqSet, freqItemList) 12测试代码： freqItems = []fpGrowth.mineTree(myFPtree, myHeaderTab, 3, set([]), freqItems)freqItems[set([‘y’]), set([‘y’, ‘x’]), set([‘y’, ‘z’]), set([‘y’,\\ ‘x’, ‘z’]), set([‘s’]), set([‘x’, ‘s’]), set([‘t’]),\\ set([‘z’, ‘t’]), set([‘x’, ‘z’, ‘t’]), set([‘y’, ‘x’, ‘z’,\\ ‘t’]), set([‘y’, ‘z’, ‘t’]), set([‘x’, ‘t’]), set([‘y’,\\ ‘x’, ‘t’]), set([‘y’, ‘t’]), set([‘r’]), set([‘x’]), set([‘x’, ‘z’]), set([‘z’])]` 下面举例解释上面的递归代码，清楚易懂。我们在这里分解输入myFPtree和myHeaderTab后，“for basePat in bigL:”一行当basePat为’t’时的过程： 总结FP-growth算法是一种用于发现数据集中频繁模式的有效方法。FP-growth算法利用Apriori原则，执行更快。Apriori算法产生候选项集，然后扫描数据集来检查它们是否频繁。由于只对数据集扫描两次，因此FP-growth算法执行更快。在FP-growth算法中，数据集存储在一个称为FP树的结构中。FP树构建完成后，可以通过查找元素项的条件基及构建条件FP树来发现频繁项集。该过程不断以更多元素作为条件重复进行，直到FP树只包含一个元素为止。 FP-growth算法还有一个map-reduce版本的实现，它也很不错，可以扩展到多台机器上运行。Google使用该算法通过遍历大量文本来发现频繁共现词，其做法和我们刚才介绍的例子非常类似（参见扩展阅读：FP-growth算法）。 思维导图 参考http://www.cnblogs.com/qwertWZ/p/4510857.html#_label3","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"},{"name":"机器学习","slug":"机器学习","permalink":"http://zhangbuzola.cn/tags/机器学习/"}]},{"title":"Apriori算法","slug":"MLInaction_c11_apriori","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/12/28/MLInaction_c11_apriori/","link":"","permalink":"http://zhangbuzola.cn/2017/12/28/MLInaction_c11_apriori/","excerpt":"","text":"使用Apriori算法进行关联分析问题是寻找物品之间的不同组合很耗时，计算代价高，野蛮手段都不一定能解决这个问题。所以提出一些更加智能的算法在合理的时间范围内找到频繁项集。 关联分析关联分析：从大规模数据集中寻找物品减的隐含关系，可以用在超市商品捆绑销售上。 这些隐含关系有两种形式： 频繁项集或者关联规则 关联规则：物品之间可能存在很强的关系 {}-&gt;{}； {啤酒}-&gt;{尿布} ： 可以表示说在超市买了啤酒的人可能会买尿布 频繁项集：经常出现在一起的物品集合 如何度量这些关系：一个项集的支持度（定义数据集中包含的记录所占的比例）。可信度或者置信度:是对于关联规则 Apriori原理假设某家超市只卖四样商品：0,1,2,3。 Apriori原理是说如果某个项集是频繁的，那么他的子项集也是频繁的，那么逆否命题也是成立的，也就是说：一个项集非频繁，那么他的所有超项集是非频繁的。 Apriori 找频繁集关联分析的目标包括两项：发现频繁项集和发现关联规则。首先需要找到频繁项集，然后才能获得关联规则。 Apriori是发现频繁项集的算法之一。该算法的输入参数是：最小支持度和置信度。 该算法首先会生成所有单个元素的项集列表。接着扫描所有的数据集来查看满足最小支持度的项集。把那些不符合最小支持度的项集去掉。 生成候选项集数据集扫描的伪代码 1234567对数据集中的每条交易记录tran： 对每个候选项集can： 检查can是否是tran的子集 如果是，则增加can的计数对每个候选项集： 如果其支持度不低于最小值，则保留该项集返回所有频繁项集列表 Apriori算法辅助函数部分 1234567891011121314151617181920212223242526272829303132from numpy import *def loadDataSet(): return [[1, 3, 4], [2, 3, 5], [1, 2, 3, 5], [2, 5]]def createC1(dataSet): C1 = [] for transaction in dataSet: for item in transaction: if not [item] in C1: C1.append([item]) C1.sort() return map(frozenset, C1)#use frozen set so we #can use it as a key in a dict def scanD(D, Ck, minSupport): ssCnt = &#123;&#125; for tid in D: for can in Ck: if can.issubset(tid): if not ssCnt.has_key(can): ssCnt[can]=1 else: ssCnt[can] += 1 numItems = float(len(D)) retList = [] supportData = &#123;&#125; for key in ssCnt: support = ssCnt[key]/numItems if support &gt;= minSupport: retList.insert(0,key) supportData[key] = support return retList, supportData Apriori算法 整个apriori算法的伪代码是： 1234当集合中项的个数大于0的时候： 构建一个k个项组成的候选项集的列表 检查数据保证每个项集都是频繁的 保留频繁项集并构建k+1项组成的候选项集的列表 图示意： 下面是代码部分： 123456789101112131415161718192021222324def aprioriGen(Lk, k): #creates Ck retList = [] lenLk = len(Lk) for i in range(lenLk): for j in range(i+1, lenLk): L1 = list(Lk[i])[:k-2]; L2 = list(Lk[j])[:k-2] L1.sort(); L2.sort() if L1==L2: #if first k-2 elements are equal retList.append(Lk[i] | Lk[j]) #set union return retListdef apriori(dataSet, minSupport = 0.5): C1 = createC1(dataSet) D = map(set, dataSet) L1, supportData = scanD(D, C1, minSupport) L = [L1] k = 2 while (len(L[k-2]) &gt; 0): Ck = aprioriGen(L[k-2], k) Lk, supK = scanD(D, Ck, minSupport)#scan DB to get Lk supportData.update(supK) L.append(Lk) k += 1 return L, supportData aprioriGen函数是通过列表Lk和项集个数k生成候选项集Ck+1. 生成过程：首先对每个项集按元素进行排序，然后比较两个项集，只有在前k-1项相同的才将这两个合并。如此是因为函数并非是要两两合并各个集合，这样的话，生成的集合个数就不是k+1项的了。在限制了项数的前提下，只有在前k-1项相同的情况下才能进行合并，产生新的候选集合。 apriori函数中Ck表示项数为k的候选项集，最初的C1通过createC1()函数生成。Lk表示项数为k的频繁项集，supK为其支持度，Lk和supK由scanD()函数通过Ck计算而来。 频繁项集推关联规则要找到一个关联规则需要从频繁项集开始，比如说一个频繁项集：{豆奶，莴苣}，可能就会有这样一条频繁规则：”豆奶 -&gt; 莴苣”。也就是说买了豆奶的人很大程度上会买莴苣。但是反过来并一定成立。可信度(“豆奶➞莴苣”)并不等于可信度(“莴苣➞豆奶”)。 下面图给出了从项集{0,1,2,3}产生的所有关联规则，其中阴影区域给出的是低可信度的规则。可以发现如果{0,1,2}➞{3}是一条低可信度规则，那么所有其他以3作为后件（箭头右部包含3）的规则均为低可信度的。 关联规则生成函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&apos;&apos;&apos;L: 频繁项集列表supportData： 包含哪些频繁项集支持数据的字典minconf： 最小可信度阈值&apos;&apos;&apos;def generateRules(L, supportData, minConf=0.7): # 频繁项集挖掘关联规则 bigRuleList = [] # 保存包含可信度的规则列表 for i in range(1, len(L)):# 只保留两个或者两个元素以上的集合 for freqSet in L[i]: # 遍历某个频繁项集的元素 H1 = [frozenset([item]) for item in freqSet] if (i &gt; 1): rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf) else: # 计算规则的可信度，并过滤出满足最小可信度要求的规则 calcConf(freqSet, H1, supportData, bigRuleList, minConf) return bigRuleList&apos;&apos;&apos;calConf: 计算规则的可信度，并筛选出满足最小可信度要求的规则freqSet: 频繁项集H: 候选规则集合supportData: 保存项集支持度brl: 保存生成的规则minConf: 最小置信度&apos;&apos;&apos;def calcConf(freqSet, H, supportData, brl, minConf=0.7): # 计算规则的可信度，并过滤出满足最小可信度要求的规则 prunedH = [] # 保存规则列表的右部 for conseq in H: conf = supportData[freqSet]/supportData[freqSet-conseq] if conf &gt;= minConf: print freqSet-conseq,&apos;--&gt;&apos;,conseq,&apos;conf:&apos;,conf brl.append((freqSet-conseq, conseq, conf)) prunedH.append(conseq) return prunedH&apos;&apos;&apos;根据当前的候选规则集合H生成下一层候选规则集freqSet: 频繁项集H: 候选规则集合supportData: 保存项集支持度brl: 保存生成的规则minConf: 最小置信度&apos;&apos;&apos;def rulesFromConseq(freqSet, H, supportData, brl, minConf=0.7): m = len(H[0]) if (len(freqSet) &gt; (m + 1)): Hmp1 = aprioriGen(H, m+1) Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf) if (len(Hmp1) &gt; 1): rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf) 一些问题运行代码然后仔细检查输出，有发现一些问题 发现问题频繁项集L的值前面提到过。我们在其中计算通过{2, 3, 5}生成的关联规则，可以发现关联规则{3, 5}➞{2}和{2, 3}➞{5}的可信度都应该为1.0的，因而也应该包括在当minConf = 0.7时的rules中——但是这在前面的运行结果中并没有体现出来。minConf = 0.5时也是一样，{3, 5}➞{2}的可信度为1.0，{2, 5}➞{3}的可信度为2/3，{2, 3}➞{5}的可信度为1.0，也没有体现在rules中。 通过分析程序代码，我们可以发现： 当i = 1时，generateRules()函数直接调用了calcConf()函数直接计算其可信度，因为这时L[1]中的频繁项集均包含两个元素，可以直接生成和判断候选关联规则。比如L[1]中的{2, 3}，生成的候选关联规则为{2}➞{3}、{3}➞{2}，这样就可以了。 当i &gt; 1时，generateRules()函数调用了rulesFromConseq()函数，这时L[i]中至少包含3个元素，如{2, 3, 5}，对候选关联规则的生成和判断的过程需要分层进行（图示意）。这里，将初始的H1（表示初始关联规则的右部，即箭头右边的部分）作为参数传递给了rulesFromConseq()函数。 例如，对于频繁项集{a, b, c, …}，H1的值为[a, b, c, …]（代码中实际为frozenset类型）。如果将H1带入计算可信度的calcConf()函数，在函数中会依次计算关联规则{b, c, d, …}➞{a}、{a, c, d, …}➞{b}、{a, b, d, …}➞{c}……的支持度，并保存支持度大于最小支持度的关联规则，并保存这些规则的右部（prunedH，即对H的过滤，删除支持度过小的关联规则）。 当i &gt; 1时没有直接调用calcConf()函数计算通过H1生成的规则集。在rulesFromConseq()函数中，首先获得当前H的元素数m = len(H[0])（记当前的H为HmHm）。当HmHm可以进一步合并为m+1元素数的集合Hm+1Hm+1时（判断条件：len(freqSet) &gt; (m + 1)），依次： 生成Hm+1Hm+1：Hmpl = aprioriGen(H, m + 1) 计算Hm+1Hm+1的可信度：Hmpl = calcConf(freqSet, Hmpl, …) 递归计算由Hm+1Hm+1生成的关联规则：rulesFromConseq(freqSet, Hmpl, …)所以这里的问题是，在i&gt;1时，rulesFromConseq()函数中并没有调用calcConf()函数计算H1的可信度，而是直接由H1生成H2，从H2开始计算关联规则——于是由元素数&gt;3的频繁项集生成的{a, b, c, …}➞{x}形式的关联规则（图4中的第2层）均缺失了。由于代码示例数据中的对H1的剪枝prunedH没有删除任何元素，结果只是“巧合”地缺失了一层。正常情况下如果没有对H1进行过滤，直接生成H2，将给下一层带入错误的结果（如图4中的012➞3会被错误得留下来）。 解决问题在i&gt;1时，将对H1调用calcConf()的过程加上就可以了。比如可以这样： 12345678910111213def generateRules2(L, supportData, minConf=0.7): bigRuleList = [] for i in range(1, len(L)): for freqSet in L[i]: H1 = [frozenset([item]) for item in freqSet] if (i &gt; 1): # 三个及以上元素的集合 H1 = calcConf(freqSet, H1, supportData, bigRuleList, minConf) rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf) else: # 两个元素的集合 calcConf(freqSet, H1, supportData, bigRuleList, minConf) return bigRuleList 这里就只需要修改generateRules()函数。这样实际运行效果中，刚才丢失的那几个关联规则就都出来了。 再修改进一步修改：当i=1时的else部分并没有独特的逻辑，这个if语句可以合并，然后再修改rulesFromConseq()函数，保证其会调用calcConf(freqSet, H1, …)： 123456789101112131415def generateRules3(L, supportData, minConf=0.7): bigRuleList = [] for i in range(1, len(L)): for freqSet in L[i]: H1 = [frozenset([item]) for item in freqSet] rulesFromConseq2(freqSet, H1, supportData, bigRuleList, minConf) return bigRuleList def rulesFromConseq2(freqSet, H, supportData, brl, minConf=0.7): m = len(H[0]) if (len(freqSet) &gt; m): # 判断长度改为 &gt; m，这时即可以求H的可信度 Hmpl = calcConf(freqSet, H, supportData, brl, minConf) if (len(Hmpl) &gt; 1): # 判断求完可信度后是否还有可信度大于阈值的项用来生成下一层H Hmpl = aprioriGen(Hmpl, m + 1) rulesFromConseq2(freqSet, Hmpl, supportData, brl, minConf) # 递归计算，不变 运行结果和generateRules2相同。 进一步修改：消除rulesFromConseq2()函数中的递归项。这个递归纯粹是偷懒的结果，没有简化任何逻辑和增加任何可读性，可以直接用一个循环代替： 123456789def rulesFromConseq3(freqSet, H, supportData, brl, minConf=0.7): m = len(H[0]) while (len(freqSet) &gt; m): # 判断长度 &gt; m，这时即可求H的可信度 H = calcConf(freqSet, H, supportData, brl, minConf) if (len(H) &gt; 1): # 判断求完可信度后是否还有可信度大于阈值的项用来生成下一层H H = aprioriGen(H, m + 1) m += 1 else: # 不能继续生成下一层候选关联规则，提前退出循环 break 另一个主要的区别是去掉了多余的Hmpl变量。运行的结果和generateRules2相同。 至此，一个完整的Apriori算法就完成了。 实战发现美国国会投票中的模式 数据集有： recent100bills.txt 100条议案标题以及id recent20biils.txt 将上文本文件的billId转为actionId，并非所有的议案都被投票过，另外一些议案再多处进行了议案投票。需要对actionId进行过滤只保留投票数据的actionId。处理以后得到此文件。 收集美国国会议案中的actionId的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from time import sleepfrom votesmart import votesmartvotesmart.apikey = &apos;get your api key first&apos;def getActionIds(): # 保存actionId和标题 actionIdList = []; billTitleList = [] fr = open(&apos;recent20bills.txt&apos;) for line in fr.readlines(): billNum = int(line.split(&apos;\\t&apos;)[0]) try: billDetail = votesmart.votes.getBill(billNum) # 获得billDetail的对象 # 遍历议案中的所有行为，寻找有投票行为的数据 for action in billDetail.actions: if action.level == &apos;House&apos; and \\ (action.stage == &apos;Passage&apos; or action.stage == &apos;Amendment Vote&apos;): actionId = (int)(action.actionId) print(&apos;bill: %d has actionId: %d&apos; %(billNum, actionId)) actionIdList.append(actionId) billTitleList.append(line.strip().split(&apos;\\t&apos;)[1]) except: print(&apos;problem getting bill %d&apos; % billNum) sleep(1) return actionIdList, billTitleList&apos;&apos;&apos;基于投票数据的事务列表填充函数创建事务数据库&apos;&apos;&apos;def getTransList(actionIdList, billTitleList): itemMeaning = [&apos;Republican&apos;, &apos;Democratic&apos;] for billTitle in billTitleList: itemMeaning.append(&apos;%s -- Nay&apos; % billTitle) itemMeaning.append(&apos;%s -- Yea&apos; % billTitle) transDict = &#123;&#125; voteCount = 2 for actionId in actionIdList: sleep(3) print &apos;getting votes for actionId: %d&apos; % actionId try: voteList = votesmart.votes.getBillActionVotes(actionId) for vote in voteList: if not transDict.has_key(vote.candidateName): transDict[vote.candidateName] = [] if vote.officeParties == &apos;Democratic&apos;: transDict[vote.candidateName].append(1) elif vote.officeParties == &apos;Republican&apos;: transDict[vote.candidateName].append(0) if vote.action == &apos;Nay&apos;: transDict[vote.candidateName].append(voteCount) elif vote.action == &apos;Yea&apos;: transDict[vote.candidateName].append(voteCount + 1) except: print &quot;problem getting actionId: %d&quot; % actionId voteCount += 2 return transDict, itemMeaning 总结关联分析是用于发现大数据集中元素间有趣关系的一个工具集，可以采用两种方式来量化这些有趣的关系。第一种方式是使用频繁项集，它会给出经常在一起出现的元素项。第二种方式是关联规则，每条关联规则意味着元素项之间的“如果……那么”关系。 发现元素项间不同的组合是个十分耗时的任务，不可避免需要大量昂贵的计算资源，这就需要一些更智能的方法在合理的时间范围内找到频繁项集。能够实现这一目标的一个方法是Apriori算法，它使用Apriori原理来减少在数据库上进行检查的集合的数目。Apriori原理是说如果一个元素项是不频繁的，那么那些包含该元素的超集也是不频繁的。Apriori算法从单元素项集开始，通过组合满足最小支持度要求的项集来形成更大的集合。支持度用来度量一个集合在原始数据中出现的频率。 关联分析可以用在许多不同物品上。商店中的商品以及网站的访问页面是其中比较常见的例子。 每次增加频繁项集的大小，Apriori算法都会重新扫描整个数据集。当数据集很大时，这会显著降低频繁项集发现的速度。下面会介绍FP-growth算法，和Apriori算法相比，该算法只需要对数据库进行两次遍历，能够显著加快发现频繁项集的速度。 再接一张思维导图，帮助回忆 参考http://www.cnblogs.com/qwertWZ/p/4510857.html","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"},{"name":"机器学习","slug":"机器学习","permalink":"http://zhangbuzola.cn/tags/机器学习/"}]},{"title":"K-means","slug":"MLInaction_c10_kmeans","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/12/28/MLInaction_c10_kmeans/","link":"","permalink":"http://zhangbuzola.cn/2017/12/28/MLInaction_c10_kmeans/","excerpt":"","text":"利用K-均值聚类算法对未标注数据分组聚类什么是聚类算法呢，相比于分类算法，很明了了。聚类算法是无监督的，也就是样本都没有任何标签，而分类对象的标签已经。将相似的对象聚成簇。簇内的对象越相似，聚类效果就越好。 下面介绍K-均值聚类的算法。K-均值：是将n个样本聚类到k个簇中，每个簇的中心采用簇中所含的均值计算得到的。 K-均值聚类算法优点： 容易实现 缺点：可能收敛到局部最小值，在大规模数据集上收敛较慢。 伪代码1234567创建k个点作为起始质心（经常是随机选择）当任意一个点的簇分配结果发生改变时： 对数据集中的每个数据点 对每个质心 计算质心与数据点之间的距离 将数据点分配到距其最近的簇 对每个簇，计算簇中所有点的均值，并将其作为簇的质心。（更新质心） 复杂度：时间复杂度：O（mnkd），其中 m是样本的个数，n为维数，k是迭代的次数，d为聚类中心的个数。空间复杂度：O（mn） python实践12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&apos;&apos;&apos;k Means Clustering for Ch10 of Machine Learning in Action&apos;&apos;&apos;from numpy import *def loadDataSet(fileName): # general function to parse tab delimited floats dataMat = [] # assume last column is target value fr = open(fileName) for line in fr.readlines(): curLine = line.strip().split(&apos;\\t&apos;) fltLine = map(float,curLine) # map all elements to float() dataMat.append(fltLine) return dataMatdef distEclud(vecA, vecB): return sqrt(sum(power(vecA - vecB, 2))) # la.norm(vecA-vecB)def randCent(dataSet, k): # 在给定的数据集上构建一个包含k个随机质心的集合 n = shape(dataSet)[1] centroids = mat(zeros((k,n)))# create centroid mat for j in range(n): # create random cluster centers, within bounds of each dimension minJ = min(dataSet[:,j]) rangeJ = float(max(dataSet[:,j]) - minJ) centroids[:,j] = mat(minJ + rangeJ * random.rand(k,1)) return centroids def kMeans(dataSet, k, distMeas=distEclud, createCent=randCent): m = shape(dataSet)[0] clusterAssment = mat(zeros((m,2)))# create mat to assign data points # to a centroid, also holds SE of each point # 用于存放该样本属于哪类及质心距离 centroids = createCent(dataSet, k) clusterChanged = True while clusterChanged: clusterChanged = False for i in range(m):#for each data point assign it to the closest centroid minDist = inf; minIndex = -1 for j in range(k): distJI = distMeas(centroids[j,:],dataSet[i,:]) if distJI &lt; minDist: minDist = distJI; minIndex = j if clusterAssment[i,0] != minIndex: clusterChanged = True clusterAssment[i,:] = minIndex,minDist**2 print centroids for cent in range(k):# recalculate centroids ptsInClust = dataSet[nonzero(clusterAssment[:,0].A==cent)[0]]# get all the point in this cluster centroids[cent,:] = mean(ptsInClust, axis=0) # assign centroid to mean return centroids, clusterAssment 二分K-均值算法二分K-均值是为了解决简答的K-均值算法收敛于局部最小的问题。 算法思想：一开始将所有样本点作为一个簇，然后将该簇一分为二。然后选择其一进行划分，选择哪一个簇的原则是：对其划分可以最大程度降低SSE的值。 伪代码1234567将所有点看成一个簇当簇数目小于k的时候： 对于每一个簇： 计算总误差 在给定的簇上面进行K-均值聚类k=2 计算该簇一分为二之后的总误差 选择一个总误差最小的簇继续划分 问题：如何进行二分呢？随机？ 1234567891011121314151617181920212223242526272829303132def biKmeans(dataSet, k, distMeas=distEclud): m = shape(dataSet)[0] clusterAssment = mat(zeros((m,2))) centroid0 = mean(dataSet, axis=0).tolist()[0] # 创建一个初始的簇 centList =[centroid0] #create a list with one centroid for j in range(m):#calc initial Error clusterAssment[j,1] = distMeas(mat(centroid0), dataSet[j,:])**2 while (len(centList) &lt; k): lowestSSE = inf for i in range(len(centList)): ptsInCurrCluster = dataSet[nonzero(clusterAssment[:,0].A==i)[0],:] # get the data points currently in cluster i centroidMat, splitClustAss = kMeans(ptsInCurrCluster, 2, distMeas) sseSplit = sum(splitClustAss[:,1]) # compare the SSE to the currrent minimum sseNotSplit = sum(clusterAssment[nonzero(clusterAssment[:,0].A!=i)[0],1]) print &quot;sseSplit, and notSplit: &quot;,sseSplit,sseNotSplit if (sseSplit + sseNotSplit) &lt; lowestSSE: bestCentToSplit = i bestNewCents = centroidMat bestClustAss = splitClustAss.copy() lowestSSE = sseSplit + sseNotSplit bestClustAss[nonzero(bestClustAss[:,0].A == 1)[0],0] = len(centList) # change 1 to 3,4, or whatever bestClustAss[nonzero(bestClustAss[:,0].A == 0)[0],0] = bestCentToSplit print &apos;the bestCentToSplit is: &apos;,bestCentToSplit print &apos;the len of bestClustAss is: &apos;, len(bestClustAss) centList[bestCentToSplit] = bestNewCents[0,:].tolist()[0] # replace a centroid with two best centroids centList.append(bestNewCents[1,:].tolist()[0]) clusterAssment[nonzero(clusterAssment[:,0].A == bestCentToSplit)[0],:]= bestClustAss#reassign new clusters, and SSE return mat(centList), clusterAssment 实战对地图上的点进行聚类 书中假设的情况是：Drew要进城参加朋友的生日，其他人也会过去，所以提供一个方案，参加生日的人都给出一个想去的地方，然后这些地址组成一个列表，有70个位置。保存在portland_Clubs.txt。将这些地址进行聚类，然后来安排行程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import urllibimport jsondef geoGrab(stAddress, city): apiStem = &apos;http://where.yahooapis.com/geocode?&apos; #create a dict and constants for the goecoder params = &#123;&#125; params[&apos;flags&apos;] = &apos;J&apos;#JSON return type params[&apos;appid&apos;] = &apos;aaa0VN6k&apos; params[&apos;location&apos;] = &apos;%s %s&apos; % (stAddress, city) url_params = urllib.urlencode(params) yahooApi = apiStem + url_params #print url_params print yahooApi c=urllib.urlopen(yahooApi) return json.loads(c.read())from time import sleepdef massPlaceFind(fileName): fw = open(&apos;places.txt&apos;, &apos;w&apos;) for line in open(fileName).readlines(): line = line.strip() lineArr = line.split(&apos;\\t&apos;) retDict = geoGrab(lineArr[1], lineArr[2]) if retDict[&apos;ResultSet&apos;][&apos;Error&apos;] == 0: lat = float(retDict[&apos;ResultSet&apos;][&apos;Results&apos;][0][&apos;latitude&apos;]) lng = float(retDict[&apos;ResultSet&apos;][&apos;Results&apos;][0][&apos;longitude&apos;]) print &quot;%s\\t%f\\t%f&quot; % (lineArr[0], lat, lng) fw.write(&apos;%s\\t%f\\t%f\\n&apos; % (line, lat, lng)) else: print &quot;error fetching&quot; sleep(1) fw.close() def distSLC(vecA, vecB):#Spherical Law of Cosines a = sin(vecA[0,1]*pi/180) * sin(vecB[0,1]*pi/180) b = cos(vecA[0,1]*pi/180) * cos(vecB[0,1]*pi/180) * \\ cos(pi * (vecB[0,0]-vecA[0,0]) /180) return arccos(a + b)*6371.0 #pi is imported with numpyimport matplotlibimport matplotlib.pyplot as pltdef clusterClubs(numClust=5): datList = [] for line in open(&apos;places.txt&apos;).readlines(): lineArr = line.split(&apos;\\t&apos;) datList.append([float(lineArr[4]), float(lineArr[3])]) datMat = mat(datList) myCentroids, clustAssing = biKmeans(datMat, numClust, distMeas=distSLC) fig = plt.figure() rect=[0.1,0.1,0.8,0.8] scatterMarkers=[&apos;s&apos;, &apos;o&apos;, &apos;^&apos;, &apos;8&apos;, &apos;p&apos;, \\ &apos;d&apos;, &apos;v&apos;, &apos;h&apos;, &apos;&gt;&apos;, &apos;&lt;&apos;] axprops = dict(xticks=[], yticks=[]) ax0=fig.add_axes(rect, label=&apos;ax0&apos;, **axprops) imgP = plt.imread(&apos;Portland.png&apos;) ax0.imshow(imgP) ax1=fig.add_axes(rect, label=&apos;ax1&apos;, frameon=False) for i in range(numClust): ptsInCurrCluster = datMat[nonzero(clustAssing[:,0].A==i)[0],:] markerStyle = scatterMarkers[i % len(scatterMarkers)] ax1.scatter(ptsInCurrCluster[:,0].flatten().A[0],\\ ptsInCurrCluster[:,1].flatten().A[0], marker=markerStyle, s=90) ax1.scatter(myCentroids[:,0].flatten().A[0], \\ myCentroids[:,1].flatten().A[0], marker=&apos;+&apos;, s=300) plt.show() 总结聚类是一个无监督的算法，无监督是事先不知道要寻找的内容，也就是没有目标变量。聚类将数据点归到多个簇中。 下面是一个k-means的思维导图，来帮助回忆吧。","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"},{"name":"机器学习","slug":"机器学习","permalink":"http://zhangbuzola.cn/tags/机器学习/"}]},{"title":"java基础学习之finalize","slug":"java基础之finalize","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/12/27/java基础之finalize/","link":"","permalink":"http://zhangbuzola.cn/2017/12/27/java基础之finalize/","excerpt":"","text":"finalize的作用 finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题] finalize的问题一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法 System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们 Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行 finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行 对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的 finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为) finalize的执行过程(生命周期) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。 finalize流程对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下： unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的 finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行 finalized: 表示GC已经对该对象执行过finalize方法 reachable: 表示GC Roots引用可达 finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达 unreachable：对象不可通过上面两种途径可达 状态变迁图 变迁说明： 新建对象首先处于[reachable, unfinalized]状态(A) 随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态 若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。 在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N) 处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因 程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为 若JVM检测到finalized状态的对象变成unreachable，回收其内存(I) 若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O） 注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法 一些代码示例对象复活12345678910111213141516171819202122232425262728293031public class GC &#123; public static GC SAVE_HOOK = null; public static void main(String[] args) throws InterruptedException &#123; SAVE_HOOK = new GC(); SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (null != SAVE_HOOK) &#123; //此时对象应该处于(reachable, finalized)状态 System.out.println(&quot;Yes , I am still alive&quot;); &#125; else &#123; System.out.println(&quot;No , I am dead&quot;); &#125; SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (null != SAVE_HOOK) &#123; System.out.println(&quot;Yes , I am still alive&quot;); &#125; else &#123; System.out.println(&quot;No , I am dead&quot;); &#125; &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(&quot;execute method finalize()&quot;); SAVE_HOOK = this; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"leetcode刷题四","slug":"leetcode-Array-4","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/12/20/leetcode-Array-4/","link":"","permalink":"http://zhangbuzola.cn/2017/12/20/leetcode-Array-4/","excerpt":"","text":"695. Max Area Of Island难度星级： *** 题目描述Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: 12345678910[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]Given the above grid, return 6. Note the answer is not 11because the island must be connected 4-directionally. Example 2: 12[[0,0,0,0,0,0,0,0]]Given the above grid, return 0. Note: The length of each dimension in the given grid does not exceed 50. 解题思路题目给了我们一个 2d grid array， 让我们找到所有岛中区域最大的一个，返回区域值。0代表海洋，1代表陆地。陆地与陆地相连，只能是横向和纵向，不可以斜着。 因为只能横向和纵向相连，所以每一个cell 只能是4个方向延伸，左 上 右 下。 这道题目要用到Depth-first Search，遍历2d array，遇到1的时候，就利用dfs把这个岛的区域大小找全。我的dps顺序是 左，上，右，下。在递归dfs之前，要把目前的cell 设为0，是为了避免dfs又往回走，每一个数过的cell，就不需要在重复走了。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; int max_area = 0; for(int i=0; i&lt;grid.length; i++) &#123; for(int j=0; j&lt;grid[0].length; j++) &#123; if(grid[i][j] == 1) max_area = Math.max(max_area, dfs(grid, i, j)); &#125; &#125; return max_area; &#125; public int dfs(int[][] grid, int i, int j) &#123; // if i or j is invalid or grid is 0, just return 0 if( i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length || grid[i][j] == 0) return 0; // do dfs to its 4 direction cell when value is 1 int tempMaxArea = 1; grid[i][j] = 0; // set current cell to 0 to prevent dfs coming back // order is left, top, right, bottom tempMaxArea += dfs(grid, i, j-1) + dfs(grid, i-1, j) + dfs(grid, i, j+1) + dfs(grid, i+1, j); return tempMaxArea; &#125;&#125; 689. Maximum Sum of 3 Non-Overlapping Subarrays难度星级： ** 题目描述In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum. Each subarray will be of size k, and we want to maximize the sum of all 3*k entries. Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one. Example: 1234Input: [1,2,1,2,6,7,5,1], 2Output: [0, 3, 5]Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger. Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3). 解题思路题意: 解法一给定正整数数组nums，计算其中不想交的3段子数组的最大和。每段子数组的长度为k。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution: def maxSumOfThreeSubarrays(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; # print(nums) #前缀和 s = [0] * len(nums) s[0] = nums[0] for i in range(1, len(s)): s[i] = s[i - 1] + nums[i] # print(&apos;s&apos;, s) a = [0] * len(nums) a[k - 1] = s[k - 1] for i in range(k, len(s)): a[i] = s[i] - s[i - k] # print(&apos;a&apos;, a) #最大前缀和 ss = [0] * len(nums) ma = 0 for i in range(k - 1, len(s)): if a[i] &gt; a[ma]: ma = i ss[i] = (a[ma], ma) # print(&apos;ss&apos;,ss) sss = [0] * len(nums) for i in range(k * 2 - 1, len(s)): sss[i] = a[i] + ss[i - k][0] # print(&apos;sss&apos;,sss) #二级最大前缀和 b = [0] * len(nums) ma = 0 for i in range(k * 2 - 1, len(s)): if sss[i] &gt; sss[ma]: ma = i b[i] = (sss[ma], ma) # print(&apos;b&apos;,b) #三级前缀和 c = [0] * len(nums) for i in range(k * 3 - 1, len(s)): c[i] = a[i] + b[i - k][0] # print(&apos;c&apos;,c) ans = 0 for i in range(k * 3 - 1, len(c)): if c[i] &gt; c[ans]: ans = i ret = [0, 0, ans] ret[1] = b[ret[2] - k][1] ret[0] = ss[ret[1] - k][1] ret = list(map(lambda i: i - k+1, ret)) return retif __name__ == &apos;__main__&apos;: ans = Solution().maxSumOfThreeSubarrays([1,2,1,2,6,7,5,1], 2) print(ans) 解法二分治法和合并法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int[] maxSumOfThreeSubarrays(int[] nums, int k) &#123; int n = nums.length; int[] sum = new int[n + 1]; int[] left = new int[n]; int[] right = new int[n]; int[] ret = new int[3]; // First get the prefix sum of nums. // Prefix sum enables us to get the sum of k consecutive element in O(1) time for (int i = 0; i &lt; n; i++) &#123; sum[i + 1] = sum[i] + nums[i]; &#125; // DP for the left intetval max sum for (int i = k, tot = sum[k] - sum[0]; i &lt; n; i++) &#123; if (sum[i + 1] - sum[i - k + 1] &gt; tot) &#123; tot = sum[i + 1] - sum[i - k + 1]; left[i] = i - k + 1; &#125; else &#123; left[i] = left[i - 1]; &#125; &#125; // DP for the right interval max sum right[n - k] = n - k; for (int i = n - 1 - k, tot = sum[n] - sum[n - k]; i &gt;= 0; i--) &#123; if (sum[i + k] - sum[i] &gt;= tot) &#123; tot = sum[i + k] - sum[i]; right[i] = i; &#125; else &#123; right[i] = right[i + 1]; &#125; &#125; // Find the max sum by iterating through the middle interval index based on above 2 cache. int maxSum = 0; for (int i = k; i &lt;= n - 2 * k; i++) &#123; int l = left[i - 1], r = right[i + k]; int tot = sum[l + k] - sum[l] + sum[r + k] - sum[r] + sum[i + k] - sum[i]; if (tot &gt; maxSum) &#123; ret[0] = l; ret[1] = i; ret[2] = r; maxSum = tot; &#125; &#125; return ret; &#125;&#125; 683. K Empty Slots难度星级： * 题目描述There is a garden with N slots. In each slot, there is a flower. The N flowers will bloom one by one in N days. In each day, there will be exactly one flower blooming and it will be in the status of blooming since then. Given an array flowers consists of number from 1 to N. Each number in the array represents the place where the flower will open in that day. For example, flowers[i] = x means that the unique flower that blooms at day i will be at position x, where i and x will be in the range from 1 to N. Also given an integer k, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming. If there isn’t such day, output -1. Example 1: 12345Input: flowers: [1,3,2]k: 1Output: 2Explanation: In the second day, the first and the third flower have become blooming. Example 2: 1234Input: flowers: [1,2,3]k: 1Output: -1 Note: The given array will be in the range [1, 20000]. 解题思路题意： 树状数组（Fenwick Tree） 树状数组ft[k]存储前k个槽一共有多少朵花，则区间[m, n]的花朵总数 = ft[n] - ft[m - 1] 利用该数据结构，遍历flowers即可求解。 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def kEmptySlots(self, flowers, k): &quot;&quot;&quot; :type flowers: List[int] :type k: int :rtype: int &quot;&quot;&quot; maxn = max(flowers) nums = [0] * (maxn + 1) ft = FenwickTree(maxn) for i, v in enumerate(flowers): ft.add(v, 1) nums[v] = 1 if v &gt;= k and ft.sum(v) - ft.sum(v - k - 2) == 2 and nums[v - k - 1]: return i + 1 if v + k + 1&lt;= maxn and ft.sum(v + k + 1) - ft.sum(v - 1) == 2 and nums[v + k + 1]: return i + 1 return -1class FenwickTree(object): def __init__(self, n): self.n = n self.sums = [0] * (n + 1) def add(self, x, val): while x &lt;= self.n: self.sums[x] += val x += self.lowbit(x) def lowbit(self, x): return x &amp; -x def sum(self, x): res = 0 while x &gt; 0: res += self.sums[x] x -= self.lowbit(x) return res 674. Longest Continuous Increasing Subsequence题目描述Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get. Example 1: 123Input: 2736Output: 7236Explanation: Swap the number 2 and the number 7. Example 2: 123Input: 9973Output: 9973Explanation: No swap. Note: The given number is in the range [0, 108] 解题思路123456789101112131415161718192021222324package com.leetcode.coding;public class LongestContinuousIncreasingSubsequence &#123; public static int findLengthOfLCIS(int[] nums) &#123; if(nums.length == 0) &#123; return 0; &#125; int curlen = 0; for(int i = 0, k = 1; i &lt; nums.length-1; i++) &#123; if(nums[i] &lt; nums[i+1]) &#123; k++; curlen = Math.max(curlen, k); &#125; else &#123; k = 1; &#125; &#125; return curlen; &#125; public static void main(String[] args) &#123; int[] nums = &#123;1,3,5,4,7&#125;; int len = findLengthOfLCIS(nums); System.out.println(len); &#125;&#125; 670. Maximum Swap题目描述Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get. Example 1: 123Input: 2736Output: 7236Explanation: Swap the number 2 and the number 7. Example 2: 123Input: 9973Output: 9973Explanation: No swap. Note: The given number is in the range [0, 108]. 解题思路题意：给定非负整数，至多对调其中的两个数字，使数字最大化 从左向右（高位到低位）遍历nums, numt，记当前数字分别为m, n, 下标为i 若m != n：则将nums[i + 1 .. size]的最后一个最大值maxv与m对调 将nums恢复为数字并返回。 1234567891011121314151617181920212223242526public static int maximumSwap1(int num) &#123; char[] digits = Integer.toString(num).toCharArray(); int[] buckets = new int[10]; for (int i = 0; i &lt; digits.length; i++) &#123; buckets[digits[i] - &apos;0&apos;] = i; &#125; for (int i = 0; i &lt; digits.length; i++) &#123; //从最高位开始 for (int k = 9; k &gt; digits[i] - &apos;0&apos;; k--) &#123; // k需要比数字digits[i]大 if (buckets[k] &gt; i) &#123; //如果k的位置在i后面 char tmp = digits[i]; digits[i] = digits[buckets[k]]; digits[buckets[k]] = tmp; return Integer.valueOf(new String(digits)); &#125; &#125; &#125; return num;&#125;public static void main(String[] args) &#123; int n = 2736; int i = maximumSwap1(n); System.out.println(i);&#125; 667. Beautiful Arrangement II题目描述Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:Suppose this list is [a1, a2, a3, … , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, … , |an-1 - an|] has exactly k distinct integers. If there are multiple answers, print any of them. Example 1: 1234Input: n = 3, k = 1Output: [1, 2, 3]Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3,and the [1, 1] has exactly 1 distinct integer: 1. Example 2: 1234Input: n = 3, k = 2Output: [1, 3, 2]Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3,and the [2, 1] has exactly 2 distinct integers: 1 and 2. Note: The n and k are in the range 1 &lt;= k &lt; n &lt;= 104. 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041package com.leetcode.coding;public class BeautifulArrangementII &#123; public static int[] constructArray(int n, int k) &#123; int[] res = new int[n]; int l = 1, r = n; for(int i = 0; l &lt;= r; i++) &#123; res[i] = k &gt; 1 ? (k-- % 2 == 0 ? r-- : l++) : l++; &#125; return res; &#125; public static int[] constructArray1(int n, int k) &#123; int[] res = new int[n]; for(int i = 1, j = n, s = 0; i &lt;= j;) &#123; if(k &gt; 1) &#123; if(k % 2 == 0) &#123; res[s++] = i++; &#125; else &#123; res[s++] = j--; &#125; k--; &#125; else &#123; if(k % 2 == 0) &#123; res[s++] = i++; &#125; else &#123; res[s++] = j--; &#125; &#125; &#125; return res; &#125; public static void main(String[] args) &#123; int[] res = BeautifulArrangementII.constructArray(7, 3); for(int i = 0; i &lt; res.length; i++) &#123; System.out.print(res[i] + &quot; &quot;); &#125; &#125;&#125; 665. Non-decreasing Array题目描述Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n). Example 1: 123Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. Example 2: 123Input: [4,2,1]Output: FalseExplanation: You can&apos;t get a non-decreasing array by modify at most one element. Note: The n belongs to [1, 10,000]. 解题思路123456789101112131415161718192021222324252627282930class Solution &#123; public boolean checkPossibility(int[] nums) &#123; boolean modified = false; for(int i=0; i&lt;nums.length; i++) &#123; if(i+1 &lt; nums.length &amp;&amp; nums[i] &gt; nums[i+1]) &#123; if(modified) // if modified a number already return false; else // if it is first time to modify a number &#123; if(i-1 &lt; 0 || nums[i+1] &gt;= nums[i-1]) // if nums[i+1] is larger or equal all numbers before nums[i] nums[i] = nums[i+1]; // change nums[i] as same as nums[i+1] else // if nums[i+1] is not larger than all numbers before nums[i] nums[i+1] = nums[i]; // change nums[i+1] as same as nums[i] modified = true; &#125; &#125; &#125; return true; &#125;&#125; 12345678910111213141516class Solution(object): def checkPossibility(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; times = 0 for i in range(1, len(nums)): if nums[i] &lt; nums[i - 1]: times += 1 if times == 2: return False if (i != 1 and i != len(nums) - 1): if (nums[i - 1] &gt; nums[i + 1] and nums[i] &lt; nums[i - 2]): return False return True 621. Task Schedular题目描述Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks. Example 1: 123Input: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2Output: 8Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. Note: The number of tasks is in the range [1, 10000]. The integer n is in the range [0, 100]. 解题思路 贪心，利用优先队列排序：队列中保存&lt;类型，个数&gt;的map，并且按照个数由大到小排序。按照词频由大到小取出n+1个或者队列中全部(若没有取出全部，则总长度要加上空闲个数)，再把词频-1之后不为0的放回队列中。直到队列空了为止。——其实也和前面相同，总是选择词频最大的填入每一块。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123; map&lt;char, int&gt; m; for (int i = 0; i &lt; tasks.size(); ++i) &#123; m[tasks[i]]++; &#125; priority_queue&lt;int&gt; pq; for (auto ite : m)&#123; pq.push(ite.second); &#125; int cycle = n + 1, ret = 0; while(!pq.empty())&#123; vector&lt;int&gt; tmp; int time = 0; for (int i = 0; i &lt; cycle; ++i) &#123; if (!pq.empty())&#123; tmp.push_back(pq.top()); pq.pop(); time++; &#125; &#125; for (auto cnt : tmp)&#123; int remainCnt = cnt - 1; if(remainCnt &gt; 0)pq.push(remainCnt); &#125; if(pq.empty()) ret += time;//如果是最后一次调度，不在需要idle来填充 else ret += cycle; &#125; return ret; &#125;&#125;; 先统计词频，再排序，从后往前找到第一个不是最大词频的下标i，结果是tasks.length或(c[25] - 1) * (n + 1) + 25 – i中大的那一个，25-i就是最大词频的任务类，这个和我的思路是一样的。证明：最大词频是k，则创建k个块，每一块开头是最大词频的任务构成的(输入AACCCDDEEE，则开头是CE)，词频由大到小插入每一块。 这道题让我们安排CPU的任务，规定在两个相同任务之间至少隔n个时间点。说实话，刚开始博主并没有完全理解题目的意思，后来看了大神们的解法才悟出个道理来。下面这种解法参考了大神fatalme的帖子，由于题目中规定了两个相同任务之间至少隔n个时间点，那么我们首先应该处理的出现次数最多的那个任务，先确定好这些高频任务，然后再来安排那些低频任务。如果任务F的出现频率最高，为k次，那么我们用n个空位将每两个F分隔开，然后我们按顺序加入其他低频的任务，来看一个例子： AAAABBBEEFFGG 3 我们发现任务A出现了4次，频率最高，于是我们在每个A中间加入三个空位，如下： A—A—A—A AB–AB–AB–A (加入B) ABE-ABE-AB–A (加入E) ABEFABE-ABF-A (加入F，每次尽可能填满或者是均匀填充) ABEFABEGABFGA (加入G) 再来看一个例子： ACCCEEE 2 我们发现任务C和E都出现了三次，那么我们就将CE看作一个整体，在中间加入一个位置即可： CE-CE-CE CEACE-CE (加入A) 注意最后面那个idle不能省略，不然就不满足相同两个任务之间要隔2个时间点了。 12345678910111213141516171819202122class Solution &#123;public: int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123; int mx = 0, mxCnt = 0; vector&lt;int&gt; cnt(26, 0); for (char task : tasks) &#123; ++cnt[task - &apos;A&apos;]; if (mx == cnt[task - &apos;A&apos;]) &#123; ++mxCnt; &#125; else if (mx &lt; cnt[task - &apos;A&apos;]) &#123; mx = cnt[task - &apos;A&apos;]; mxCnt = 1; &#125; &#125; int partCnt = mx - 1; int partLen = n - (mxCnt - 1); int emptySlots = partCnt * partLen; int taskLeft = tasks.size() - mx * mxCnt; int idles = max(0, emptySlots - taskLeft); return tasks.size() + idles; &#125;&#125;; 12345678910111213public class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int[] map = new int[26]; for (char c: tasks) map[c - &apos;A&apos;]++; Arrays.sort(map); int max_val = map[25] - 1, idle_slots = max_val * n; for (int i = 24; i &gt;= 0 &amp;&amp; map[i] &gt; 0; i--) &#123; idle_slots -= Math.min(map[i], max_val); &#125; return idle_slots &gt; 0 ? idle_slots + tasks.length : tasks.length; &#125;&#125; 532. K-diff Pairs in an ArrayGiven an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1: 1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. Example 2: 123Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3: 123Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). Note: The pairs (i, j) and (j, i) count as the same pair. The length of the array won’t exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7]. 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public int findPairs(int[] nums, int k) &#123; if(nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); if(nums[0] + k &gt; nums[nums.length-1])&#123; return 0; &#125; int count = 0; //boolean[] visited = new boolean[nums.length]; //System.out.println(visited[0]); int keyindex = -1; for(int i = 0; i &lt; nums.length; i++) &#123; //System.out.println(&quot;i: &quot; + i + &quot;, &quot;+&quot;nums[i]: &quot;+nums[i] +&quot;, &quot;+ &quot;nums[i]+k: &quot; + (nums[i] + k)); //System.out.println(nums[i] + k); int target = nums[i] + k; if(i == 0) &#123; keyindex = binarySearch(nums, 1, target); //System.out.println(&quot;keyindex:&quot; + keyindex); if(keyindex != -1) &#123; count++; &#125; &#125; else if(i != 0 &amp;&amp; nums[i] != nums[i-1]) &#123; keyindex = binarySearch(nums, i+1, target); //System.out.println(&quot;keyindex:&quot; + keyindex); if(keyindex != -1) &#123; count++; &#125; &#125; &#125; return count; &#125; public int binarySearch(int[] nums, int start, int target) &#123; int left = start, right = nums.length - 1; //System.out.println(mid); while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if(nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; return left; &#125; &#125; return -1; &#125;&#125; 581. Shortest Unsorted Continuous Subarray题目描述Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. Example 1: 1234Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Note: Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means &lt;=. 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041/** * */package com.leetcode.coding;import java.util.Arrays;/** * @author zolanunu * */public class ShortestUnSortedContinuousSubArray &#123; public static int findUnsortedSubarray(int[] nums) &#123; int len = nums.length; int[] numscopy = new int[nums.length]; for(int i = 0; i &lt; len; i++) &#123; numscopy[i] = nums[i]; &#125; Arrays.sort(nums); int s = -1, e = -1; for(int i = 0; i &lt; len; i++) &#123; if(numscopy[i] != nums[i]) &#123; if(s == -1) &#123; s = i; &#125; e = i; &#125; System.out.println(s +&quot; &quot;+ e); &#125; if(s == e) &#123; return 0; &#125; System.out.println(s +&quot; &quot;+ e); return e - s + 1; &#125; public static void main(String[] args) &#123; int[] nums = &#123;1,2,3,4,5,2&#125;; System.out.println(findUnsortedSubarray(nums)); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://zhangbuzola.cn/tags/算法与数据结构/"},{"name":"leetcode","slug":"leetcode","permalink":"http://zhangbuzola.cn/tags/leetcode/"}]},{"title":"java基础学习之构造函数","slug":"javabase_constructure","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/12/20/javabase_constructure/","link":"","permalink":"http://zhangbuzola.cn/2017/12/20/javabase_constructure/","excerpt":"","text":"构造方法构造方法函数123456789101112131415161718192021public class Car_1 &#123; private String color; private String brand; public Car_1() &#123; this.color = &quot;blue&quot;; this.brand = &quot;aodi&quot;; &#125; public Car_1(String color, String brand) &#123; this.color = color; this.brand = brand; &#125;&#125;// 构造函数，构造名字与类名一致// 在创建对象的时候，对象成员可以由构造函数方法进行初始化// new对象时，都是用构造方法进行实例化的；Test test = new Test（&quot;a&quot;）；//Test（&quot;a&quot;）；其中这个就是构造函数，“a”为构造方法的形参；// 构造函数的任务是初始化一个对象内部的状态 12345构造方法的方法名必须与类名一样。构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。构造方法不能作用是完成对象的初始化工作，他能够把定义对象时的参数传递给对象的域。构造方法不能由编程人员调用，而要系统调用。构造方法可以重载，以参数的个数，类型，或排序顺序区分 多个构造函数重载构造函数 继承中的构造函数1234567891011121314151617181920public Class Parent&#123; public Parent() &#123; sysout(&quot;constructure in parent...&quot;) &#125;&#125;public Class SubParent extends Parent&#123; public SubParent() &#123; sysout(&quot;constructure in SubParent, SubParent extends Parent...&quot;) &#125;&#125;public Class Subtine extends SubParent&#123; public Subtine() &#123; sysout(&quot;constructur in Subtine, Subtine extend SubParent...&quot;) &#125;&#125;// outputconstructure in parent...constructure in SubParent, SubParent extends Parent...constructur in Subtine, Subtine extend SubParent... 在Subtine的主方法中只调用子类构造方法，实例化子类对象并且在子类构造方法中，没有调用父类的构造方法的任何语句。但是在实例化对象时，它相应的调用了父类构造方法，在结果中还可以看到调用构造方法的顺序，首先是顶级，再继续往下直达本身类。也就是说实例化子类的时候，要首先实例化父类对象，然后在实例化子类对象，所以在子类构造方法调用父类构造方法前，父类已经实例化了。 但是对于有参数的构造函数，就不一样了。 1234567891011121314151617181920public class Parent &#123; Parent(int a)&#123;//就是将无参数构造方法改成有参数的。 System.out.println(&quot;调用父类Parent构造方法&quot; + a); &#125;&#125;public class Subparent extends Parent&#123; Subparent()&#123; System.out.println(&quot;调用子类Subparent的构造方法&quot;); &#125;&#125;public class Subtine extends Subparent&#123; Subtine()&#123; System.out.println(&quot;调用子类Subtine构造方法&quot;); &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; Subtine subtine = new Subtine(); &#125;&#125; 上面的代码会报错，原因就是在子类调用构造函数的时候，必须先调用父类构造函数，因为无参数构造函数，编译器会自动调用，也就是第一种情况就不会报错。但是对于有参数的，就必须利用Super的方法来调用。如果不进行调用那么将会报错。其实意思就是你需要在子类中明显显示调用父类的构造方法，除了无参构造。不论是在子类的有参构造还是无参构造当中，都需要显式地调用父类有参构造函数。 1234567public class Subparent extends Parent&#123; Subparent()&#123; super(5);//调用了其父类就不会报错了。 System.out.println(&quot;调用子类Subparent的构造方法&quot;); &#125;&#125;//备注一下，调用父类构造方法就是；super()；//就ok了。 还补充一点，关于构造方法的可扩展性； 查看过源码的应该都发现过jdk的编码人员会在一个类中建立多个构造方法；然而他的作用就是提高可扩展性； 这么多构造方法，他们之间并且还有联系；通过this（）来调用自己类的其他构造方法，来减少代码的复制，增大程序的可读性； 测试1-如果父类不主动创建构造函数则子类创建构造函数没有限制。 测试2-如果父类创建不含参构造函数则子类创建构造函数没有限制且先执行父类的构造函数。 测试3-如果父类创建含参构造函数则子类创建构造函数需要先super父类函数且先执行父类的构造函数。 测试4-如果父类创建多个含参构造函数则子类创建构造函数需要先super指定的父类函数（如父类包含无参构造函数则子类可以不super父类函数同测试2）。 12345678910111213141516171819202122232425262728293031public class Father &#123; public Father(int a) &#123; System.out.println(&quot;这是父类的构造函数1&quot;); &#125; public Father(String b) &#123; System.out.println(&quot;这是父类的构造函数2&quot;); &#125;&#125;public class Child extends Father &#123; public Child()&#123; super(&quot;a&quot;); System.out.println(&quot;这是子类的构造函数调用2&quot;); &#125; public Child(String a, int b) &#123; super(1); System.out.println(&quot;这是子类的构造函数调用1&quot;); &#125; public static void main(String[] args) &#123; Child t3 = new Child(&quot;xx&quot;,1); Child t4 = new Child(); &#125;&#125;//output这是父类的构造函数1这是子类的构造函数调用1这是父类的构造函数2这是子类的构造函数调用2 如果父类不主动创建构造函数或者父类有无参的构造函数则子类可以不考虑父类的构造函数。 如果子类需要继承父类的含参构造函数则需要使用super命令（如果父类包含多个含参构造函数则依据参数使用super命令）3、如果父类建立了构造函数且都含有参数，则子类必须使用super命令。 构造函数能否被继承不能，因为子类继承父类的时候，先运行父类构造函数；具体的说就是运行父类时就会先“调用”父类的构造函数，注意“调用”和继承不是一个含义，实质上是“自动运行”。 继承（extends）的含义其实是“扩展”，子类完全没必要扩展父类的构造函数，因为反正每次调子类的时候都会“自动运行”它父类的构造函数，如果真的需要子类构造函数特殊的形式，子类直接修改或重载自己的构造函数就好了。 估计是你对“构造函数”的意义本身不理解，“调用”一个类有“继承”和“组合（说白了new 一个类）”两种方式，当你“调用”一个类的时候就会“自动运行”它的“构造函数”","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"leetcode刷题三","slug":"leetcode-Array-3","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/12/19/leetcode-Array-3/","link":"","permalink":"http://zhangbuzola.cn/2017/12/19/leetcode-Array-3/","excerpt":"","text":"724. Find Pivot Index题目描述Given an array of integers nums, write a method that returns the “pivot” index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 1: 123456789101112Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs. Example 2: 123456789Input: nums = [1, 2, 3]Output: -1Explanation: There is no index that satisfies the conditions in the problem statement. Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. 解题思路1234567891011121314151617181920212223class Solution &#123; public int pivotIndex(int[] nums, int k) &#123; if(nums.length &lt; 3) &#123; return -1; &#125; int[] sum = new int[nums.length]; int max; for(int i = 0; i &lt; nums.length; i++) &#123; if(i == 0) &#123; sum[i] = nums[i]; &#125; else &#123; sum[i] = sum[i-1] + nums[i]; &#125; &#125; max = sum[nums.length-1]; for(int i = 0; i &lt; nums.length; i++) &#123; if(max - sum[i] == sum[i] - nums[i]) &#123; return i; &#125; &#125; return -1; &#125;&#125; 723. Candy Crush题目描述Given a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies. A value of board[i][j] = 0 represents that the cell at position (i, j) is empty. The given board represents the state of the game following the player’s move. Now, you need to restore the board to a stable state by crushing candies according to the following rules: If three or more candies of the same type are adjacent vertically or horizontally, “crush” them all at the same time - these positions become empty.After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.If there does not exist more candies that can be crushed (ie. the board is stable), then return the current board.You need to perform the above rules until the board becomes stable, then return the current board. Example 1: 12345678910Input:board = [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,2,1,2,2],[4,1,4,4,1014]]Output:[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]Explanation: Note: The length of board will be in the range [3, 50]. The length of board[i] will be in the range [3, 50]. Each board[i][j] will initially start as an integer in the range [1, 2000]. 解题思路题意：模拟实现游戏“糖果粉碎传奇”。 给定二维数组board，每行、列中3个或以上连续相同的数字都可以被消去（变为0表示空位），消去后位于上方的数字会填充空位。 重复直到没有更多的数字可以被消去。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; candyCrush(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int m = board.size(), n = board[0].size(); while (true) &#123; vector&lt;pair&lt;int, int&gt;&gt; del; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (board[i][j] == 0) continue; int x0 = i, x1 = i, y0 = j, y1 = j; while (x0 &gt;= 0 &amp;&amp; x0 &gt; i - 3 &amp;&amp; board[x0][j] == board[i][j]) --x0; while (x1 &lt; m &amp;&amp; x1 &lt; i + 3 &amp;&amp; board[x1][j] == board[i][j]) ++x1; while (y0 &gt;= 0 &amp;&amp; y0 &gt; j - 3 &amp;&amp; board[i][y0] == board[i][j]) --y0; while (y1 &lt; n &amp;&amp; y1 &lt; j + 3 &amp;&amp; board[i][y1] == board[i][j]) ++y1; if (x1 - x0 &gt; 3 || y1 - y0 &gt; 3) del.push_back(&#123;i, j&#125;); &#125; &#125; if (del.empty()) break; for (auto a : del) board[a.first][a.second] = 0; for (int j = 0; j &lt; n; ++j) &#123; int t = m - 1; for (int i = m - 1; i &gt;= 0; --i) &#123; if (board[i][j]) swap(board[t--][j], board[i][j]); &#125; &#125; &#125; return board; &#125;&#125;; 714. Best Time to Buy and Sell Stock with Transaction Fee题目描述Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 12345678Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Note: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 解题思路1234567891011121314151617// 动态规划,到第i天有两种状态，一种是持有股票并且最大利润，有两种选择,一个是什么都不做，一个是买入股票;// 一种是未持有股票并且最大利润,也有两种选择，一种是什么都不做，一种是卖出股票，我们用两个数组分别保存,每次得到最优解即可.class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int l = prices.length; int[] hold = new int[l + 1]; //Hold the stock until day i; int[] notHold = new int[l + 1]; //Do not hold the stock until day i; hold[0] = Integer.MIN_VALUE; for (int i = 1; i &lt;= l; i++) &#123; hold[i] = Math.max(hold[i - 1], notHold[i - 1] - prices[i - 1] - fee); // buy notHold[i] = Math.max(notHold[i - 1], hold[i - 1] + prices[i - 1]); // sell &#125; return notHold[l]; &#125;&#125; 1234567891011121314public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int cash=0;//the maxPro you have if you don&apos;t have a stock that day int hold=-prices[0]; // the maxPro you have if you have a stock that day, // if you have a stock the first day,hold=-prices[0] int i; for(i=1;i&lt;prices.size();i++)&#123; cash=max(cash,hold+prices[i]-fee); //cash in day i is the maxvalue of cash in day i-1 or you sell your stock hold=max(hold,cash-prices[i]); &#125; return cash; &#125; 713. Subarray Product Less Than K题目描述Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: 1234Input: nums = [10, 5, 2, 6], k = 100Output: 8Explanation: The 8 subarrays that have product less than 100 are:[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. Note: 0 &lt; nums.length &lt;= 50000. 0 &lt; nums[i] &lt; 1000. 0 &lt;= k &lt; 10^6. 解题思路比赛的时候想试试O（N*N）结果过了，后来数据更新了，我又重新写了个O(N)的 记得自己以前总结过 substring , subarray的题目很多时候可以用滑动窗口（子序列不行 那么我们先来看看比较暴力的方法吧 先看例子 nums = [10, 5, 2, 6], k = 100 我们从左到右每次读到一个就枚举前面可以达到最长的然后 结果加上长度 第一次 10 ans = 1 5,10( 5可以，5，10可以) ans=1+2 2,5( 2可以，2，5可以） ans = 1 + 2 + 2 6,2,5( 6可以 ， 2，6可以，2，5，6可以） ans = 1+2 +2 +3 =8 这样做是O（N*N）但是我们或许不需要这么做 我们可以用two poionts + sliding window 来解决这个问题还是之前的例子 我们定义起点为0开始 10 ans = 1 10，5 ans = 1+2 10,5,2不可以但是我们直接除10并且起点++ 12345678910111213141516171819class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if( k == 0 ) return 0 ; int start =0 ; int val = 1 ; int ans =0 ; for( int i =0 ; i&lt; nums.size() ; i++)&#123; val *= nums[i]; while( val &gt;= k &amp;&amp; start &lt;= i )&#123; val/=nums[start]; start ++; &#125; ans+= i-start+1; &#125; return ans ; &#125;&#125;; 697. Degree of an Array题目描述Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: 1234567Input: [1, 2, 2, 3, 1]Output: 2Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice.Of the subarrays that have the same degree:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]The shortest length is 2. So return 2. Example 2: 12Input: [1,2,2,3,1,4,2]Output: 6 Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999. 解题思路给了我们一个数组，定义数组的度为某个或某些数字出现最多的次数，要我们找最短的子数组使其和原数组拥有相同的度。那么我们肯定需要统计每个数字出现的次数，就要用哈希表来建立每个数字和其出现次数之间的映射。由于我们要求包含原度的最小长度的子数组，那么最好的情况就是子数组的首位数字都是统计度的数字，即出现最多的数字。那么我们肯定要知道该数字的第一次出现的位置和最后一次出现的位置，由于我们开始不知道哪些数字会出现最多次，所以我们统计所有数字的首尾出现位置，那么我们再用一个哈希表，建立每个数字和其首尾出现的位置。我们用变量degree来表示数组的度。好，现在我们遍历原数组，累加当前数字出现的次数，当某个数字是第一次出现，那么我们用当前位置的来更新该数字出现的首尾位置，否则只更新尾位置。每遍历一个数，我们都更新一下degree。当遍历完成后，我们已经有了数组的度，还有每个数字首尾出现的位置，下面就来找出现次数为degree的数组，然后计算其首尾位置差加1就是candidate数组的长度，由于出现次数为degree的数字不一定只有一个，我们遍历所有的，找出其中最小的即可，参见代码如下： 12345678910111213141516171819202122class Solution &#123;public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), res = INT_MAX, degree = 0; unordered_map&lt;int, int&gt; m; unordered_map&lt;int, pair&lt;int, int&gt;&gt; pos; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (++m[nums[i]] == 1) &#123; pos[nums[i]] = &#123;i, i&#125;; &#125; else &#123; pos[nums[i]].second = i; &#125; degree = max(degree, m[nums[i]]); &#125; for (auto a : m) &#123; if (degree == a.second) &#123; res = min(res, pos[a.first].second - pos[a.first].first + 1); &#125; &#125; return res; &#125;&#125;; 用一次遍历，建立数字出现次数的哈希表，还有建立每个数字和其第一次出现位置之间的映射。 那么我们当前遍历的位置其实可以看作是尾位置，还是可以计算子数组的长度的。我们遍历数组，累加当前数字出现的次数，如果某个数字是第一次出现，建立该数字和当前位置的映射。 如果当前数字的出现次数等于degree时，当前位置为尾位置，首位置在startIdx中取的，二者做差加1来更新结果res；如果当前数字的出现次数大于degree，说明之前的结果代表的数字不是出现最多的，直接将结果res更新为当前数字的首尾差加1的长度，然后degree也更新为当前数字出现的次数。 123456789101112131415161718class Solution &#123;public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), res = INT_MAX, degree = 0; unordered_map&lt;int, int&gt; m, startIdx; for (int i = 0; i &lt; n; ++i) &#123; ++m[nums[i]]; if (!startIdx.count(nums[i])) startIdx[nums[i]] = i; if (m[nums[i]] == degree) &#123; res = min(res, i - startIdx[nums[i]] + 1); &#125; else if (m[nums[i]] &gt; degree) &#123; res = i - startIdx[nums[i]] + 1; degree = m[nums[i]]; &#125; &#125; return res; &#125;&#125;; 解法三题目给了我们一个 nums array， 让我们首先找到 出现最多次数的数字（可能多于1个），然后在这些数字中，找到一个 长度最小的 数字。返回它的长度。 比较直接的想法就是，既然我们首先要知道每一个数字出现的次数，那么就利用HashMap，而且我们还要知道 这个数字的最小index 和最大index，那么也可以存入map记录。 设一个HashMap&lt;Integer, int[]&gt; map， key 就是 num，value 就是int[3]: int[0] 记录 firstIndex; int[1] 记录 lastIndex; int[2] 记录次数。 这样的话，我们需要遍历两次： 第一次遍历nums array：记录每一个数字的 firstIndex， lastIndex， 出现次数； 还要记录下最大的出现次数。 第二次遍历map key set：当key (num) 的次数等于最大次数的时候，记录最小的长度。(lastIndex - firstIndex + 1)。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int findShortestSubArray(int[] nums) &#123; HashMap&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;(); int maxFre = 0; int minLen = Integer.MAX_VALUE; // first nums iteration: store first index, last index, occurrence and find out the maxFre for(int i=0; i&lt;nums.length; i++) &#123; if(map.containsKey(nums[i])) // num is already in map &#123; map.get(nums[i])[1] = i; // update this num&apos;s end index map.get(nums[i])[2]++; // update this num&apos;s occurrence &#125; else // first time that store into map &#123; int[] numInfo = new int[3]; numInfo[0] = i; // store this num&apos;s begin index numInfo[1] = i; // store this num&apos;s end index numInfo[2] = 1; // store this num&apos;s occurrence map.put(nums[i], numInfo); &#125; maxFre = Math.max(maxFre, map.get(nums[i])[2]); // update maxFre &#125; // second map keys iteration: find the minLen for numbers that have maxFre for(int num: map.keySet()) if(maxFre == map.get(num)[2]) minLen = Math.min(minLen, map.get(num)[1] - map.get(num)[0] + 1); return minLen; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"},{"name":"leetcode","slug":"leetcode","permalink":"http://zhangbuzola.cn/tags/leetcode/"}]},{"title":"leetcode刷题二","slug":"leetcode-Array-2","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2017/12/16/leetcode-Array-2/","link":"","permalink":"http://zhangbuzola.cn/2017/12/16/leetcode-Array-2/","excerpt":"","text":"720. Longest Word in Dictionary题目描述Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Example 1: 12345Input: words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]Output: &quot;world&quot;Explanation: The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;. Example 2: 123456Input: words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]Output: &quot;apple&quot;Explanation: Both &quot;apply&quot; and &quot;apple&quot; can be built from other words in the dictionary. However, &quot;apple&quot; is lexicographically smaller than &quot;apply&quot;. Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30]. 解题思路题意：给定一组词组成的字典，判断其中前缀均可以在字典中找到的最长词，若存在长度相同的情况，则返回字典序最小的词。给出的是个字符串数组，然后问我们从单个字符开始拼，最长能组成啥单词，注意中间生成的字符串也要在字典中存在，而且当组成的单词长度相等时，返回字母顺序小的那个。 解法一可以借鉴查找的思想来做。那么为了快速的查找某个单词是否在字典中存在，我们将所有单词放到哈希集合中，在查找的时候，可以采用BFS或者DFS都行。先来看BFS的做法，使用一个queue来辅助，我们先把所有长度为1的单词找出排入queue中，当作种子选手，然后我们进行循环，每次从队首取一个元素出来，如果其长度大于我们维护的最大值mxLen，则更新mxLen和结果res，如果正好相等，也要更新结果res，取字母顺序小的那个。然后我们试着增加长度，做法就是遍历26个字母，将每个字母都加到单词后面，然后看是否在字典中存在，存在的话，就加入queue中等待下一次遍历，完了以后记得要恢复状态。 123456789101112131415161718192021222324252627class Solution &#123;public: string longestWord(vector&lt;string&gt;&amp; words) &#123; string res = &quot;&quot;; int mxLen = 0; unordered_set&lt;string&gt; s(words.begin(), words.end()); queue&lt;string&gt; q; for (string word : words) &#123; if (word.size() == 1) q.push(word); &#125; while (!q.empty()) &#123; string t = q.front(); q.pop(); if (t.size() &gt; mxLen) &#123; mxLen = t.size(); res = t; &#125; else if (t.size() == mxLen) &#123; res = min(res, t); &#125; for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; ++c) &#123; t.push_back(c); if (s.count(t)) q.push(t); t.pop_back(); &#125; &#125; return res; &#125;&#125;; 解法二首先建立一个空的哈希set，然后我们直接遍历排序后的字典，对于当前的单词，如果当前单词长度为1，或者该单词去掉最后一个字母后在集合中存在，这也不难理解，长度为1，说明是起始单词，不需要的多余的判断，否则的话就要判断其去掉最后一个字母后的单词是否在集合中存在，存在的话，才说明其中间单词都存在，因为此时是从短单词向长单词遍历，只要符合要求的才会加入集合，所以一旦其去掉尾字母的单词存在的话，那么其之前所有的中间情况都会在集合中存在。我们更新结果res时，要判断当前单词长度是否大于结果res的长度，因为排序过后，默认先更新的字母顺序小的单词，所有只有当当前单词长度大，才更新结果res，之后别忘了把当前单词加入集合中。 123456789101112131415class Solution &#123;public: string longestWord(vector&lt;string&gt;&amp; words) &#123; string res = &quot;&quot;; unordered_set&lt;string&gt; s; sort(words.begin(), words.end()); for (string word : words) &#123; if (word.size() == 1 || s.count(word.substr(0, word.size() - 1))) &#123; res = (word.size() &gt; res.size()) ? word : res; s.insert(word); &#125; &#125; return res; &#125;&#125;; 解法三1234567891011121314151617181920212223242526272829class Solution &#123; public String longestWord(String[] words) &#123; //给定字符串数组，找出包含最长的字符串（包含其他单词的字母），如果存在相同长度，取字母排序小的 //思路：对数组排序，再利用Set对字母存储，小的单词一定包含在后面大的单词里面。后面只需要取前缀相同的 Set&lt;String&gt; set=new HashSet&lt;String&gt;(); for(int i=0;i&lt;words.length;i++)&#123; set.add(words[i]); &#125; int length=0; String word=&quot;&quot;; for(int i=0;i&lt;words.length;i++)&#123; if(words[i].length()&gt;length||(words[i].length()==length&amp;&amp;words[i].compareTo(word)&lt;0))&#123; //如果存在相同长度的字符串，取字母排序较小的 int len=words[i].length(); while(len&gt;0&amp;&amp;set.contains(words[i].substring(0,len)))&#123; //求相同的部分 len--; &#125; if(len==0)&#123; //说明该单词的所有字符串均为公共字母,将其标记为匹配串 length=words[i].length(); word=words[i]; &#125; &#125; &#125; return word; &#125; &#125; 解法四思路：对数组排序，再利用Set对字母存储，小的单词一定包含在后面大的单词里面。后面只需要取前缀相同的 12345678910111213141516171819package com.leetcode.coding.arrays;import java.util.Arrays;import java.util.HashSet;public class LongestWord &#123; public static String longestWord(String[] words) &#123; Arrays.sort(words); HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); String res = &quot;&quot;; for(String s : words) &#123; if(s.length() == 1 || set.contains(s.substring(0, s.length()-1))) &#123; res = (s.length() &gt; res.length()) ? s:res; set.add(s); &#125; &#125; return res; &#125;&#125; 719. Find K-th Smallest Pair Distance题目描述https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/ Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. Example 1: 12345678910Input:nums = [1,3,1]k = 1Output: 0 Explanation:Here are all the pairs:(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2Then the 1tt smallest distance pair is (1,1), and its distance is 0. Note: 2 &lt;= len(nums) &lt;= 10000. 0 &lt;= nums[i] &lt; 1000000. 1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2. 解题思路第K小/大的问题，一般可以利用二分法解决 1234567891011121314151617181920212223242526272829import java.util.Arrays;public class KthSmallDistance &#123; public int kthSmallDistance(int[] nums, int k) &#123; Arrays.sort(nums); int l = 0; int h = nums[nums.length-1] -nums[0]; while(l &lt; h) &#123; int m = (l+h) / 2; // search //使用窗口思想，判断差值&lt;=k的个数， //r-l即表示[l,r]间间隔&lt;m的个数（每确定一个窗口就新增加了（r-l+1）- 1个差值对） int left = 0; int count = 0; for(int right = 0; right &lt; nums.length; right++) &#123; while(nums[right] - nums[left] &gt; m) &#123; left++; &#125; count += right - left; &#125; if(count&gt;=k) &#123; h = m; &#125; else &#123; l = m+1; &#125; &#125; return l; &#125;&#125; 718. Maximum Length of Repeated Subarray题目描述Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: 123456Input:A: [1,2,3,2,1]B: [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3, 2, 1]. Note: 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 解题思路解法一动态规划，需要知道状态转移方程。 12dp[i][j] = dp[i-1][j-1] + 1 if A[i] = B[j]dp[i][j] = 0 otherwise 贴上java代码 123456789101112131415161718192021222324252627public class MaxiLengthSubArray &#123; public static int findLength(int[] A, int[] B) &#123; int lenA = A.length, lenB = B.length; int max = 0; int[][] dp = new int[lenA+1][lenB+1]; for(int i = 1; i &lt;= lenA; i++) &#123; for(int j = 1; j &lt;= lenB; j++) &#123; if(A[i-1] == B[j-1]) &#123; dp[i][j] = dp[i-1][j-1]+1; max = dp[i][j] &gt; max ? dp[i][j] : max; &#125; &#125; &#125; return max; &#125; public static void main(String[] args) &#123; int[] A = &#123;3, 1, 2&#125;; int[] B = &#123;1, 2, 3&#125;; int[][] dp = findLength(A, B); for(int i = 0; i &lt;= A.length; i++) &#123; for(int j = 0; j &lt;= B.length; j++) &#123; System.out.print(dp[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 解法二从A串的结尾开始向前遍历，记当前pos为i。 对每一个i，从B串的开始开始遍历，记当前pos为j，用dp[j]表示以i位置开头的A子串和以j位置开头的B子串最长重复串的长度。 则在对B遍历时，若当前pos为j，则当前的dp[j+1]是上一次的结果，即以i+1位置开头的A子串和以j+1位置开头的B子串最长重复串的长度; 这时，若A[i]与B[j]相等，则dp[j] = dp[j+1] + 1，否则为0。 上述也是表示了为什么要从B串的开头开始循环：为了在计算pos j 时， dp[j+1]记录的时pos i 的数据。也即若A[i]与B[j]相等， dp[i][j] = dp[i+1][j+1] + 1。 考虑到边界情况，dp数组申请长度为B长度+1。 12345678910111213141516class Solution &#123;public: int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; int len1= A.size(), len2 = B.size(); if (!len1 || !len2) return 0; vector&lt;int&gt; dp(len2+1); int re = 0; for (int i = len1 - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; len2; j++) &#123; dp[j] = (A[i] == B[j])?(1 + dp[j+1]):0; re = max(re, dp[j]); &#125; &#125; return re; &#125;&#125;; 717. 1-bit and 2-bit Characters题目描述We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: 123456Input: bits = [1, 0, 0]Output: TrueExplanation: The only way to decode it is two-bit character and one-bit character.So the last character is one-bit character. Example 2: 123456Input: bits = [1, 1, 1, 0]Output: FalseExplanation: The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note: 1 &lt;= len(bits) &lt;= 1000. bits[i] is always 0 or 1. 解题思路给定数组中仅有0和1两种元素，且出现的元素组合只能有三种编码方式：10、11、0，判断给定的数组最后一个元素是否属于0编码，而不是10编码。 读清楚题目。 明白题目意图，就会发现，题目的意思是要判断最后一个0元素是属于0还是属于10； 遍历数组，给定指针，若当前位为1则指针+2；若当前位为0，则指针+1； 判断最后指针是否与bits.length-1相等，相等则为真，否则为假；其中length=1的情况也包括进去了。 12345678910111213class Solution &#123; public boolean isOneBitCharacter(int[] bits) &#123; int i = 0; while (i &lt; bits.length-1)&#123; if (bits[i] == 1)&#123; i += 2; &#125;else&#123; i++; &#125; &#125; return i == bits.length-1; &#125;&#125; 时间复杂度：O(n)，空间复杂度：O(1) 715. Range Module题目描述A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner. addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked. queryRange(int left, int right) Returns true if and only if every real number in the interval [left, right) is currently being tracked. removeRange(int left, int right) Stops tracking every real number currently being tracked in the interval [left, right). Example 1: 123456addRange(10, 20): nullremoveRange(14, 16): nullqueryRange(10, 14): true (Every number in [10, 14) is being tracked)queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation) Note: A half open interval [left, right) denotes all real numbers left &lt;= x &lt; right. 0 &lt; left &lt; right &lt; 10^9 in all calls to addRange, queryRange, removeRange. The total number of calls to addRange in a single test case is at most 1000. The total number of calls to queryRange in a single test case is at most 5000. The total number of calls to removeRange in a single test case is at most 1000. 解题思路解法一实现一个区间模型，可以实现插入，查询，删除区间的功能。 思路：使用treemap会对键值对升序排序的特征完成功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.leetcode.coding;import java.util.HashSet;import java.util.Map;import java.util.Set;import java.util.TreeMap;public class RangeModule &#123; TreeMap&lt;Integer, Integer&gt; map; public RangeModule() &#123; map = new TreeMap&lt;&gt;(); &#125; public void addRange(int left, int right) &#123; if(right &lt;= left) &#123; return ; &#125; Integer start = map.floorKey(left); Integer end = map.floorKey(right); // 如果当前的区间不存在重合的部分 if(start == null &amp;&amp; end == null) &#123; map.put(left, right); &#125; else if(start != null &amp;&amp; map.get(start) &gt;= left) &#123; map.put(start, Math.max(map.get(start), right)); &#125; else &#123; map.put(left, Math.max(map.get(end), right)); &#125; Map&lt;Integer, Integer&gt; subMap = map.subMap(left, false, right, true); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(subMap.keySet()); map.keySet().removeAll(set); &#125; public boolean queryRange(int left, int right) &#123; Integer start = map.floorKey(left); if(start == null) &#123; return false; &#125; return map.get(start) &gt;= right; &#125; public void removeRange(int left, int right) &#123; if(right &lt;= left) &#123; return ; &#125; Integer start = map.floorKey(left); Integer end = map.floorKey(right); if(end != null &amp;&amp; map.get(end) &gt; right) &#123; map.put(right, map.get(end)); &#125; if(start != null &amp;&amp; map.get(start) &gt; left) &#123; map.put(start, left); &#125; // clean up intermediate intervals Map&lt;Integer, Integer&gt; subMap = map.subMap(left, true, right, false); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(subMap.keySet()); map.keySet().removeAll(set); &#125;&#125; 解法二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758final int MAX_VALUE = 100000001; class Range implements Comparable&lt;Range&gt;&#123; int left, right; public Range(int left, int right) &#123; this.left = left; this.right = right; &#125; public int compareTo(Range another) &#123; if (left == another.left) &#123; return right - another.right; &#125; return left - another.left; &#125; public String toString() &#123; return &quot;Range(&quot; + left + &quot;,&quot; + right + &quot;)&quot;; &#125; &#125; private TreeSet&lt;Range&gt; ts; public RangeModule() &#123; ts = new TreeSet&lt;&gt;(); &#125; public void addRange(int left, int right) &#123; int nleft = left, nright = right; Range high = new Range(right, MAX_VALUE); while (true) &#123; Range r = ts.lower(high); if (r == null || r.right &lt; left) break; if (r.right &gt; right) &#123; nright = r.right; &#125; if (r.left &lt; left) &#123; nleft = r.left; &#125; ts.remove(r); &#125; ts.add(new Range(nleft, nright)); &#125; public boolean queryRange(int left, int right) &#123; Range target = ts.floor(new Range(left, MAX_VALUE)); return target != null &amp;&amp; target.left &lt;= left &amp;&amp; target.right &gt;= right; &#125; public void removeRange(int left, int right) &#123; Range high = new Range(right, right); while (true) &#123; Range r = ts.lower(high); if (r == null || r.right &lt;= left) break; if (r.right &gt; right) &#123; ts.add(new Range(right, r.right)); &#125; if (r.left &lt; left) &#123; ts.add(new Range(r.left, left)); &#125; ts.remove(r); &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"},{"name":"leetcode","slug":"leetcode","permalink":"http://zhangbuzola.cn/tags/leetcode/"}]},{"title":"leetcode 刷题1","slug":"leetcode-Array-1","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2017/12/15/leetcode-Array-1/","link":"","permalink":"http://zhangbuzola.cn/2017/12/15/leetcode-Array-1/","excerpt":"","text":"MyCalendar I题目描述Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking. Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation: The first event can be booked. The second can’t because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20. Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9]. 题目解析没有任何重叠部分 解题一123456789101112131415161718192021class MyCalendar &#123; private TreeMap&lt;Integer, Integer&gt; startMap; public MyCalendar() &#123; startMap = new TreeMap&lt;&gt;(); &#125; public boolean book(int start, int end) &#123; Integer nextStart = startMap.ceilingKey(start); if (nextStart != null &amp;&amp; nextStart &lt; end) &#123; return false; &#125; Integer prevStart = startMap.lowerKey(start); if(prevStart != null &amp;&amp; startMap.get(prevStart) &gt; start) &#123; return false; &#125; startMap.put(start, end); return true; &#125;&#125; 解题二利用插入排序求解。 123456789101112131415161718192021class MyCalendar &#123; private TreeMap&lt;Integer, Integer&gt; startMap; public MyCalendar() &#123; startMap = new TreeMap&lt;&gt;(); &#125; public boolean book(int start, int end) &#123; Integer nextStart = startMap.ceilingKey(start); if (nextStart != null &amp;&amp; nextStart &lt; end) &#123; return false; &#125; Integer prevStart = startMap.lowerKey(start); if(prevStart != null &amp;&amp; startMap.get(prevStart) &gt; start) &#123; return false; &#125; startMap.put(start, end); return true; &#125;&#125; 解法三利用BST二叉排序树，每个节点代表一个事件区间，如果要插入的部分全部在当前节点的左侧或者右侧，则左递归或者右递归，否则，插入失败。 12345678910111213141516171819202122232425262728293031323334353637383940class Node &#123; //节点有起始结束时间和左右子节点 public Node(int start, int end) &#123; l = start; r = end; &#125; int l, r; Node left, right; &#125; Node root = null; public boolean book(int start, int end) &#123; if (root == null) &#123; root = new Node(start, end); &#125; else &#123; Node cur = root; Node pre = null;//父节点 boolean leftTag = false;//记录该插入的节点是左子还是右子 while (cur != null) &#123; pre = cur; if (end &lt;= cur.l) &#123;//应该在当前节点的左侧，往左子递归 leftTag = true; cur = cur.left; &#125; else if (start &gt;= cur.r) &#123;//应该在当前节点的右侧，往右子递归 leftTag = false; cur = cur.right; &#125; else &#123;// 有重叠，不应该插入，返回false return false; &#125; &#125; if (leftTag) &#123;//根据tag确定是父亲的左子还是右子 pre.left = new Node(start, end); &#125; else &#123; pre.right = new Node(start, end); &#125; &#125; return true; &#125; MyCalendar II题目描述Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking. Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(50, 60); // returns true MyCalendar.book(10, 40); // returns true MyCalendar.book(5, 15); // returns false MyCalendar.book(5, 10); // returns true MyCalendar.book(25, 55); // returns true Explanation: The first two events can be booked. The third event can be double booked. The fourth event (5, 15) can’t be booked, because it would result in a triple booking. The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked. The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event; the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event. 题目解析My Calendar I: 无重叠 MyCalendar II: 三个区间不能有重叠部分，重叠部分区域最多两个。 解法一关键：保存重叠区域，用一个集合来专门存重叠区间，再用一个集合来存完整的区间。 先遍历专门存重叠区间的集合，因为能在这里出现的区间，都已经是出现两次了，如果当前新的区间跟重叠区间有交集的话，说明此时三个事件重叠了，直接返回false。如果当前区间跟重叠区间没有交集的话，那么再来遍历完整区间的集合，如果有交集的话，那么应该算出重叠区间并且加入放重叠区间的集合中。最后记得将新区间加入完整区间的集合中 贴上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.leetcode.coding.arrays;import java.util.Set;public class MyCalendarII &#123; private static Set&lt;Pair&gt; s1, s2; // s2 是s1的所有交集部分 /***/ public MyCalendarII() &#123; // TODO Auto-generated constructor stub &#125; public static boolean book(int s, int e) &#123; for (Pair set : s2) &#123; // 查看是否和s2有交集 if (s &gt;= set.getE() || e &lt;= set.getS()) &#123; // 没有任何交集，先走了或者后来来的 continue; &#125; else &#123; // 有交集 return false; &#125; &#125; for (Pair a : s1) &#123; if (s &gt;= a.getE() || e &lt;= a.getS())&#123; continue; &#125; else&#123; s2.add(new Pair(Math.max(s, a.getS()), Math.min(e, a.getE())));//将交集部分加入 &#125; &#125; s1.add(new Pair(s, e)); return true; &#125; private static Object Pair(int max, int min) &#123; // TODO Auto-generated method stub return null; &#125;&#125;Class Pair() &#123; public int s; public int e; public Pair(int s, int e) &#123; this.s = s; this.e = e; &#125; public int getS() &#123; return s; &#125; public void setS(int s) &#123; this.s = s; &#125; public int getE() &#123; return e; &#125; public void setE(int e) &#123; this.e = e; &#125; &#125; 解法二建立一个时间点和次数之间的映射，规定遇到起始时间点，次数加1，遇到结束时间点，次数减1。那么我们首先更改新的起始时间start和结束时间end的映射，start对应值增1，end对应值减1。然后定义一个变量cnt，来统计当前的次数。 用TreeMap保存所有事件开始及终止的位置以及它们的次数 123456789101112131415161718192021222324252627282930TreeMap&lt;Integer,Integer&gt; treeMap; public MyCalendarTwo() &#123; treeMap=new TreeMap&lt;&gt;(); &#125; public boolean book(int start, int end) &#123; int a=treeMap.getOrDefault(start,0); int b=treeMap.getOrDefault(end,0); treeMap.put(start,a+1); treeMap.put(end,b-1); int count=0; for (Integer val : treeMap.values()) &#123; count+=val;//记录当前已开始但未结束的事件个数 if(count&gt;2)&#123;//如果事件个数&gt;2，则说明有三个或者以上的重叠，不满足条件，要取消刚刚的插入 if(a==0)&#123;//如果插入前的个数为0则可以直接删除这条记录，否则对次数进行更改 treeMap.remove(start); &#125;else&#123; treeMap.put(start,a); &#125; if(b==0)&#123; treeMap.remove(end); &#125;else&#123; treeMap.put(end,b); &#125; return false; &#125; &#125; return true; &#125; 解题三123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.ArrayList;import java.util.HashMap;import java.util.Map;/** * 利用HashMap存储各区间端点被覆盖的次数，记为dmap * 利用List存储所有不triple booking的活动，记为events * 每次添加活动时，遍历events，判断当前活动与已存在活动是否发生冲突，并更新dmap * 将终点坐标减去0.5，与起点坐标做区分 * */public class MyCalendarII &#123; private Map&lt;Double, Integer&gt; dMap; private ArrayList&lt;int[]&gt; events; public MyCalendarII_1() &#123; dMap = new HashMap&lt;&gt;(); events = new ArrayList&lt;&gt;(); &#125; public boolean book(int start, int end) &#123; int cs = 1, ce = 1; for (int i = 0; i &lt; events.size(); i++) &#123; if (events.get(i)[0] &lt;= start &amp;&amp; events.get(i)[1] &gt; start) &#123; cs++; &#125; if (events.get(i)[0] &lt; end &amp;&amp; events.get(i)[1] &gt; end) &#123; ce++; &#125; &#125; if (cs &gt; 2 || ce &gt; 2) return false; ArrayList&lt;Double&gt; addList = new ArrayList&lt;&gt;(); for (double key : dMap.keySet()) &#123; if (start &lt;= key &amp;&amp; key &lt;= end - 0.5) &#123; if (dMap.get(key) == 2) return false; addList.add(key); &#125; &#125; for (Double key: addList) dMap.put(key, dMap.get(key) + 1); if (!dMap.containsKey(start)) &#123; dMap.put((double)start, cs); &#125; if (!dMap.containsKey(end - 0.5)) &#123; dMap.put(end - 0.5, ce); &#125; events.add(new int[]&#123;start, end&#125;); return true; &#125;&#125; 解题四和第一题一样使用BST，没有重叠的区间的节点操作类似第一题，但是对于有重叠区间的节点，要进行分裂，把lser,lsre,slre,sler四种情况总结起来就是中间两个值作为当前节点的起始和终止时间，且次数要增加，两侧分别进行左递归和右递归，次数根据lr还是se再外侧来决定。[selr分别为待插入的start,end，当前节点的left和right] 注意，次数不能简单的为1，对于分裂了lr的情况（如lser和lsre、sler），递归的时候次数可能要指定为当前节点的已有次数，而这个不是固定为1的。所以插入次数也要作为参数进行传递。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Node &#123;//节点有起始终止事件，左右子节点，这个时间区间的重叠次数 int left, right; int count; Node leftChild, rightChild; public Node(int l, int r, int c) &#123; left = l; right = r; count = c; &#125; &#125; int maxK = 1;//只要调用1次book，则最大记录至少为1，所以可以直接初始化为1 Node root; public int book(int start, int end) &#123; root = insert(root, start, end, 1); return maxK; &#125; private Node insert(Node root2, int start, int end, int c) &#123;//由于需要修改节点的链接关系，所以需要返回节点 if (start &gt;= end) &#123;// no need to take action return root2; &#125; if (root2 == null) &#123; root2 = new Node(start, end, c); return root2; &#125; int l = root2.left; int r = root2.right; if (end &lt;= l) &#123;//一定落在当前节点的左侧即左子树上，进行左递归 root2.leftChild = insert(root2.leftChild, start, end, c); &#125; else if (start &gt;= r) &#123; root2.rightChild = insert(root2.rightChild, start, end, c); &#125; else &#123; int[] a = new int[4];//给四个值排序 if (start &lt;= l) &#123; a[0] = start; a[1] = l; &#125; else &#123; a[0] = l; a[1] = start; &#125; if (end &lt;= r) &#123; a[2] = end; a[3] = r; &#125; else &#123; a[2] = r; a[3] = end; &#125; root2.left = a[1];//中间的两个值作为当前节点的值 root2.right = a[2]; root2.leftChild = insert(root2.leftChild, a[0], a[1], start &lt;= l ? c : root2.count);//左递归，如果start在外侧，则次数为c；如果l在外侧，则次数为当前节点的次数 root2.rightChild = insert(root2.rightChild, a[2], a[3], end &gt;= r ? c : root2.count); root2.count += c;//当前节点的次数要增加，并且根据大小情况选择性的更新maxK maxK = Math.max(maxK, root2.count); &#125; return root2; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"},{"name":"leetcode","slug":"leetcode","permalink":"http://zhangbuzola.cn/tags/leetcode/"}]},{"title":"imos累积和法","slug":"imos-累积和法","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2017/12/15/imos-累积和法/","link":"","permalink":"http://zhangbuzola.cn/2017/12/15/imos-累积和法/","excerpt":"","text":"imos方法imos是将累积和算法扩展到多次元和高次空间的方法，Kentaro Imajo将其用于高次元高次空间，在信号处理/图像处理领域取得了成就。 基本imos法例子你在经营一个咖啡厅，你的咖啡厅里每个客人在S_i时刻进店，E_i时刻出店。求店里最多有多少客人？（客人最多C个，时刻在T内。如果有多人同时进店出店，先算出店的人）。 朴素的解法朴素的思想是，计算每个时刻客户的数量，从中找出最大值。但是，复杂度是O(CT) 12345678910111213141516171819202122232425262728293031 #include &lt;iostream&gt; #include &lt;algorithm&gt;using namespace std; #define C 4 #define T 10// 每个客人的进入时间int S[C] = &#123; 1, 3, 5, 7 &#125;;// 每个客人的离开时间int E[C] = &#123; 2, 8, 6, 8 &#125;;// 店里的人数int table[T]; ///////////////////////////SubMain//////////////////////////////////int main(int argc, char *argv[])&#123; memset(table, 0, sizeof(table)); for (int i = 0; i &lt; C; i++) &#123; // 从时间 S[i] 到 E[i] - 1 店里人数计数加一 for (int j = S[i]; j &lt; E[i]; j++) &#123; table[j]++; &#125; &#125; // 找最大値 cout &lt;&lt; *max_element(table, table + T) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; imos法解法imos法的基本方向是，只统计出入店时刻的人数变化（我个人理解相当于求导），入店+1，出店-1。最终统计的时候，需要将每个时刻加上前一个时刻的统计量（我个人理解相当于求积分），其中的最大值就是所求。记录复杂度O(C)，累加复杂度O(T)，所以整体复杂度O(C+T)。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; #define C 4#define T 10// 每个客人的进入时间int S[C] = &#123; 1, 3, 5, 7 &#125;;// 每个客人的离开时间int E[C] = &#123; 2, 8, 6, 8 &#125;;// 店里的人数int table[T]; ///////////////////////////SubMain//////////////////////////////////int main(int argc, char *argv[])&#123; memset(table, 0, sizeof(table)); for (int i = 0; i &lt; C; i++) &#123; table[S[i]]++; // 入店+1 table[E[i]]--; // 出店-1 &#125; // 累加 for (int i = 1; i &lt; T; i++) &#123; table[i] += table[i - 1]; &#125; // 找最大値 cout &lt;&lt; *max_element(table, table + T) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 二次空间imos相对于朴素方法的一个优点就是随着次元增大复杂度的降低越明显。 例题你在玩一个抓怪兽的游戏，现在你面前是一张W*H的地图，地图里有N种怪物。怪物i只会在左下角为（B_i,C_i），右上角为(A_i,D_i)的矩形区域内出现。求单位区域内最多有多少种怪兽？ 朴素解法1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define W 6#define H 6#define N 4// 左下角坐标int B[N] = &#123;3,4,3,5,&#125;;int C[N] = &#123;0,1,2,2,&#125;;// 右上角坐标int A[N] = &#123;0,3,2,2,&#125;;int D[N] = &#123;3,2,3,5,&#125;;// 地图上的分布结果int tiles[H][W]; ///////////////////////////SubMain//////////////////////////////////int main(int argc, char *argv[])&#123; memset(tiles, 0, sizeof(tiles)); for (int i = 0; i &lt; N; i++) &#123; // 怪兽 i 出现的范围 [(A[i],C[i]), (B[i],D[i])) 内的计数加一 for (int y = C[i]; y &lt; D[i]; y++) &#123; for (int x = A[i]; x &lt; B[i]; x++) &#123; tiles[y][x]++; &#125; &#125; &#125; // 求最大値 cout &lt;&lt; *max_element(tiles[0], tiles[0] + H * W) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; imos解法矩形的左上角 (A[i],C[i]) +1 ，右上角 (A[i],D[i]) −1，左下角 (B[i],C[i]) −1 ，右下角(B[i],D[i]) +1 ，统计最终结果之前累加。加一减一 O(N)，累加(WH) 整体复杂度 O(N+WH) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define W 6#define H 6#define N 4// 左下角坐标int B[N] = &#123;3,4,3,5,&#125;;int C[N] = &#123;0,1,2,2,&#125;;// 右上角坐标int A[N] = &#123;0,3,2,2,&#125;;int D[N] = &#123;3,2,3,5,&#125;;// 地图上的分布结果int tiles[H][W]; ///////////////////////////SubMain//////////////////////////////////int main(int argc, char *argv[])&#123; memset(tiles, 0, sizeof(tiles)); // 影响力计算 (图 3) for (int i = 0; i &lt; N; i++) &#123; tiles[C[i]][A[i]]++; tiles[C[i]][B[i]]--; tiles[D[i]][A[i]]--; tiles[D[i]][B[i]]++; &#125; // 横向累积和 (图 4, 5) for (int y = 0; y &lt; H; y++) &#123; for (int x = 1; x &lt; W; x++) &#123; tiles[y][x] += tiles[y][x - 1]; &#125; &#125; // 纵向累积和 (图 6, 7) for (int y = 1; y &lt; H; y++) &#123; for (int x = 0; x &lt; W; x++) &#123; tiles[y][x] += tiles[y - 1][x]; &#125; &#125; cout &lt;&lt; *max_element(tiles[0], tiles[0] + H * W) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 结果图 转自 http://www.hankcs.com/program/algorithm/imos_method.html","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"}]},{"title":"mysql必知必会学习笔记二","slug":"mysql_must2","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/12/06/mysql_must2/","link":"","permalink":"http://zhangbuzola.cn/2017/12/06/mysql_must2/","excerpt":"","text":"创建计算字段 字段 字段和列的意思相同。 拼接字段123456789101112131415concat()函数：拼接两个列SELECT Concat(vend_name, &apos;(&apos;, vend_country, &apos;)&apos;) from vendors ORDER BY cend name;SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;) from vendors ORDER BY cend name;-- RTrim函数去掉值右边所有的空格-- 多数DBMS使用+或者||来实现拼接，mysql这使用concat函数来实现，当把sql语句转换成mysql语句时一定要把这个区别铭记于心result:Concat(vend_name, &apos;(&apos;,vend_country,&apos;)&apos;)ACME(USA) 1234SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;) AS vend_titleFROM vendors ORDER BY cend name;-- 使用别名 使用数据处理函数函数数据库相关的函数来处理数据 文本处理函数123SELECT vend_name, Upper(vend_name) AS vend_name_upcaseFROM vendorsORDER BY vend_name; 1234RTrim() 去掉串右边的空格Soundex() 返回串的SOUNDEX值SubString() 返回字串的字符Upper() 将串转换位大写 日期和时间处理函数数值处理函数汇总数据聚集函数12345AVG() 返回某列的平均值COUNT() 返回某列的行数MAX() 返回某列的最大值MIN() 返回某列的最小值SUM() 返回某列值之和 1SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id = 1003; 分组数据数据分组1SELECT COUNT(*) AS num_prods FROM products WHERE vend_id = 1003; 创建分组123456SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id;vend_id num_prods1001 21002 11003 7 过滤分组1HAVING 过滤分组 WHERE 过滤行 分组 排序1234SELECT order_num, SUM(quantity * item_price) AS ordertotal FROM orderitemsGROUP BY order_numHAVING SUM(quantity * item_price) &gt;= 50ORDER BY ordertotal; 使用子查询子查询subquery：嵌套子啊其他查询中的查询 12SELECT cust_id FROM orders WHERE order_num IN(SELECT order_num FROM orderitems WHERE prod_id = &apos; TNT2&apos;);","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangbuzola.cn/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangbuzola.cn/tags/MySQL/"}]},{"title":"数据结构之符号表 (算法第四版)","slug":"算法第四版3","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/12/05/算法第四版3/","link":"","permalink":"http://zhangbuzola.cn/2017/12/05/算法第四版3/","excerpt":"","text":"符号表这章的笔记是数据结构的部分，介绍一种抽象的数据结构，符号表以及它相关的API和实现方式 符号表：键-值，支持：插入和查找；key-value，添加(key,value)或者根据key查找value 符号表设计 应用 API 设计决策 泛型：不执行处理对象的类型 重复的键：每个键只对应着一个值，键不可以重复；插入重复的键时，新的值会替代旧的值 空键：键不能为空。 空值：值不能为空 删除操作 实现无序链表实现查找表 如图，当我们往链表中插入元素的时候，从表头开始查找，如果找到，则更新value，否则，在表头插入新的节点元素。以及还有二分查找有序表的操作 参考https://algs4.cs.princeton.edu/31elementary/","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhangbuzola.cn/categories/数据结构/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"}]},{"title":"数据结构之优先队列(算法第四版)","slug":"算法第四版2","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2017/12/04/算法第四版2/","link":"","permalink":"http://zhangbuzola.cn/2017/12/04/算法第四版2/","excerpt":"","text":"优先队列优先队列在实际生活很常见，对于一些任务，通常按照优先级情况进行先后处理，级别越高的优先处理 定义优先队列和一般的队列、栈一样，只不过每个元素都有一个优先级，在处理的时候，优先处理级别最高，级别相同，则按插入顺序处理。 支持：删除最大元素和插入元素，这两个操作是优先队列最重要的操作。 优先队列可用数组，链表，堆或者其他数据结构实现。书中使用二叉堆数据结构的一种优先队列的典型实现方式。 实现API 数组实现(无序或者有序) 无序数组每一次插入的时候，直接在末尾插入即可，时间复杂度O(1)，但是如果是最大值或者最小值，需要O(n) 有序数组插入时间复杂度O(n)， 查询最大值和最小值O(1) 所以采用普通的数组或者链表实现，无法使得插入和排序都达到比较好的时间复杂度。所以我们需要采用新的数据结构来实现。下面就开始介绍如何采用二叉堆(binary heap)来实现优先级队列 参考http://www.cnblogs.com/yangecnu/p/Introduce-Priority-Queue-And-Heap-Sort.html","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhangbuzola.cn/categories/数据结构/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"}]},{"title":"剑指offer之解题3","slug":"剑指offer-1","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2017/12/03/剑指offer-1/","link":"","permalink":"http://zhangbuzola.cn/2017/12/03/剑指offer-1/","excerpt":"","text":"48 不用加减乘除做加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 输入： 5 7 输出： 5 + 7 = 12 解题思路分3个步骤： 个位数相加不进位 做进位 把前两步得到的结果加起来就ok了 12345678910111213141516171819202122232425public class SpecialSumforIntegerSolution &#123; public static int add(int n, int m) &#123; int s, k; do &#123; s = n ^ m; k = (n &amp; m) &lt;&lt; 1; n = s; m = k; System.out.println(s + &quot; &quot; + k); &#125; while (m != 0); return n; &#125; public static void main(String[] args) &#123; int s = add(86, 12); System.out.println(s); &#125;&#125;/ *** 90 8* 82 16* 66 32* 98 0* 98** / 补充如果不用加减乘除的运算符号的话，就是位运算了。 位运算 这里复习一下java中的位运算 左移( &lt;&lt; )、右移( &gt;&gt; ) 、无符号右移( &gt;&gt;&gt; ) 、位与( &amp; ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。 左移( &lt;&lt; ) 123456789main() &#123; 5 &lt;&lt; 2 // 20&#125;java中整数默认是int类型，也就是32位0000 0000 0000 0000 0000 0000 0000 0101 然后左移2位后，低位补0：0000 0000 0000 0000 0000 0000 0001 0100 换算成10进制为20 右移( &gt;&gt; ) 1230000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：0000 0000 0000 0000 0000 0000 0000 0001 无符号右移 ( &gt;&gt;&gt; ) 知道在Java中int类型占32位，可以表示一个正数，也可以表示一个负数。正数换算成二进制后的最高位为0，负数的二进制最高为为1 例如 -5换算成二进制后为：补码表示 -5对应正数5（00000101）→所有位取反（11111010）→加1(11111011) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 1111 1111 1111 1111 1111 1111 1111 1011 (刚开始接触二进制时，不知道最高位是用来表示正负之分的，当时就总想不通。。明明算起来得到的就是一个正数-_-) 我们分别对5进行右移3位、 -5进行右移3位和无符号右移3位： 1234567public class Test &#123; public static void main(String[] args) &#123; System.out.println(5&gt;&gt;3);//结果是0 System.out.println(-5&gt;&gt;3);//结果是-1 System.out.println(-5&gt;&gt;&gt;3);//结果是536870911 &#125; &#125; -5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011 -5右移3位后结果为-1，-1的二进制为： 1111 1111 1111 1111 1111 1111 1111 1111 // (用1进行补位) -5无符号右移3位后的结果 536870911 换算成二进制： 0001 1111 1111 1111 1111 1111 1111 1111 // (用0进行补位) 位与&amp; 或| 位异或 ^ 位非~ 49 把字符串转换成整数题目描述将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 输入描述: 输入一个字符串,包括数字字母符号,可以为空 输出描述: 如果是合法的数值表达则返回该数字，否则返回0 示例1 输入 +2147483647 1a33 输出 2147483647 0 解题思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class StrtoInt &#123; /** * 可能的输入： * 1 带符号数 * 2 无符号数 * 3 零 * 4 空指针 * 5 超出表示范围 – 暂时仅仅是直接退出且设置最小 – 可以考虑此时抛个异常 * 6 非法输入，比如并不是一个0-9或者+ -组成的字符串 – 对于非法输入一律返回的是Integer.MIN_VALUE * */ public static long strToIntegerSolution(String str) &#123; // 判断输入是否合法 if(str == null) &#123; return Long.MAX_VALUE; &#125; if(str.length() == 0) &#123; return 0; &#125; for(int i = 0; i &lt; str.length(); i++) &#123; if(!judge(str.charAt(i))) &#123; return Long.MIN_VALUE; &#125; &#125; char chars[] = str.toCharArray(); long result = 0; if(chars[0] == &apos;-&apos; || chars[0] == &apos;+&apos;) &#123; // 有符号数 result = trans(str.substring(1)); &#125; else &#123; // 无符号数 result = trans(str); &#125; if(result &gt; 0 &amp;&amp; chars[0] == &apos;-&apos;) &#123; result = -result; &#125; return result; &#125; public static long trans(String str)&#123; if(str.length() == 0) return 0; long result = 0; for(int i=0; i&lt;str.length(); i++)&#123; result = result*10 + (str.charAt(i)-&apos;0&apos;); if(result &gt; Long.MAX_VALUE)&#123; result = Long.MIN_VALUE; break; &#125; &#125; return result; &#125; public static boolean judge(char c)&#123; if(c == &apos;-&apos; || c == &apos;+&apos;) return true; if(c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) return true; return false; &#125; public static void main(String[] args) &#123; String str1 = &quot;123456&quot;; String str2 = &quot;-123456&quot;; String str3 = &quot;-6&quot;; String str4 = &quot;-&quot;; String str5 = &quot;+1&quot;; String str6 = &quot;+abc&quot;; String str7 = null; System.out.println(strToIntegerSolution(str1)); System.out.println(strToIntegerSolution(str2)); System.out.println(strToIntegerSolution(str3)); System.out.println(strToIntegerSolution(str4)); System.out.println(strToIntegerSolution(str5)); System.out.println(strToIntegerSolution(str6)); System.out.println(strToIntegerSolution(str7)); &#125;&#125; 51 数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。 解题思路1234567891011121314151617181920public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(numbers == null) &#123; return false; &#125; if(length != numbers.length) &#123; return false; &#125; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; length; i++) &#123; sb.append(&quot;#&quot;).append(a[i]).append(&quot;#&quot;); &#125; String string = sb.toString(); for(int i = 0; i &lt; length; i++) &#123; if(string.indexOf(&quot;#&quot;+a[i]+&quot;#&quot;) != string.lastIndexOf(&quot;#&quot;+a[i]+&quot;#&quot;)) &#123; duplication[0] = a[i]; return true; &#125; &#125; return false; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://zhangbuzola.cn/tags/剑指offer/"}]},{"title":"数据结构之背包队列和栈(算法第四版)","slug":"算法第四版1","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2017/12/03/算法第四版1/","link":"","permalink":"http://zhangbuzola.cn/2017/12/03/算法第四版1/","excerpt":"","text":"背包、队列和栈泛型集合类的抽象数据类型：任意类型的数据 泛型(参数化类型): 任意数据类型 可迭代的集合类型 背包不支持从中删除元素的集合数据类型，帮助用例手机元素并迭代所有收集到的元素，迭代的顺序不确定 队列先进先出队列：基于先进先出的队列 栈下压栈： 后进先出 12345678910111213141516171819Bag public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; Bag() // create an empty bag boolean add(Item item) // add an item boolean isEmpty() // is the bag empty int size() // number of items in the bagFIFO queue public class Queue(Item) implements Iterable&lt;Item&gt; Queue() // create an empty queue void enqueue(Item item) // add an item boolean isEmpty() // is the queue empty int size) // number of items in the queuePushdown(LIFO) stack public calss Stack&lt;Item&gt; implements Iterable&lt;Item&gt; Stack() // create an empty stack void push(Item item) // add an item Item pop() // remove an item recently added item boolean isEmpty() // is the stack empty int size() // number of items in the queue ### 链表节点记录123456private class Node &#123; Item item; Node next;&#125;private Node fist = null;private int number = 0; 构造链表 链表头插入insert at the beginning:链表头插入元素 链表头删除元素 队尾插入元素 遍历123for(Node x = first; x != null; x = x.next) &#123; // process x.item&#125; 复杂度参考http://www.cnblogs.com/yangecnu/p/Introduction-Stack-and-Queue.html","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhangbuzola.cn/categories/数据结构/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"}]},{"title":"java基础学习之Object类","slug":"javabase_Object","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2017/12/01/javabase_Object/","link":"","permalink":"http://zhangbuzola.cn/2017/12/01/javabase_Object/","excerpt":"","text":"Object类基本说明 Object类位于java.lang包，java.lang包包含着java最基础和核心的类。在编译的时候会自动导入。 Object类是所有java类的祖先。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package java.lang;public class Object &#123; /*一个本地方法,具体是用C(C++)在DLL中实现的,然后通过JNI调用*/ private static native void registerNatives(); /*对象初始化时自动调用此方法*/ static &#123; registerNatives(); &#125; /*返回此Object的运行时类型*/ public final native Class&lt;?&gt; getClass(); /* hashCode的常规协定是： 1.在java应用程序执行期间,在对同一对象多次调用hashCode()方法时, 必须一致地返回相同的整数,前提是将对象进行equals比较时所用的信息没有被修改. 从某一应用程序的一次执行到同一应用程序的另一次执行,该整数无需保持一致。 2.如果根据equals(object)方法,两个对象是相等的, 那么对这两个对象中的每个对象调用hashCode方法都必须生成相同的整数结果。 3.如果根据equals(java.lang.Object)方法,两个对象不相等, 那么对这两个对象中的任一对象上调用hashCode()方法不要求一定生成不同的整数结果。 4.一般必须满足obj1.equals(obj2)==true。 可以推出obj1.hash-Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。 不过为了提高效率，应该尽量使上面两个条件接近等价。 但是,程序员应该意识到,为不相等的对象生成不同整数结果可以提高哈希表的性能。 */ public native int hashCode(); /*这里比较的是对象的内存地址,跟String.equals方法不同,它比较的只是对象的值*/ public boolean equals(Object obj) &#123; return (this == obj); &#125; /*本地clone方法,用于对象的复制*/ protected native Object clone() throws CloneNotSupportedException; /* 返回该对象的字符串表示,非常重要的方法 getClass().getName();获取字节码文件的对应全路径名例如java.lang.Object Integer.toHexString(hashCode());将哈希值转成16进制数格式的字符串。 */ public String toString()&#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; /*唤醒在此对象监视器上等待的单个线程*/ public final native void notity(); /*唤醒在此对象监视器上等待的所有线程*/ public final native void notifyAll(); /* 在其他线程调用此对象的notify()方法或notifyAll()方法前,导致当前线程等待。 换句话说,此方法的行为就好像它仅执行wait(0)调用一样。 当前线程必须拥有此对象监视器。 该线程发布对此监视器的所有权并等待,直到其他线程通过调用notify方法或notifyAll方法通知在此对象的监视器上等待的线程醒来, 然后该线程将等到重新获得对监视器的所有权后才能继续执行。 */ public final void wait() throws InterruptedException()&#123; wait(0); &#125; /*在其他线程调用此对象的notify()方法或notifyAll()方法, 或者超过指定的时间量前,导致当前线程等待*/ public final native void wait(long timeout) throws InterruptedException; public final void wait() throws InterruptedException &#123; if(timeout &lt; 0)&#123; throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; //nanos不能大于等于1000000ms也就是1000s if(nanos &lt; 0 || nanos &gt; 999999)&#123; throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;); &#125; // if(nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0))&#123; timeout++; &#125; wait(timeout); &#125; /*当垃圾回收期确定不存在对该对象的更多引用时,由对象的垃圾回收器调用此方法。*/ protected void finalize() throws Throwable&#123;&#125;&#125; 方法解释clone Object类的clone()方法是一个native方法，native方法的效率一般来说都是远高于Java中的非native方法。这也解释了为什么要用Object中clone()方法而不是先new一个类，然后把原始对象中的信息复制到新对象中，虽然这也实现了clone功能。 Object类中的 clone()方法被protected修饰符修饰。这也意味着如果要应用 clone()方 法，必须继承Object类。 Object.clone()方法返回一个Object对象。我们必须进行强制类型转换才能得到我们需要的类型。 克隆的步骤： 创建一个对象； 将原有对象的数据导入到新创建的数据中。 clone方法首先会判对象是否实现了Cloneable接口，若无则抛出CloneNotSupportedException, 最后会调用internalClone. intervalClone是一个native方法，一般来说native方法的执行效率高于非native方法。 https://www.cnblogs.com/myseries/p/7435395.htmls equal所有类都从Object类中继承了equals方法 Object中的equals方法是直接判断this和obj本身的值是否相等，即用来判断调用equals的对象和形参obj所引用的对象是否是同一对象，所谓同一对象就是指内存中同一块存储单元，如果this和obj指向的hi同一块内存对象，则返回true,如果this和obj指向的不是同一块内存，则返回false,注意：即便是内容完全相等的两块不同的内存对象，也返回false。如果是同一块内存，则object中的equals方法返回true,如果是不同的内存，则返回false 如果希望不同内存但相同内容的两个对象equals时返回true,则我们需要重写父类的equal方法 String类已经重写了object中的equals方法。 hashCodehashCode：根据一定的规则将与对象相关的信息映射成一个数值，这个数值就是散列值（hash值） 为什么会用到hashCode呢？当向集合中添加元素，添加之前需要待插入元素是否已经存在集合中，一般正常是可以使用euqal方法去进行挨个比较，但是考虑到当数据量很大的时候，equal方法就不高效了。大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值。实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。 finalizefinalize()方法：垃圾回收器准备释放内存的时候，会先调用finalize()。 对象不一定会被回收。 垃圾回收不是析构函数。 垃圾回收只与内存有关。 垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"},{"name":"Object","slug":"Object","permalink":"http://zhangbuzola.cn/tags/Object/"}]},{"title":"MySQL安装问题","slug":"mysql_install","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/11/29/mysql_install/","link":"","permalink":"http://zhangbuzola.cn/2017/11/29/mysql_install/","excerpt":"","text":"mysql安装过程总结估计我这辈子安装最多次的软件就是mysql吧，咬牙把自己安装过程中遇到的问题总结一下，随带把安装过程编辑一下，后续可以参看。不想再重装了。 安装过程各种问题 mysql 版本下载问题 官网下载，官网下载，官网下载，官网下载，官网下载，官网下载，官网下载，官网下载（虽然官网显示的是32位的，只要下载就好了，会有64位版本的供你选择。）不要自己google，会出现各种你不知所以的版本，再就是版本过老，安装过程不一样的。 navicat软件报错以后，mysql就启动不了了 mysql 卸载遇到的问题 ![] (/assets/images/mysql_5.png) 下面是解决的办法，我这边是没有解决的，就这样留着他了。因为重装以后还是可以用mysql，就没有管了。但还是贴上解决的方案吧。 Connector/Net 6.9.3无法卸载Go to the path where the msi of Connector/Net 6.9.3 is saved. type this: msiexec -x mysql-connector-net-6.9.3.msi /lvx* c:\\log.txt mysql 安装路径的问题 有的可以选择有的不可以","categories":[{"name":"工具","slug":"工具","permalink":"http://zhangbuzola.cn/categories/工具/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangbuzola.cn/tags/MySQL/"}]},{"title":"java基础之synchronized关键字","slug":"java基础之synchronized","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/11/28/java基础之synchronized/","link":"","permalink":"http://zhangbuzola.cn/2017/11/28/java基础之synchronized/","excerpt":"","text":"synchronized线程安全是并发编程中的重要关注点，应该注意到的是，造成线程安全问题的主要诱因有两点，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。因此为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能），这点确实也是很重要的。 synchronized的三种应用方式synchronized关键字最主要有以下3种应用方式，下面分别介绍 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 synchronized作用于实例方法所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是实例方法不包括静态方法，如下 12345678910111213141516171819202122232425262728293031public class AccountingSync implements Runnable&#123; //共享资源(临界资源) static int i=0; /** * synchronized 修饰实例方法 */ public synchronized void increase()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; AccountingSync instance=new AccountingSync(); Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125; /** * 输出结果: * 2000000 */&#125; 上述代码中，我们开启两个线程操作同一个共享资源即变量i，由于i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。此时我们应该注意到synchronized修饰的是实例方法increase，在这样的情况下，当前线程的锁便是实例对象instance，注意Java中的线程同步锁可以是任意对象。从代码执行结果来看确实是正确的，倘若我们没有使用synchronized关键字，其最终输出结果就很可能小于2000000，这便是synchronized关键字的作用。这里我们还需要意识到，当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了，如下代码将演示出该现象 123456789101112131415161718192021222324public class AccountingSyncBad implements Runnable&#123; static int i=0; public synchronized void increase()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //new新实例 Thread t1=new Thread(new AccountingSyncBad()); //new新实例 Thread t2=new Thread(new AccountingSyncBad()); t1.start(); t2.start(); //join含义:当前线程A等待thread线程终止之后才能从thread.join()返回 t1.join(); t2.join(); System.out.println(i); &#125;&#125; 上述代码与前面不同的是我们同时创建了两个新实例AccountingSyncBad，然后启动两个不同的线程对共享变量i进行操作，但很遗憾操作结果是1452317而不是期望结果2000000，因为上述代码犯了严重的错误，虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。解决这种困境的的方式是将synchronized作用于静态的increase方法，这样的话，对象锁就当前类对象，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。下面我们看看如何使用将synchronized作用于静态的increase方法。 synchronized作用于静态方法当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁，看如下代码 123456789101112131415161718192021222324252627282930313233343536public class AccountingSyncClass implements Runnable&#123; static int i=0; /** * 作用于静态方法,锁是当前class对象,也就是 * AccountingSyncClass类对应的class对象 */ public static synchronized void increase()&#123; i++; &#125; /** * 非静态,访问时锁不一样不会发生互斥 */ public synchronized void increase4Obj()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //new新实例 Thread t1=new Thread(new AccountingSyncClass()); //new心事了 Thread t2=new Thread(new AccountingSyncClass()); //启动线程 t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); &#125;&#125; 由于synchronized关键字修饰的是静态increase方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的increase4Obj方法是实例方法，其对象锁是当前实例对象，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题(操作了共享静态变量i)。 synchronized同步代码块除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下： 123456789101112131415161718192021public class AccountingSync implements Runnable&#123; static AccountingSync instance=new AccountingSync(); static int i=0; @Override public void run() &#123; //省略其他耗时操作.... //使用同步代码块对变量i进行同步操作,锁对象为instance synchronized(instance)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); &#125;&#125; 从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码： 12345678910111213//this,当前实例对象锁synchronized(this)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125;&#125;//class对象锁synchronized(AccountingSync.class)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125;&#125; 了解完synchronized的基本含义及其使用方式后，下面我们将进一步深入理解synchronized的底层实现原理。 synchronized底层语义原理Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。 理解Java对象头与Monitor在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下： 实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。 而对于顶部，则是Java头对象，它实现synchronized的锁对象的基础，这点我们重点分析它，一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下表： 虚拟机位数|头对象结构|说明|–|–|32/64bit|Mark Word|存储对象的hashCode、锁信息或分代年龄或GC标志等信息32/64bit|Class Metadata Address|类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构 锁状态|25bit|4bit|1bit是否是偏向锁|2bit 锁标志位|–|–|无锁状态|对象HashCode|对象分代年龄|0 |01 由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构： 其中轻量级锁和偏向锁是Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的） 123456789101112131415161718ObjectMonitor() &#123; _header = NULL; _count = 0; //记录个数 _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; //处于wait状态的线程，会被加入到_WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; //处于等待锁block状态的线程，会被加入到该列表 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; &#125; ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示 由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)，ok~，有了上述知识基础后，下面我们将进一步分析synchronized在字节码层面的具体语义实现。 synchronized代码块底层原理现在我们重新定义一个synchronized修饰的同步代码块，在代码块中操作共享变量i，如下 1234567891011public class SyncCodeBlock &#123; public int i; public void syncTask()&#123; //同步代码库 synchronized (this)&#123; i++; &#125; &#125;&#125; 编译上述代码并使用javap反编译后得到字节码如下(这里我们省略一部分没有必要的信息)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncCodeBlock.class Last modified 2017-6-2; size 426 bytes MD5 checksum c80bc322c87b312de760942820b4fed5 Compiled from &quot;SyncCodeBlock.java&quot;public class com.zejian.concurrencys.SyncCodeBlock minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: //........省略常量池中数据 //构造函数 public com.zejian.concurrencys.SyncCodeBlock(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 7: 0 //===========主要看看syncTask方法实现================ public void syncTask(); descriptor: ()V flags: ACC_PUBLIC Code: stack=3, locals=3, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter //注意此处，进入同步方法 4: aload_0 5: dup 6: getfield #2 // Field i:I 9: iconst_1 10: iadd 11: putfield #2 // Field i:I 14: aload_1 15: monitorexit //注意此处，退出同步方法 16: goto 24 19: astore_2 20: aload_1 21: monitorexit //注意此处，退出同步方法 22: aload_2 23: athrow 24: return Exception table: //省略其他字节码.......&#125;SourceFile: &quot;SyncCodeBlock.java&quot; 我们主要关注字节码中的如下代码 1234563: monitorenter //进入同步方法//..........省略其他 15: monitorexit //退出同步方法16: goto 24//省略其他.......21: monitorexit //退出同步方法 从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。 synchronized方法底层原理方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现： 12345678public class SyncMethod &#123; public int i; public synchronized void syncTask()&#123; i++; &#125;&#125; 使用javap反编译后的字节码如下： 123456789101112131415161718192021222324252627282930Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncMethod.class Last modified 2017-6-2; size 308 bytes MD5 checksum f34075a8c059ea65e4cc2fa610e0cd94 Compiled from &quot;SyncMethod.java&quot;public class com.zejian.concurrencys.SyncMethod minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool; //省略没必要的字节码 //==================syncTask方法====================== public synchronized void syncTask(); descriptor: ()V //方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法 flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=3, locals=1, args_size=1 0: aload_0 1: dup 2: getfield #2 // Field i:I 5: iconst_1 6: iadd 7: putfield #2 // Field i:I 10: return LineNumberTable: line 12: 0 line 13: 10&#125;SourceFile: &quot;SyncMethod.java&quot; 从字节码中可以看出，synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是synchronized锁在同步代码块和同步方法上实现的基本原理。同时我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。 Java虚拟机对synchronized的优化锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。 偏向锁偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。 轻量级锁倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。 自旋锁轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。 锁消除消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。 12345678910111213141516171819202122/** * Created by zejian on 2017/6/4. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] * 消除StringBuffer同步锁 */public class StringBufferRemoveSync &#123; public void add(String str1, String str2) &#123; //StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用 //因此sb属于不可能共享的资源,JVM会自动消除内部的锁 StringBuffer sb = new StringBuffer(); sb.append(str1).append(str2); &#125; public static void main(String[] args) &#123; StringBufferRemoveSync rmsync = new StringBufferRemoveSync(); for (int i = 0; i &lt; 10000000; i++) &#123; rmsync.add(&quot;abc&quot;, &quot;123&quot;); &#125; &#125;&#125; 关于synchronized 可能需要了解的关键点synchronized的可重入性从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。如下： 1234567891011121314151617181920212223242526272829public class AccountingSync implements Runnable&#123; static AccountingSync instance=new AccountingSync(); static int i=0; static int j=0; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; //this,当前实例对象锁 synchronized(this)&#123; i++; increase();//synchronized的可重入性 &#125; &#125; &#125; public synchronized void increase()&#123; j++; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); &#125;&#125; 正如代码所演示的，在获取当前实例对象锁后进入synchronized代码块执行同步代码，并在代码块中调用了当前实例对象的另外一个synchronized方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现，需要特别注意另外一种情况，当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。 线程中断与synchronized线程中断正如中断二字所表达的意义，在线程运行(run方法)中间打断它，在Java中，提供了以下3个有关线程中断的方法 12345678//中断线程（实例方法）public void Thread.interrupt();//判断线程是否被中断（实例方法）public boolean Thread.isInterrupted();//判断是否被中断并清除当前中断状态（静态方法）public static boolean Thread.interrupted(); 当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用Thread.interrupt()方式中断该线程，注意此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，如下代码将演示该过程： 12345678910111213141516171819202122232425262728293031public class InterruputSleepThread3 &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; //while在try中，通过异常中断就可以退出run循环 try &#123; while (true) &#123; //当前线程处于阻塞状态，异常必须捕捉处理，无法往外抛出 TimeUnit.SECONDS.sleep(2); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(&quot;Interruted When Sleep&quot;); boolean interrupt = this.isInterrupted(); //中断状态被复位 System.out.println(&quot;interrupt:&quot;+interrupt); &#125; &#125; &#125;; t1.start(); TimeUnit.SECONDS.sleep(2); //中断处于阻塞状态的线程 t1.interrupt(); /** * 输出结果: Interruted When Sleep interrupt:false */ &#125;&#125; 如上述代码所示，我们创建一个线程，并在线程中调用了sleep方法从而使用线程进入阻塞状态，启动线程后，调用线程实例对象的interrupt方法中断阻塞异常，并抛出InterruptedException异常，此时中断状态也将被复位。这里有些人可能会诧异，为什么不用Thread.sleep(2000);而是用TimeUnit.SECONDS.sleep(2);其实原因很简单，前者使用时并没有明确的单位说明，而后者非常明确表达秒的单位，事实上后者的内部实现最终还是调用了Thread.sleep(2000);，但为了编写的代码语义更清晰，建议使用TimeUnit.SECONDS.sleep(2);的方式，注意TimeUnit是个枚举类型。ok~，除了阻塞中断的情景，我们还可能会遇到处于运行期且非阻塞的状态的线程，这种情况下，直接调用Thread.interrupt()中断线程是不会得到任响应的，如下代码，将无法中断非阻塞状态下的线程： 1234567891011121314151617181920212223public class InterruputThread &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1=new Thread()&#123; @Override public void run()&#123; while(true)&#123; System.out.println(&quot;未被中断&quot;); &#125; &#125; &#125;; t1.start(); TimeUnit.SECONDS.sleep(2); t1.interrupt(); /** * 输出结果(无限执行): 未被中断 未被中断 未被中断 ...... */ &#125;&#125; 虽然我们调用了interrupt方法，但线程t1并未被中断，因为处于非阻塞状态的线程需要我们手动进行中断检测并结束程序，改进后代码如下： 123456789101112131415161718192021222324252627public class InterruputThread &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1=new Thread()&#123; @Override public void run()&#123; while(true)&#123; //判断当前线程是否被中断 if (this.isInterrupted())&#123; System.out.println(&quot;线程中断&quot;); break; &#125; &#125; System.out.println(&quot;已跳出循环,线程中断!&quot;); &#125; &#125;; t1.start(); TimeUnit.SECONDS.sleep(2); t1.interrupt(); /** * 输出结果: 线程中断 已跳出循环,线程中断! */ &#125;&#125; 是的，我们在代码中使用了实例方法isInterrupted判断线程是否已被中断，如果被中断将跳出循环以此结束线程,注意非阻塞状态调用interrupt()并不会导致中断状态重置。综合所述，可以简单总结一下中断两种情况，一种是当线程处于阻塞状态或者试图执行一个阻塞操作时，我们可以使用实例方法interrupt()进行线程中断，执行中断操作后将会抛出interruptException异常(该异常必须捕捉无法向外抛出)并将中断状态复位，另外一种是当线程处于运行状态时，我们也可调用实例方法interrupt()进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码(其实就是结束run方法体的代码)。有时我们在编码时可能需要兼顾以上两种情况，那么就可以如下编写： 12345678910public void run()&#123; try &#123; //判断当前线程是否已中断,注意interrupted方法是静态的,执行后会对中断状态进行复位 while (!Thread.interrupted()) &#123; TimeUnit.SECONDS.sleep(2); &#125; &#125; catch (InterruptedException e) &#123; &#125;&#125; 中断与synchronized事实上线程的中断操作对于正在等待获取的锁对象的synchronized方法或者代码块并不起作用，也就是对于synchronized来说，如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效。演示代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Created by zejian on 2017/6/2. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */public class SynchronizedBlocked implements Runnable&#123; public synchronized void f() &#123; System.out.println(&quot;Trying to call f()&quot;); while(true) // Never releases lock Thread.yield(); &#125; /** * 在构造器中创建新线程并启动获取对象锁 */ public SynchronizedBlocked() &#123; //该线程已持有当前实例锁 new Thread() &#123; public void run() &#123; f(); // Lock acquired by this thread &#125; &#125;.start(); &#125; public void run() &#123; //中断判断 while (true) &#123; if (Thread.interrupted()) &#123; System.out.println(&quot;中断线程!!&quot;); break; &#125; else &#123; f(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; SynchronizedBlocked sync = new SynchronizedBlocked(); Thread t = new Thread(sync); //启动后调用f()方法,无法获取当前实例锁处于等待状态 t.start(); TimeUnit.SECONDS.sleep(1); //中断线程,无法生效 t.interrupt(); &#125;&#125; 我们在SynchronizedBlocked构造函数中创建一个新线程并启动获取调用f()获取到当前实例锁，由于SynchronizedBlocked自身也是线程，启动后在其run方法中也调用了f()，但由于对象锁被其他线程占用，导致t线程只能等到锁，此时我们调用了t.interrupt();但并不能中断线程。 等待唤醒机制与synchronized所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。 12345synchronized (obj) &#123; obj.wait(); obj.notify(); obj.notifyAll(); &#125; 需要特别理解的一点是，与sleep方法不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法只让线程休眠并不释放锁。同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁。 参考https://blog.csdn.net/javazejian/article/details/72828483","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之多线程二","slug":"java基础之多线程二","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/11/28/java基础之多线程二/","link":"","permalink":"http://zhangbuzola.cn/2017/11/28/java基础之多线程二/","excerpt":"","text":"先来实例多线程写日志，涉及到单例模式，异步写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; Thread t1 = new Thread(Working); t1.Name = &quot;Thread1&quot;; Thread t2 = new Thread(Working); t2.Name = &quot;Thread2&quot;; Thread t3 = new Thread(Working); t3.Name = &quot;Thread3&quot;; // 依次启动3个线程。 t1.Start(); t2.Start(); t3.Start(); Console.ReadKey(); &#125; // 每个线程都同时在工作 static void Working() &#123; // 模拟1000次写日志操作 for (int i = 0; i &lt; 1000; i++) &#123; // 异步写文件 logger.Write(Thread.CurrentThread.Name + &quot; writes a log: &quot; + i + &quot;, on &quot; + DateTime.Now.ToString() + &quot;.\\n&quot;); &#125;// 做一些其它的事件 for (int i = 0; i &lt; 100; i++) &#123; &#125; &#125; &#125; public class logger &#123; private Queue&lt;Action&gt; _queue; //写日志线程 private Thread _loggingThread; //信号器 private ManualResetEvent _hasNew; // 使用单例模式，保持一个Logger对象 private static readonly logger _logger = new logger(); private static logger GetInstance() &#123; /* 不安全代码 lock (locker) &#123; if (_logger == null) &#123; _logger = new Logger(); &#125; &#125;*/ return _logger; &#125; private logger() &#123; _queue = new Queue&lt;Action&gt;(); _hasNew = new ManualResetEvent(false); _loggingThread = new Thread(Process); _loggingThread.IsBackground = true; _loggingThread.Start(); &#125; private void Process() &#123; while (true) &#123; //等待信号,阻塞线程 _hasNew.WaitOne(); //接收到信号，信号关闭，重置 _hasNew.Reset(); Thread.Sleep(100); Queue&lt;Action&gt; queueCopy; lock (_queue) &#123; queueCopy = new Queue&lt;Action&gt;(_queue); _queue.Clear(); &#125; foreach (var action in queueCopy) &#123; action(); &#125; &#125; &#125; private void WeiteLog(string content) &#123; lock (_queue) &#123; _queue.Enqueue(() =&gt; File.AppendAllText(&quot;log.txt&quot;, content)); &#125; _hasNew.Set(); &#125; public static void Write(string content) &#123; Task.Run(() =&gt; GetInstance().WeiteLog(content)); &#125; &#125;&#125; 并发和并行并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码： 1234void transferMoney(User from, User to, float amount)&#123; to.setMoney(to.getBalance() + amount); from.setMoney(from.getBalance() - amount);&#125; 同步同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。 线程状态 各种状态一目了然，值得一提的是”blocked”这个状态：线程在Running的过程中可能会遇到阻塞(Blocked)情况 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable） 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们 monitor他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 synchronized代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 12345678public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;&#125; 直接用于方法： 相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。 12345public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125; synchronized, wait, notify结合:典型场景生产者消费者问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;产品已满,请稍候再生产&quot;); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println(&quot;生产者生产第&quot; + this.product + &quot;个产品.&quot;); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;缺货,稍候再取&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println(&quot;消费者取走了第&quot; + this.product + &quot;个产品.&quot;); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125; volatile多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。 基本线程类指的是Thread类，Runnable接口，Callable接口 Thread 类实现了Runnable接口，启动一个线程的方法： 123456789101112MyThread my = new MyThread(); my.start();//当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）public static Thread.yield() //暂停一段时间public static Thread.sleep() //在一个线程中调用other.join(),将等待other执行完后才继续本线程。 public join()//后两个函数皆可以被打断public interrupte()关于中断：它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。Thread.interrupted()检查当前线程是否发生中断，返回boolean synchronized在获锁的过程中是不能被中断的。 中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体 Thread类最佳实践写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。 如何获取线程中的异常 不能用try,catch来获取线程中的异常Runnable与Thread类似Callable 实践开发中以上都属于内功心法，接下来是实际项目中常用到的工具了，Java1.5提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。 ThreadLocal类用处：保存线程的独立变量。对一个线程类（继承自Thread)当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。 实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。 主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。 原子类（AtomicInteger、AtomicBoolean……）如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized 12//返回值为booleanAtomicInteger.compareAndSet(int expect,int update) 该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为： 123456if(b.value.compareAndSet(old, value))&#123; return ;&#125;else&#123; //try again // if that fails, rollback and log&#125; AtomicReference对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号 Lock类lock: 在java.util.concurrent包内。共有三个实现： 123ReentrantLockReentrantReadWriteLock.ReadLockReentrantReadWriteLock.WriteLock 主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。 区别如下： lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序） 提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。 本质上和监视器锁（即synchronized是一样的）能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。 和Condition类的结合。性能更高。synchronized和Lock性能对比 ReentrantLock可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。 使用方法是： 先new一个实例 1static ReentrantLock r=new ReentrantLock(); 加锁 1r.lock()或r.lockInterruptibly(); 此处也是个不同，后者可被打断。当a线程lock后，b线程阻塞，此时如果是lockInterruptibly，那么在调用b.interrupt()之后，b线程退出阻塞，并放弃对资源的争抢，进入catch块。（如果使用后者，必须throw interruptable exception 或catch） 释放锁 1r.unlock() 必须做！何为必须做呢，要放在finally里面。以防止异常跳出了正常流程，导致灾难。这里补充一个小知识点，finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。 ReentrantReadWriteLock可重入读写锁（读写锁的一个实现） 123ReentrantReadWriteLock lock = new ReentrantReadWriteLock() ReadLock r = lock.readLock(); WriteLock w = lock.writeLock(); 两者都有lock,unlock方法。写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码 容器类这里就讨论比较常用的两个： 123BlockingQueueConcurrentHashMapBlockingQueue 阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可- 以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管 道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列），有兴趣可以研究 BlockingQueue在队列的基础上添加了多线程协作的功能：BlockingQueue除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队 列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。 常见的阻塞队列有： 12345ArrayListBlockingQueueLinkedListBlockingQueueDelayQueueSynchronousQueueConcurrentHashMap 高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap 管理类管理类的概念比较泛，用于管理线程，本身不是多线程的，但提供了一些机制来利用上述的工具做一些封装。 了解到的值得一提的管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之字符串常量池","slug":"java基础之字符串常量池","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/11/28/java基础之字符串常量池/","link":"","permalink":"http://zhangbuzola.cn/2017/11/28/java基础之字符串常量池/","excerpt":"","text":"概念JVM为了减少字符串对象的重复创建,其维护了一个特殊的内存,这段内存被成为字符串常量池或者字符串字面量池 Java中字符串对象创建有两种形式 字面量形式，如String str = “droid”; 另一种就是使用new这种标准的构造对象的方法，如String str = new String(“droid”);，这两种方式我们在代码编写时都经常使用，尤其是字面量的方式。 然而这两种实现其实存在着一些性能和内存占用的差别。这 一切都是源于JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池或者字符串字面量池。 当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。 12String str1 = &quot;droid&quot;;String str3 = new String(&quot;droid&quot;); 当我们使用了new来构造字符串对象的时候，不管字符串常量池中有没有相同内容的对象的引用，新的字符串对象都会创建。因此我们使用下面代码测试一下， intern对于上面使用new创建的字符串对象，如果想将这个对象的引用加入到字符串常量池，可以使用intern方法。 调用intern后，首先检查字符串常量池中是否有该对象的引用，如果存在，则将这个引用返回给变量，否则将引用加入并返回给变量。 12String str4 = str3.intern();System.out.println(str4 == str1); // true 字符串常量池中存放的时引用还是对象，这个问题是最常见的。字符串常量池存放的是对象引用，不是对象。 字符串常量池的好处就是减少相同内容字符串的创建，节省内存空间。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java高并发秒杀API_SSM","slug":"seckill","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2017/11/25/seckill/","link":"","permalink":"http://zhangbuzola.cn/2017/11/25/seckill/","excerpt":"","text":"第2部分相关技术的介绍mysql 表设计(手写代码的方式而不是第三方工具创建表) sql技巧(利用sql技巧解决一些实际的问题) 事务和行级锁 mybatis数据访问层的主要工作 dao层设计与开发 mybatis的合理使用(mybatis提供了非常多的一些使用方式，比如基于注解和xml提供sql语句，和基于原生的api和接口访问我们的数据库) mybatis和spring的整合(如何高效的整合) springspring ioc整合service以及service所有的依赖 spring的依赖注入提供了很多种使用方式,大概有： 基于xml的依赖注入 基于注解 基于java config spring ioc整合service 声明式事务的应用(spring声明式事务分析) spring mvc restful接口设计和使用(restful现在更多的是构建在我们互联网web公司的框架中一些接口设计规范中，理解restful如何去设计和使用) springmvc框架如何运作和流程 Controller开发技巧 前端 交互设计 bootstrap jquery 高并发 高并发点和高并发分析(以及如何去找到高并发的瓶颈) 优化思路并实现 项目创建和依赖基于maven来创建项目 项目之前的说明：零开始，官网获取相关配置，maven创建项目 maven配置 maven 命令创建项目 1mvn archetype:generate -DgroupId=org.seckill -DartifactId=seckill -DarchetypeArtifactId=maven-archetype-webapp eclipse中引入maven项目 修改web.xml(tomcat中找web头文件) 目录配置main中new java …. src/test/java,test/resources pom.xml 修改junit的版本号(3.0版本的junit默认使用编程的方式4.0使用注解的方式运行junint) 补全项目依赖，具体看配置了 第3部分秒杀业务分析mysql实现秒杀的难点分析多用户在用一时间对同一个商品进行秒杀的时候，产生的竞争(技术：事务+行级锁) 实现那些秒杀功能秒杀接口暴露 执行秒杀 相关查询 代码开发阶段：dao设计编码 service设计编码 web设计编码 dao层设计编码mysql数据库设计与编码1main/sql/schema.sql (seckill.seckill/ seckill.success_killed) dao实体和接口编码1java/(package)org.seckill.dao+org.seckill.entity 实体 1entity: Class Seckill/ Class SuccessKilled 变通就是：java实体其实是对应相应的数据表的，属性对应列，成功秒杀可能需要拿到seckill的实体，多对一：一个秒杀对应多个成功记录(在多方添加一方的entity，方便存取) 1dao: interface SeckillDao(reduceNumber:减库存，查询接口：Seckill queryById, queryAll)/SuccessKilledDao 基于mybatis实现dao接口 参数+sql=entity 怎么用： sql文件写在哪里(xml中，注解提供sql)，如何实现已经设计好的dao接口(mqpper自动实现dao接口，api编程方式实现dao接口) 使用mybatis实现dao接口编码配置mybatis(结合管官方文档)resources/mybatis-config.xml 1resources/mapper/SeckillDao.xml SuccessKilledDao.xml(为dao接口提供sql语句配置) SuccessKilledDao.xmlmybatis整合spring理论1resources/spring/spring-dao.xml(结合spring官方文档) 单元测试1src/test/java src/test/resources 自动加载test类：eclips如何自动加载呢？利用junit 各种dao接口测试service层开始之前：dao编码之后的思考：之前的工作其实并没有逻辑代码 dao层工作：接口设计+sql编写：好处：代码和sql的分离，方便review package： service：接口和实现类 exception：service所需要的异常 dto：数据传输层 new package123org/seckill/service:serviceorg/seckill/dto:org/seckill/exceptin: 1234567891011121314151617181920212223interface SeckillService&#123;List&lt;Seckill&gt; geiSeckillList():查询所有的秒杀记录Seckill getById(seckillId):查询单个秒杀记录Exposer exportSeckillUrl(seckillId)/*秒杀开启就是输出秒杀接口地址，否则输出系统时间和秒杀时间，这个时候需要一个dto Exposer:用来暴露一个秒杀接口*/class Exposer：这里有一个加密措施&#125;SeckillExecution executeSeckill(seckillId, userPjone, md5)/*这时封装一个dto数据传输层类SeckillSExecution：秒杀执行后结果：id+执行状态标识+秒杀成功对象执行秒杀过程中会发现各种异常(都应该是运行期异常RuntimeException：spring声明式事务只接受运行期异常)*/RepeateKillException:重复秒杀异常SeckillCloseException/*秒杀关闭异常：秒杀关闭了用户还执行秒杀,秒杀关闭的原因有很多*/SeckillException:秒杀异常上面是子异常，是两种不同的异常 设计业务接口：设计业务接口站在使用者角度设计接口 如何站在使用者设计接口： 方法定义粒度(非常明确的，像秒杀业务，肯定有一个接口执行秒杀，而不是关注在减库存之类的点上，友好方便) 参数：简练直接 返回类型：return(return的类型一定要友好而不是一个map或者是entity)异常 上面的mysql的表列命名很重要 实现SeckillService接口1service/impl/SeckillServiceImpl.java 实现四个接口： 使用枚举标识常量 基于spring管理service依赖Spring IOC功能理解(本质上通过IOC管理)： 对象工厂：IOC依赖注入：创建对象的过程，也就是对象工厂，还有一些其他的依赖(dao) 依赖管理： 达到一致的访问接口: IOC理解 业务对象依赖图：1SeckillService(依赖)--&gt;SeckillDao + successKIllDao --&gt; SqlSessionFactory--&gt;DataSource(spring) 为什么要用IOC： 对象创建统一托管；规范的生命周期管理；灵活的依赖注入(多种依赖注入方式)；一致的获取对象方式(有了ioc容器后，可以从容器中get到已有的对象) Spring-IOC：注入方式和场景： 注入方式： xml(bean+命名空间)+注解+java配置类(通过代码控制对象创建逻辑的场景) 本项目IOC使用： 主要采用xml配置+配置了一个机制：pacakge-sacn(service去扫描service类)+Annotation注解 1spring/spring-service.xml(放所有的service，扫描service包(子包)下所有使用注解的类型) 有哪些注解呢？ ioc容器拿到对象实例，注入service依赖 Spring 声明式事务：简单流程： 开启事务，修改sql-i，提交或者回滚事务 解脱事务代码 声明式事务使用方式： 早期：ProxyFactoryBean+XML (发展)tx:aop命名空间(一次配置永久生效) 注解@Transactional (注解控制，在方法中添加注解) 事务方法嵌套体现在传播行为(propagation_required…) 什么时候回滚事务：spring声明式事务只有在抛出运行期异常RuntimeException，小心不当的try-catch 声明式事务配置(spring-service.xml)：注入数据库连接池 + 配置基于注解的声明式事务：默认使用注解来管理事务行为 使用注解控制事务方法的优点： 开发团队达成一致，明确标注事务方法的编程风格 保证事务方法的执行时间尽可能短，不要穿插其他网络操作RPC/HTTP请求或者剥离到事务方法外部 不是所有的方法都需要事务，如果只有一条修改操作，只读才做不需要事务控制，可以了解mysql行级锁相关的文档 集成测试service层1test/java/../SeckillServiceTest.java 配置logbakck slf4j只是一套接口，真正实现是logback(查看官网) 1main/resource/logback.xml","categories":[{"name":"Java后台","slug":"Java后台","permalink":"http://zhangbuzola.cn/categories/Java后台/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://zhangbuzola.cn/tags/SSM/"}]},{"title":"Mybatis官方文档学习笔记二","slug":"mybatis_strong_2","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/11/23/mybatis_strong_2/","link":"","permalink":"http://zhangbuzola.cn/2017/11/23/mybatis_strong_2/","excerpt":"","text":"XML 映射配置文件配置文件结构12345678910111213- configuration 配置 - properties属性 - settings设置 - typeAliases 类型别名 - typeHandlers类型处理器 - ObjectFactory对象工厂 - plugins 插件 - environments 环境 - environment 环境变量 - transactionManager 事务管理器 - dataSource 数据源 - databaseIdProvider 数据库厂商标识 - mappers 映射器 properties这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递 1234&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;&lt;/properties&gt; 其中的属性就可以在整个配置文件中使用来替换需要动态配置的属性值。比如: 123456&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;&lt;/dataSource&gt; 这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。属性也可以被传递到 SqlSessionFactoryBuilder.build()方法中. 123SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);// ... or ...SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props); 如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载： 在 properties 元素体内指定的属性首先被读取。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。 从MyBatis 3.4.2开始，你可以为占位符指定一个默认值。例如: 12345&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- ... --&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username:ut_user&#125;&quot;/&gt; &lt;!-- If &apos;username&apos; property not present, username become &apos;ut_user&apos; --&gt;&lt;/dataSource&gt; 这个特性默认是关闭的。如果你想为占位符指定一个默认值， 你应该添加一个指定的属性来开启这个特性。例如: 12345&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt; &lt;!-- ... --&gt; &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;&lt;/properties&gt; 你可以使用 作为属性键```(e.g. db:username)``` 或者你也可以在sql定义中使用 OGNL 表达式的三元运算符```(e.g. $&#123;tableName !12 12345```&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- ... --&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;db:username?:ut_user&#125;&quot;/&gt;&lt;/dataSource&gt; settings这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等 一个配置完整的 settings 元素的示例如下: 1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; typeAliases类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如: 12345678&lt;typeAliases&gt; &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt; &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt; &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt; &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt; &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt; &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog可以用在任何使用domain.blog.Blog的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如: 123&lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。看下面的例子： 1234@Alias(&quot;author&quot;)public class Author &#123; ...&#125; 已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。 typeHandlers无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。 NOTE Since version 3.4.5, The MyBatis has been supported JSR-310(Date and Time API) by default. 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 接口， 或继承一个很便利的类 ```org.apache.ibatis.type.BaseTypeHandler```, 然后可以选择性地将它映射到一个 JDBC 类型。比如：12 // ExampleTypeHandler.java@MappedJdbcTypes(JdbcType.VARCHAR)public class ExampleTypeHandler extends BaseTypeHandler { @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException { ps.setString(i, parameter); } @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException { return rs.getString(columnName); } @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException { return rs.getString(columnIndex); } @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException { return cs.getString(columnIndex); }}12 123456789101112使用这个的类型处理器将会覆盖已经存在的处理 ```Java``` 的 ```String``` 类型属性和 ```VARCHAR``` 参数及结果的类型处理器。 要注意 ```MyBatis``` 不会窥探数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明那是 ```VARCHAR``` 类型的字段， 以使其能够绑定到正确的类型处理器上。 这是因为：```MyBatis```直到语句被执行才清楚数据类型。通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变：- 在类型处理器的配置元素（typeHandler element）上增加一个 javaType 属性（比如：javaType=&quot;String&quot;）；- 在类型处理器的类上（TypeHandler class）增加一个 @MappedTypes 注解来指定与其关联的 Java 类型列表。 如果在 javaType 属性中也同时指定，则注解方式将被忽略。可以通过两种方式来指定被关联的 JDBC 类型：- 在类型处理器的配置元素上增加一个 jdbcType 属性```（比如：jdbcType=&quot;VARCHAR&quot;）； 在类型处理器的类上class）```增加一个``` @MappedJdbcTypes ```注解来指定与其关联的 ```JDBC ```类型列表。 如果在 jdbcType 属性中也同时指定，则注解方式将被忽略。1234当决定在```ResultMap```中使用某一```TypeHandler```时，此时```java```类型是已知的（从结果类型中获得），但是```JDBC```类型是未知的。 因此```Mybatis```使用```javaType=[TheJavaType], jdbcType=nul```l的组合来选择一个```TypeHandler```。 这意味着使用```@MappedJdbcTypes```注解可以限制TypeHandler的范围，同时除非显示的设置，否则```TypeHandler```在```ResultMap```中将是无效的。 如果希望在ResultMap中使用TypeHandler，那么设置@MappedJdbcTypes注解的```includeNullJdbcType=true```即可。 然而从```Mybatis 3.4.0```开始，如果只有一个注册的```TypeHandler```来处理Java类型，那么它将是ResultMap使用Java类型时的默认值（即使没有```includeNullJdbcType=true```）。最后，可以让 MyBatis 为你查找类型处理器： 1234注意在使用自动检索（autodiscovery）功能的时候，只能通过注解方式来指定 JDBC 的类型。你能创建一个泛型类型处理器，它可以处理多于一个类。为达到此目的， 需要增加一个接收该类作为参数的构造器，这样在构造一个类型处理器的时候 MyBatis 就会传入一个具体的类。 //GenericTypeHandler.javapublic class GenericTypeHandler extends BaseTypeHandler { private Class type; public GenericTypeHandler(Class type) { if (type == null) throw new IllegalArgumentException(“Type argument cannot be null”); this.type = type; } …1234567891011EnumTypeHandler 和 EnumOrdinalTypeHandler 都是泛型类型处理器（generic TypeHandlers）， 我们将会在接下来的部分详细探讨。## 处理枚举类型若想映射枚举类型 Enum，则需要从 EnumTypeHandler 或者 EnumOrdinalTypeHandler 中选一个来使用。比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 EnumTypeHandler 来把 Enum 值转换成对应的名字。注意 EnumTypeHandler 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 Enum 的类。不过，我们可能不想存储名字，相反我们的 DBA 会坚持使用整形值代码。那也一样轻而易举： 在配置文件中把 EnumOrdinalTypeHandler 加到 typeHandlers 中即可， 这样每个 RoundingMode 将通过他们的序数值来映射成对应的整形。 12345但是怎样能将同样的 Enum 既映射成字符串又映射成整形呢？自动映射器（auto-mapper）会自动地选用 EnumOrdinalTypeHandler 来处理， 所以如果我们想用普通的 EnumTypeHandler，就非要为那些 SQL 语句显式地设置要用到的类型处理器不可。（下一节才开始讲映射器文件，所以如果是首次阅读该文档，你可能需要先越过这一步，过会再来看。） &lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;select id=&quot;getUser&quot; resultMap=&quot;usermap&quot;&gt; select * from users &lt;/select&gt; &lt;insert id=&quot;insert&quot;&gt; insert into users (id, name, funkyNumber, roundingMode) values ( #{id}, #{name}, #{funkyNumber}, #{roundingMode} ) &lt;/insert&gt; &lt;resultMap type=&quot;org.apache.ibatis.submitted.rounding.User&quot; id=&quot;usermap2&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;funkyNumber&quot; property=&quot;funkyNumber&quot;/&gt; &lt;result column=&quot;roundingMode&quot; property=&quot;roundingMode&quot; typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUser2&quot; resultMap=&quot;usermap2&quot;&gt; select * from users2 &lt;/select&gt; &lt;insert id=&quot;insert2&quot;&gt; insert into users2 (id, name, funkyNumber, roundingMode) values ( #{id}, #{name}, #{funkyNumber}, #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler} ) &lt;/insert&gt; 123456注意，这里的 select 语句强制使用 resultMap 来代替 resultType。## 对象工厂（objectFactory）MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。比如： // ExampleObjectFactory.javapublic class ExampleObjectFactory extends DefaultObjectFactory { public Object create(Class type) { return super.create(type); } public Object create(Class type, List constructorArgTypes, List constructorArgs) { return super.create(type, constructorArgTypes, constructorArgs); } public void setProperties(Properties properties) { super.setProperties(properties); } public boolean isCollection(Class type) { return Collection.class.isAssignableFrom(type); }}12 12345678910111213141516ObjectFactory 接口很简单，它包含两个创建用的方法，一个是处理默认构造方法的，另外一个是处理带参数的构造方法的。 最后，setProperties 方法可以被用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。## 插件（plugins）MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)- ParameterHandler (getParameterObject, setParameters)- ResultSetHandler (handleResultSets, handleOutputParameters)- StatementHandler (prepare, parameterize, batch, update, query)这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 的发行包中的源代码。 假设你想做的不仅仅是监控方法的调用，那么你应该很好的了解正在重写的方法的行为。 因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏 MyBatis 的核心模块。 这些都是更低层的类和方法，所以使用插件的时候要特别当心。通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定了想要拦截的方法签名即可。 // ExamplePlugin.java@Intercepts({@Signature( type= Executor.class, method = “update”, args = {MappedStatement.class,Object.class})})public class ExamplePlugin implements Interceptor { public Object intercept(Invocation invocation) throws Throwable { return invocation.proceed(); } public Object plugin(Object target) { return Plugin.wrap(target, this); } public void setProperties(Properties properties) { }}12 1234567891011121314151617上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。**NOTE 覆盖配置类**除了用插件来修改 MyBatis 核心行为之外，还可以通过完全覆盖配置类来达到目的。只需继承后覆盖其中的每个方法，再把它传递到 SqlSessionFactoryBuilder.build(myConfig) 方法即可。再次重申，这可能会严重影响 MyBatis 的行为，务请慎之又慎。## 配置环境（environments）MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：每个数据库对应一个 SqlSessionFactory 实例为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是： SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment,properties);12如果忽略了环境参数，那么默认环境将会被加载，如下所示： SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader,properties);12环境元素定义了如何配置环境。 12345678910111213141516171819注意这里的关键点:- 默认的环境 ID（比如:default=”development”）。- 每个 environment 元素定义的环境 ID（比如:id=”development”）。- 事务管理器的配置（比如:type=”JDBC”）。- 数据源的配置（比如:type=”POOLED”）。默认的环境和环境 ID 是一目了然的。随你怎么命名，只要保证默认环境要匹配其中一个环境ID。### 事务管理器（transactionManager）在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如: 1234**NOTE如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。**这两种事务管理器类型都不需要任何属性。它们不过是类型别名，换句话说，你可以使用 TransactionFactory 接口的实现类的完全限定名或类型别名代替它们。 public interface TransactionFactory { void setProperties(Properties props); Transaction newTransaction(Connection conn); Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);}1任何在 XML 中配置的属性在实例化之后将会被传递给 setProperties() 方法。你也需要创建一个 Transaction 接口的实现类，这个接口也很简单： public interface Transaction { Connection getConnection() throws SQLException; void commit() throws SQLException; void rollback() throws SQLException; void close() throws SQLException; Integer getTimeout() throws SQLException;}123456789101112131415161718使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。### 数据源（dataSource）dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。许多 MyBatis 的应用程序将会按示例中的例子来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。有三种内建的数据源类型（也就是 ```type=”[UNPOOLED|POOLED|JNDI]”```）：UNPOOLED– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：- driver – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。- url – 这是数据库的 JDBC URL 地址。- username – 登录数据库的用户名。- password – 登录数据库的密码。- defaultTransactionIsolationLevel – 默认的连接事务隔离级别。作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为“driver.”，例如： driver.encoding=UTF812这将通过 DriverManager.getConnection(url,driverProperties)12345678910111213141516171819202122方法传递值为 UTF8 的 encoding 属性给数据库驱动。POOLED这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。除了上述提到 UNPOOLED 下的属性外，会有更多属性用来配置 POOLED 的数据源：- poolMaximumActiveConnections – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10- poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。- poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）- poolTimeToWait – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。- poolMaximumLocalBadConnectionTolerance – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程. 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这 个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。 默认值：3 (Since: 3.4.5)- poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。- poolPingEnabled – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 poolPingQuery 属性（最好是一个非常快的 SQL），默认值：false。- poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。JNDI– 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：- initial_context – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。- data_source – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给初始上下文。比如： env.encoding=UTF8123这就会在初始上下文（InitialContext）实例化时往它的构造方法传递值为 UTF8 的 encoding 属性。通过需要实现接口 org.apache.ibatis.datasource.DataSourceFactory ， 也可使用任何第三方数据源，： public interface DataSourceFactory { void setProperties(Properties props); DataSource getDataSource();}12`org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory` 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码： import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;import com.mchange.v2.c3p0.ComboPooledDataSource; public class C3P0DataSourceFactory extends UnpooledDataSourceFactory { public C3P0DataSourceFactory() { this.dataSource = new ComboPooledDataSource(); }}12为了令其工作，为每个需要 MyBatis 调用的 setter 方法中增加一个属性。下面是一个可以连接至 PostgreSQL 数据库的例子： 1234## databaseIdProviderMyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可： 12这里的 DB_VENDOR 会通过 DatabaseMetaData#getDatabaseProductName() 返回的字符串进行设置。 由于通常情况下这个字符串都非常长而且相同产品的不同版本会返回不同的值，所以最好通过设置属性别名来使其变短，如下： 1234在有 properties 时，```DB_VENDOR databaseIdProvider``` 的将被设置为第一个能匹配数据库产品名称的属性键对应的值，如果没有匹配的属性将会设置为 “null”。 在这个例子中，如果 ```getDatabaseProductName()``` 返回```“Oracle (DataDirect)”，databaseId``` 将被设置为“oracle”。你可以通过实现接口 ```org.apache.ibatis.mapping.DatabaseIdProvider``` 并在 mybatis-config.xml 中注册来构建自己的 ```DatabaseIdProvider： 1234public interface DatabaseIdProvider &#123; void setProperties(Properties p); String getDatabaseId(DataSource dataSource) throws SQLException;&#125; 映射器（mappers）既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如： 12345678910111213141516171819202122&lt;mappers&gt;&lt;!-- Using classpath relative resources --&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- Using url fully qualified paths --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- Using mapper interface classes --&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- Register all interfaces in a package as mappers --&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; 这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了，也就是接下来我们要讨论的。","categories":[{"name":"Java后台","slug":"Java后台","permalink":"http://zhangbuzola.cn/categories/Java后台/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://zhangbuzola.cn/tags/Mybatis/"}]},{"title":"mysql必知必会学习笔记一","slug":"mysql_must1","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/11/23/mysql_must1/","link":"","permalink":"http://zhangbuzola.cn/2017/11/23/mysql_must1/","excerpt":"","text":"mysql 检索数据select 语句12345678910111213141516171819202122232425SELECT * FROM table_name; /*检索所有列*/SELECT column_name FROM table_name;/*检索出来的数据顺序随机*/-- sql关键字大写，对所有表名字和列小写，SQL不区分大小写SELECT DISTINCT column_name FROM table_name; /*返回不同值，执行mysql返回不多于5行*/-- 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数SELECT column_name FROM table_name LIMIT 5; /*这个语句是用来检索单个列*/SELECT column_name FROM table_name LIMIT 5,5; --限制行数：这里是指：从行5开始的5行，第一个是开始位置，第二个数为要检索的行数-- 后面mysql5支持LIMIT的另一种替代语法：LIMIT 4 OFFSET 3 从行3开始取4行-- 接下来将检索出来的数据进行 排序SELECT column_name FROM table_name ORDER BY column_name;SELECT column_name1,..., column_namen FROM table_name ORDER BY column_namei, column_namej;SELECT column_name1,...,column_namen FROM table_name ORDER BY column_namei DESC;-- 降序排序DESC关键字，默认升序SELECT column_name FROM table_name ORDER BY column_name DESC LIMIT 1;-- LIMIT 1 表示值返回一行，所以返回的是最大值-- 带一个值的LIMIT总是从第一行开始 where字句12345678910111213141516SELECT column_name1,...,column_namen FROM table_name WHERE column_namei = valuei;--- 空值检查--- 单引号表示字符串SELECT column_name FROM table_name WHERE column_name IS NULL;-- 组合where字句/*AND/OR*/ /*注意运算符的优先级 AND &gt; OR, 可适当加括号*/SELECT prod_name,prod_price FROM products WHERE (vend_i=1002 OR vend_id=1003) AND prod_price&gt;=10;/*IN操作符:指定条件范围*/SELECT prod_name,prod_price FROM products WHERE vend_i IN(1002, 1003) ORDER BY prod_name;/*NOT 操作符*/SELECT prod_name,prod_price FROM products WHERE vend_i NOT IN(1002, 1003) ORDER BY prod_name; 通配符123456789/*LIKE操作符*/SELECT prod_id, prod_name FROM products WHERE prod_name LIKE &apos;jet%&apos;;--- % 通配符:表示任何字符出现任意次数SELECT prod_id, prod_name FROM products WHERE prod_name LIKE &apos;%anvil%&apos;;-- 例子：产品名字包含anvil-- 下划线(_)通配符:只匹配单个字符而不是多个字符SELECT prod_id, prod_name FROM products WHERE prod_name LIKE &apos;_ton anvil%&apos;; 正则表达式123456789101112131415161718192021222324252627/*LIKE ---&gt; REGEXP*/SELECT prod_name,prod_price FROM products WHERE prod_name LIKE &apos;1000&apos; ORDER BY prod_name;SELECT prod_name,prod_price FROM products WHERE prod_name REGEXP &apos;1000&apos; ORDER BY prod_name;SELECT prod_name,prod_price FROM products WHERE prod_name REGEXP &apos;1000|2000&apos; ORDER BY prod_name;SELECT prod_name,prod_price FROM products WHERE prod_name REGEXP &apos;.000&apos; ORDER BY prod_name;-- LIKE需要通配符,仔细比较上面语句的区别/* .匹配任意一个字符,so上一个查询语句返回的结果是：prod_name中后缀是000的，前一个字符任意*/-- []:[123]匹配1或者2或者3 [0-9][a-z]匹配人一个范围内的字符-- 匹配特殊字符：需要转义字符：\\\\.匹配.字符-- 匹配字符类：[:lower:]任意小写字母[:space:]包括空格在内的任意空白字符...-- 匹配多个实例：* 0或者多个匹配+ 1或者多个匹配&#123;1，&#125;？ 0或者1个匹配&#123;0,1&#125;&#123;n&#125;指定数目匹配&#123;n,&#125;不少于指定数目的匹配&#123;n,m&#125;匹配数目的范围m&lt;=255^匹配串的开始","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangbuzola.cn/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangbuzola.cn/tags/MySQL/"}]},{"title":"Mybatis官方文档学习笔记一","slug":"mybatis_strong_1","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/11/23/mybatis_strong_1/","link":"","permalink":"http://zhangbuzola.cn/2017/11/23/mybatis_strong_1/","excerpt":"","text":"入门Mybatis导入 安装:mybatis-x.x.x.jar 文件放在classpath中就可以了 maven构建项目 将dependency代码放在pom.xml中： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; XML中构建SqlSessionFactory每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的。 SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。 而SqlSessionFactoryBuilder则可以从 XML 配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。 从 XML 文件中构建SqlSessionFactory的实例非常简单，建议使用类路径下的资源文件进行配置。 但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。 MyBatis 包含一个名叫Resources的工具类，它包含一些实用方法，可使从classpath或其他位置加载资源文件更加容易。 123String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!-- 要注意 XML 头部的声明，用来验证 XML 文档正确性 --&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment 元素体中包含了事务管理和连接池的配置 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- mappers 元素则是包含一组 mapper 映射器 --&gt; &lt;!-- 这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息 --&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 不使用XML构建SqlSessionFactory直接使用java源码创建configuration或者自己configuration构建器，MyBatis 也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项 12345678910DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class); /*configuration 添加了一个映射器类(mapper class)*//*映射器类是 Java 类，它们包含 SQL 映射语句的注解从而避免了 XML 文件的依赖*//** 不过，由于 Java 注解的一些限制加之某些 MyBatis 映射的复杂性，XML ** 映射对于大多数高级映射（比如：嵌套 Join 映射）来说仍然是必须的 ***/SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); 从 SqlSessionFactory 中获取 SqlSession拿到SqlSessionFactory后,我们就可以从中获得 SqlSession 的实例了。 SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句 123456789101112131415161718192021/* old version*/SqlSession session = sqlSessionFactory.openSession();try &#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125; finally &#123; session.close();&#125;/* new version *//** ** 使用对于给定语句能够合理描述参数和返回值的接口(比如说BlogMapper.class) ** 如此不但可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。 ***/SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; finally &#123; session.close();&#125; 探究已映射的 SQL 语句SqlSession 和 Mapper 到底执行了什么操作，而 SQL 语句映射是个相当大的话题，可能会占去文档的大部分篇幅。不过为了让你能够了解个大概，这里会给出几个例子 在上面提到的两个例子中，一个语句应该是通过 XML 定义，而另外一个则是通过注解定义。 先看 XML 定义这个，事实上 MyBatis 提供的全部特性可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你以前用过 MyBatis，这个概念应该会比较熟悉。不过 XML 映射文件已经有了很多的改进，随着文档的进行会愈发清晰。这里给出一个基于 XML 映射语句的示例，它应该可以满足上述示例中 SqlSession 的调用。 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!-- simple example --&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; &lt;!-- 非常轻量级 --&gt; 在一个 XML 映射文件中，你想定义多少个映射语句都是可以的，这样下来，XML 头部和文档类型声明占去的部分就显得微不足道了。文件的剩余部分具有很好的自解释性。在命名空间“org.mybatis.example.BlogMapper”中定义了一个名为“selectBlog”的映射语句，这样它就允许你使用指定的完全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句，就像上面的例子中做的那样： 1Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101); 你可能注意到这和使用完全限定名调用 Java 对象的方法是相似的，之所以这样做是有原因的。这个命名可以直接映射到在命名空间中同名的 Mapper 类，并在已映射的 select 语句中的名字、参数和返回类型匹配成方法。这样你就可以向上面那样很容易地调用这个对应 Mapper 接口的方法。不过让我们再看一遍下面的例子： 12345BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101);/*第二种方法有很多优势，首先它不是基于字符串常量的，就会更安全；其次，如果你的 IDE 有代码补全功能，那么你可以在有了已映射 SQL 语句的基础之上利用这个功能。*/ 命名空间命名空间（Namespaces）在之前版本的 MyBatis 中是可选的，容易引起混淆因此是没有益处的。现在的命名空间则是必须的，目的是希望能比只是简单的使用更长的完全限定名来更进一步区分语句。 命名空间使得你所见到的接口绑定成为可能，尽管你觉得这些东西未必用得上，你还是应该遵循这里的规定以防哪天你改变了主意。出于长远考虑，使用命名空间，并将它置于合适的 Java 包命名空间之下，你将拥有一份更加整洁的代码并提高了 MyBatis 的可用性。 命名解析：为了减少输入量，MyBatis 对所有的命名配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。 完全限定名（比如“com.mypackage.MyMapper.selectAllThings”）将被直接查找并且找到即用。 短名称（比如“selectAllThings”）如果全局唯一也可以作为一个单独的引用。如果不唯一，有两个或两个以上的相同名称（比如“com.foo.selectAllThings ”和“com.bar.selectAllThings”），那么使用时就会收到错误报告说短名称是不唯一的，这种情况下就必须使用完全限定名。 对于像 BlogMapper 这样的映射器类（Mapper class）来说，还有另一招来处理。它们的映射的语句可以不需要用 XML 来做，取而代之的是可以使用 Java 注解。比如，上面的 XML 示例可被替换如下： 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;) Blog selectBlog(int id);&#125; 对于简单语句来说，注解使代码显得更加简洁，然而 Java 注解对于稍微复杂的语句就会力不从心并且会显得更加混乱。因此，如果你需要做很复杂的事情，那么最好使用 XML 来映射语句。 选择何种方式以及映射语句的定义的一致性对你来说有多重要这些完全取决于你和你的团队。换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。 作用域和生命周期错误使用会导致非常严重的并发问题 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器（mapper）并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。如果对如何通过依赖注入框架来使用 MyBatis 感兴趣可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式： 123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; 在你的所有的代码中一致性地使用这种模式来保证所有数据库资源都能被正确地关闭。 映射器实例（Mapper Instances）映射器是创建用来绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，映射器实例的最大作用域是和 SqlSession 相同的，因为它们都是从 SqlSession 里被请求的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。下面的示例就展示了这个实践： 1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); // do work&#125; finally &#123; session.close();&#125; 问题 什么是SqlSession,用来做什么的呢？ 线程问题 依赖注入框架 注解","categories":[{"name":"Java后台","slug":"Java后台","permalink":"http://zhangbuzola.cn/categories/Java后台/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://zhangbuzola.cn/tags/Mybatis/"}]},{"title":"hexo+github搭建个人博客","slug":"hexo_github","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/11/23/hexo_github/","link":"","permalink":"http://zhangbuzola.cn/2017/11/23/hexo_github/","excerpt":"","text":"# hexo+github搭建个人博客 前期准备github账户域名我是在腾讯云上购买了一个域名，90块钱3年，自己是觉得很划算啦。教训就是名字起的不是很满意，被男票嫌弃了一番。再就是域名解析，这个百度教程就有啦，github如何绑定自己的域名。 git安装git官网下载后，安装过程一路next就好啦。 检查是否安装成功，cmd命令，出现版本号即说明已经成功安装 12$ git -version nodejs安装nodejs安装蛮容易的，安装nodejs网址：https://nodejs.org/en/进去之后下载好.msi的安装包，一路next就可以（除非那种对安装路径很有洁癖的人就修改一下安装路径就好了），安装好nodejs就可以使用npm安装hexo了。 检查是否安装成功： 123$ node -v$ npm -v hexo 安装 hexo的安装我花了些时间折腾，原因是镜像问题，最开始按着csdn里面的一个教程安装了cnpm的，然后开始出现各种npm err问题，后悔啊。我nodejs重装了好几次，万能方法，但是折腾啊。 检查是否安装成功： 1$ hexo -v 总结一下： npm install 出现问题 最简单的方式就是找到C:\\Users\\ *下的.npmrc文件，直接编辑里面的内容： 1234registry=https://registry.npm.taobao.orgcache=D:\\zola_softeware\\greensoftwares\\node.js\\node_cacheprefix=D:\\zola_softeware\\greensoftwares\\node.js\\node_global（路径是nodejs的安装路径） 或者：(这个我看registry地址有的教程写的竟然是taobap，然后呜呼，又是一道弯路，有可能是我眼花了，哭脸) 123npm config set registry https://registry.npm.taobao.orgnpm config set prefix &quot;D:\\Program Files\\Nodejs\\node_global&quot;npm config set cache &quot;D:\\Program Files\\Nodejs\\node_cache&quot; 这个是配置npm的全局模块的存放路径以及cache的路径，例如我希望将以上两个文件夹放在NodeJS的主目录下，便在NodeJs下新建”node_global”及”node_cache”两个文件夹。 npm install -g hexo 出现问题，可能就是上面的镜像的问题，当时使用这个命令的时候总是报错 hexo安装好以后，接下来就是开始blog了，首先在某盘上新建blog文件，右键git bash here,我的是提示一下问题： 执行npm install即可，接下来你就可以在blog文件下看到已经自动生成了若干个文件。 123456789* node_modules: hexo的功能javascript文件* public：生成静态网页文件* scaffolds：工具模板* source：./drafts:草稿文件夹./posts:文章文件夹* themes：用来存放皮肤的文件夹* ——config.yml:全局配置文件* db.json:json格式的静态常量数据库 123456hexo init:初始化hexonpm install:安装生成器，下载各种包hexo g: hexo d：hexp p:hexo s: hexo s命令，localhost：4000一直在转圈，打不开网页,原因是：4000端口一直被占用了，执行: 1$ hexo server -p 4013 对于hexo的更多使用命令： 1https://hexo.io/ 深呼一口气，我的准备工作算是完成了一大半了。接下来就是找一个我喜欢的主题，然后部署到我的github就好了。 hexo+githubhexo博客部署到我的github上 修改_config.yml文件配置如下： 123456#Deployment##Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:zolanunu/zolanunu.github.io.git branch: master 修改好配置文件之后 123hexo cleanhexo ghexo deploy 打开浏览器，输入：zolanunu.github.io，就可以发现bingo了。 接下来我要挑一个我喜欢的主题咯：https://github.com/csuldw/FreeSky 遇到的难点hexo 图片问题 hexo 博客搭建过程笔记： 各种前期准备工作，前期各种域名和github的各种连接问题 hexo 主题下载及优化 再就是hexo 博客搭建过程中遇到的问题 hexo 图片加载问题","categories":[{"name":"工具","slug":"工具","permalink":"http://zhangbuzola.cn/categories/工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhangbuzola.cn/tags/hexo/"}]},{"title":"Mybatis官方文档学习笔记三","slug":"mybatis_strong_3","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/11/23/mybatis_strong_3/","link":"","permalink":"http://zhangbuzola.cn/2017/11/23/mybatis_strong_3/","excerpt":"","text":"XML 映射文件Mybatis与SQL SQL映射文件中若干个顶级元素： 123456789cache - 给定命名空间的缓存空间cache-ref - 其他命名空间缓存配置的引用resultMap - 描述如何从数据库结果中加载对象parameterMap - 已经废弃了，参数映射sql - 可被其他语句引用的可重用语句块insert -映射插入语句update - 映射更新语句delete - 映射删除语句select - 映射查询语句 select1234567&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt; &lt;!-- 这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数 并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值 --&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 1#&#123;id&#125; &lt;!-- 参数符号 --&gt; 这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样： 1234// Similar JDBC code, NOT MyBatis…String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); 12345678910111213141516171819202122232425262728293031323334353637id 在命名空间中唯一的标识符，可以被用来引用这条语句。parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：falseuseCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个默认值为 unset （依赖驱动）。databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。","categories":[{"name":"Java后台","slug":"Java后台","permalink":"http://zhangbuzola.cn/categories/Java后台/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://zhangbuzola.cn/tags/SSM/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://zhangbuzola.cn/tags/Mybatis/"}]},{"title":"java基础学习之return","slug":"java基础之return","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/11/22/java基础之return/","link":"","permalink":"http://zhangbuzola.cn/2017/11/22/java基础之return/","excerpt":"","text":"return关键字 return语句的作用：a、返回一个值，这个值可以是任意类型。b、使程序返回到操作系统（即终止程序） java中对于一个函数，不论有没有返回值类型，都可以带有return 语句。但是区别在于，return 语句是否可以返回一个值（这取决与该函数的返回值类型）。 return就是有两种用途，一个是返回值给需要的函数调用，所以就要求函数前面的返回值，void就代表不接受返回值。第二种就是单纯的退出这个方法函数，不执行了，就直接写return；","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之访问权限","slug":"java基础之访问权限","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/11/22/java基础之访问权限/","link":"","permalink":"http://zhangbuzola.cn/2017/11/22/java基础之访问权限/","excerpt":"","text":"访问权限 private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。 protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。 权限 类内 包内 包外子类 包外非子类 private ok default ok ok protected ok ok ok public ok ok ok ok publicpublic：接口访问权限 使用public关键字，就意味着被声明的成员或方法对所有人都是可以访问的。 例：如果将default级别权限例子中的print()方法权限设为public，则PublicDemo02可以访问。 1234567package com.notes.packages.test;publicclass Info &#123; publicvoid print() &#123; System.out.println(&quot;public method -- print()&quot;); &#125;&#125; privateprivate：无法访问 使用private关键字，就意味着被声明的成员或方法，除了本类，其他任何类都无法访问。 应用场景：单例模式 protectedprotected：继承访问权限 新类（称之子类或派生类）通过继承可以复用一个现有类（称之父类或基类），然后扩展基类的成员、方法。有时，基类的创建者会希望某个特定成员，将它的访问权限赋予派生类而不是所有类。public无法做到这一点，为此，引入了protected来完成这一工作。protected也提供包访问权限，也就是说，派生类以及相同包内的其他类都可以访问protected成员或方法。 例：子类继承父类后，可以访问父类的protected成员。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Father &#123; private String a = &quot;private&quot;; protected String b = &quot;protected&quot;; public String c = &quot;public&quot;;&#125;;class Son extends Father &#123; publicvoid print() &#123; // System.out.println(&quot;element a：&quot; + super.a); // Error System.out.println(&quot;element b：&quot; + super.b); System.out.println(&quot;element c：&quot; + super.c); &#125;&#125;publicclass ProtectedDemo01 &#123; publicstaticvoid main(String args[]) &#123; Son sub = new Son(); sub.print(); &#125;&#125;;``` # 注意点访问权限修饰词的注意点前面各个例子中展示了类的成员、方法都可以用各种权限修饰词来修饰。除此之外，还有一些需要注意的点：- 静态成员、静态方法的权限修饰词的用法和普通成员、方法一样。- 类虽然也可以被修饰词修饰，但是不可以用private、protected两个权限修辞词。- 有些书中将包访问权限又叫做默认访问权限。个人不建议这么去记，因为这很容易与Java Se8中新特性——default关键字混淆。这个关键字只能用于Interface，作用是允许程序员在Interface中定义接口的默认具体实现（以往的JDK版本是不允许这样的，你只能在接口中声明方法）。# 作用Java中为什么要设计访问权限控制机制呢？主要作用有两点：- 为了使用户不要触碰那些他们不该触碰的部分，这些部分对于类内部的操作时必要的，但是它并不属于客户端程序员所需接口的一部分。- 为了让类库设计者可用更改类的内部工作方式，而不必担心会对用户造成重大影响。 Java中的访问权限控制的等级，按照权限从大到小依次为： Public -&gt; protected -&gt; 包访问权限（没有权限修饰词）-&gt; private12345678910111213Java中包(package)的概念和C++中命名空间(namespace)的概念很类似，都可以限制类的作用域。二者最大的差别在于，Java中的包隐式地指明了类的树形层级结构（同时也是Java源码文件的目录结构）。这样做的好处在于：可以通过文件系统中对于文件路径唯一性的要求来限制类的唯一性。编写一个Java源代码文件(.java文件)时，此文件通常被称为编译单元。在编译单元内最多允许有一个public类，且该类的名称必须与文件名完全相同（包括大小写）。编译一个.java文件时，在.java文件中的每个类都会有一个.class输出文件，这个文件名和类名是相同的。Java可运行程序是一组可以打包并压缩为一个Java文档文件(JAR包，使用Java的jar文档生成器)的.class文件。Java解释器负责这些文件的查找、装载和解释。# package类库实际上是一组类文件。其中每个.java文件最多允许有一个public类，以及任意数量的非public类。因此，每个文件都有一个构件。如果要将这些构件（每个构建有一个.java文件和若干个.class文件）组织起来，形成不同的群组，可以使用Java中的关键字package。Java中，使用package关键字来指定代码所属的包（命名空间）。语法格式： package pkg1[．pkg2[．pkg3…]];` 注意点： 包的名字隐含地指出了代码的目录结构。 同一目录下的public类名（同时也是java文件名）应该是独一无二的。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 package的名字一般全是小写字母。 它的代码目录结构就是java/util/ArrayList.java","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之String","slug":"java基础之String","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/11/22/java基础之String/","link":"","permalink":"http://zhangbuzola.cn/2017/11/22/java基础之String/","excerpt":"","text":"String首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。 字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。 null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与” “、new String()的区别就象真空与空气一样。 在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。 对于字符串的使用无非就是这几个方面： • 字符串比较 123456equals() // 判断内容是否相同。compareTo() // 判断字符串的大小关系。compareToIgnoreCase(String int) // 在比较时忽略字母大小写。== // 判断内容与地址是否相同。equalsIgnoreCase() // 忽略大小写的情况下判断内容是否相同。reagionMatches() // 对字符串中的部分内容是否相同进行比较（详情请参考API）。 字符串查找 12345678charAt(int index) // 返回指定索引index位置上的字符，索引范围从0开始。indexOf(String str)// 从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。indexOf(String str，int fromIndex);// 从字符串的第fromIndex个字符开始检索str。lastIndexOf(String str) // 查找最后一次出现的位置。lastIndexOf(String str，int fromIndex) // 从字符串的第fromIndex个字符查找最后一次出现的位置。starWith(String prefix，int toffset)// 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。starWith(String prefix) // 测试此字符串是否以指定的前缀开始。endsWith(String suffix) // 测试此字符串是否以指定的后缀结束。 字符串截取 12public String subString(int beginIndex) // 返回一个新的字符串，它是此字符串的一个子字符串。public String subString(int beginIndex，int endIndex)// 返回的字符串是从beginIndex开始到endIndex-1的串。 字符串替换 123public String replace(char oldChar，char newChar)。public String replace(CharSequence target，CharSequence replacement)// 把原来的etarget子序列替换为replacement序列，返回新串。public String replaceAll(String regex，String replacement)// 用正则表达式实现对字符串的匹配。注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。 更多方法请参考APIStringBufferStringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。 其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。 同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。 在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法： append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。 insert：该类方法主要是在StringBuffer对象中插入内容。 delete：该类方法主要用于移除StringBuffer对象中的内容 StringBuilderStringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。 上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。 正确使用String、StringBuffer、StringBuilder这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。 在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。 但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如： 12String name = ”I ” + ”am ” + ”chenssy ” ;StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”); 对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。 对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）： String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。 StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。 StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。 String内容不可变，StringBuffer和StringBuilder内容可变； StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用）； 如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 更多有关于他们之间区别，请参考：http://www.cnblogs.com/zuoxiaolong/p/lang1.html。 字符串拼接方式对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class StringTest &#123; /** * @desc 使用+、concat()、append()方法循环10W次 * @author chenssy * @data 2013-11-16 * @param args * @return void */ public static void main(String[] args) &#123; //+ long start_01 = System.currentTimeMillis(); String a = &quot;a&quot;; for(int i = 0 ; i &lt; 100000 ; i++)&#123; a += &quot;b&quot;; &#125; long end_01 = System.currentTimeMillis(); System.out.println(&quot; + 所消耗的时间：&quot; + (end_01 - start_01) + &quot;毫米&quot;); //concat() long start_02 = System.currentTimeMillis(); String c = &quot;c&quot;; for(int i = 0 ; i &lt; 100000 ; i++)&#123; c = c.concat(&quot;d&quot;); &#125; long end_02 = System.currentTimeMillis(); System.out.println(&quot;concat所消耗的时间：&quot; + (end_02 - start_02) + &quot;毫米&quot;); //append long start_03 = System.currentTimeMillis(); StringBuffer e = new StringBuffer(&quot;e&quot;); for(int i = 0 ; i &lt; 100000 ; i++)&#123; e.append(&quot;d&quot;); &#125; long end_03 = System.currentTimeMillis(); System.out.println(&quot;append所消耗的时间：&quot; + (end_03 - start_03) + &quot;毫米&quot;); &#125;&#125;------------Output: + 所消耗的时间：19080毫米concat所消耗的时间：9089毫米append所消耗的时间：10毫米 从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解: +方式拼接字符串 在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于 1str = new StringBuilder(str).append(&quot;b&quot;).toString(); 它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？ concat()方法拼接字符串 12345678910111213141516171819202122232425262728293031public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf); &#125; 这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。 （三）append()方法拼接字符串public synchronized StringBuffer append(String str) &#123; super.append(str); return this; &#125; StringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：public AbstractStringBuilder append(String str) &#123; if (str == null) str = &quot;null&quot;; int len = str.length(); if (len == 0) return this; int newCount = count + len; if (newCount &gt; value.length) expandCapacity(newCount); str.getChars(0, len, value, count); count = newCount; return this; &#125; 与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"排序算法三","slug":"java 排序算法三","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/11/22/java 排序算法三/","link":"","permalink":"http://zhangbuzola.cn/2017/11/22/java 排序算法三/","excerpt":"","text":"交换排序前面已回忆了简单的插入排序和选择排序两种算法，接下来就是交换（bubble、quick sort） 冒泡排序贴图 贴代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.algs_4th_xie.C2_Sort;public class BubbleSort &#123; /* * 冒泡排序 * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ public static void bubbleSort1(int[] a, int n) &#123; int i,j; for (i=n-1; i&gt;0; i--) &#123; // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换a[j]和a[j+1] int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; &#125; &#125; &#125; &#125; /* * 冒泡排序(改进版) * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ public static void bubbleSort2(int[] a, int n) &#123; int i,j; int flag; // 标记 for (i=n-1; i&gt;0; i--) &#123; flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换a[j]和a[j+1] int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = 1; // 若发生交换，则设标记为1 &#125; &#125; if (flag==0) break; // 若没发生交换，则说明数列已有序。 &#125; &#125; public static void main(String[] args) &#123; int i; int[] a = &#123;0,5,8,1,10,3&#125;; System.out.printf(&quot;before sort:&quot;); for (i=0; i&lt;a.length; i++) System.out.printf(&quot;%d &quot;, a[i]); System.out.printf(&quot;\\n&quot;); bubbleSort1(a, a.length); //bubbleSort2(a, a.length); System.out.printf(&quot;after sort:&quot;); for (i=0; i&lt;a.length; i++) System.out.printf(&quot;%d &quot;, a[i]); System.out.printf(&quot;\\n&quot;); &#125;&#125; 复杂度分析冒泡排序的时间复杂度是O(N2)。 假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度是O(N2)。 冒泡排序稳定性 冒泡排序是稳定的算法，它满足稳定算法的定义。 算法稳定性 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 快速排序贴图 贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.algs_4th_xie.C2_Sort;public class QuickSort &#123; /* * 快速排序 * * 参数说明： * a -- 待排序的数组 * l -- 数组的左边界(例如，从起始位置开始排序，则l=0) * r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1) */ public static void quickSort(int[] a, int l, int r) &#123; if (l &lt; r) &#123; int i,j,x; i = l; j = r; x = a[i]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt; x) j--; // 从右向左找第一个小于x的数 if(i &lt; j) a[i++] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt; x) i++; // 从左向右找第一个大于x的数 if(i &lt; j) a[j--] = a[i]; &#125; a[i] = x; quickSort(a, l, i-1); /* 递归调用 */ quickSort(a, i+1, r); /* 递归调用 */ &#125; &#125; public static void main(String[] args) &#123; int i; int a[] = &#123;30,40,60,10,20,50&#125;; System.out.printf(&quot;before sort:&quot;); for (i=0; i&lt;a.length; i++) System.out.printf(&quot;%d &quot;, a[i]); System.out.printf(&quot;\\n&quot;); quickSort(a, 0, a.length-1); System.out.printf(&quot;after sort:&quot;); for (i=0; i&lt;a.length; i++) System.out.printf(&quot;%d &quot;, a[i]); System.out.printf(&quot;\\n&quot;); &#125; &#125; 复杂度分析稳定性：不稳定的排序算法 时间复杂度：最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"}]},{"title":"排序算法二","slug":"java 排序算法四","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/11/22/java 排序算法四/","link":"","permalink":"http://zhangbuzola.cn/2017/11/22/java 排序算法四/","excerpt":"","text":"归并排序今天刚好是疲倦期了，因为又开始重新刷&lt;犯罪心理&gt;美剧了 贴图 复杂度分析复杂度：O(nlgn) 稳定性算法 缺点: 额外的N的空间排序 实现过程有两种方法：top-down and bottom-up,典型的分治算法 以一个具有15元素的数组为例,调用堆栈为: 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.algs_4th_xie.C2_Sort;public class MergeSort &#123;/**1. 从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)2. 从上往下的归并排序：它与&quot;从下往上&quot;在排序上是反方向的。它基本包括3步：① 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2; ② 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。③ 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。*/ public static void merge(int[] a, int start, int mid, int end) &#123; int[] temp = new int[end-start+1]; int i = start; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= end) &#123; if(a[i] &lt;= a[j]) &#123; temp[k++] = a[i++]; &#125; else &#123; temp[k++] = a[j++]; &#125; &#125; while(i &lt;= mid) &#123; temp[k++] = a[i++]; &#125; while(j &lt;= end) &#123; temp[k++] = a[j++]; &#125; // 将排序后的元素，全部整合到数组a中 for(i = 0; i &lt; k; i++) &#123; a[start+i] = temp[i]; &#125; temp = null; &#125; public static void mergeSort(int[] a, int s, int e) &#123; if(a == null || s &gt;= e) &#123; return ; &#125; int mid = (s + e) / 2; mergeSort(a, s, mid); // 递归排序a[s, mid] mergeSort(a, mid+1, e); merge(a, s, e, mid); // 两个单独有序数组排序成整有序数组 &#125; /* * 对数组a做若干次合并：数组a的总长度为len，将它分为若干个长度为gap的子数组； * 将&quot;每2个相邻的子数组&quot; 进行合并排序。 * * 参数说明： * a -- 待排序的数组 * len -- 数组的长度 * gap -- 子数组的长度 */ public static void mergeGroups(int[] a, int len, int gap) &#123; int i; int twolen = 2 * gap; // 两个相邻的子数组的长度 // 将&quot;每2个相邻的子数组&quot; 进行合并排序。 for(i = 0; i+2*gap-1 &lt; len; i+=(2*gap)) merge(a, i, i+gap-1, i+2*gap-1); // 若 i+gap-1 &lt; len-1，则剩余一个子数组没有配对。 // 将该子数组合并到已排序的数组中。 if ( i+gap-1 &lt; len-1) merge(a, i, i + gap - 1, len - 1); &#125; /* * 归并排序(从下往上) * * 参数说明： * a -- 待排序的数组 */ public static void mergeSortDown2Up(int[] a) &#123; if (a==null) return ; for(int n = 1; n &lt; a.length; n*=2) mergeGroups(a, a.length, n); &#125; public static void main(String[] args) &#123; int i; int a[] = &#123;80,30,60,40,20,10,50,70&#125;; System.out.printf(&quot;before sort:&quot;); for (i=0; i&lt;a.length; i++) System.out.printf(&quot;%d &quot;, a[i]); System.out.printf(&quot;\\n&quot;); mergeSort(a, 0, a.length-1); // 归并排序(从上往下) //mergeSortDown2Up(a); // 归并排序(从下往上) System.out.printf(&quot;after sort:&quot;); for (i=0; i&lt;a.length; i++) System.out.printf(&quot;%d &quot;, a[i]); System.out.printf(&quot;\\n&quot;); &#125; &#125; 补充归并排序有原地归并，自顶向下归并以及自下而上归并 原地归并的抽象方法 12345678910111213public static void merge(int[] a, int s, int e, int mid) &#123; int i = s, j = mid + 1; // 将a[s, mid]和s[mid+1, e]归并 for(int k = s, k &lt;= e; k++) &#123; aux[k] = a[k]; &#125; for(int k = s; k &lt;= e; k++) &#123; if(i &gt; mid) &#123;a[k] =aux[j++];&#125; if(j &gt; e) &#123;a[k]=aux[i++];&#125; else if(aux[j] &lt; aux[i]) &#123;a[k]=a[j++];&#125; else&#123;a[k] = a[i++];&#125; &#125;&#125; 几点改进 当划分到较小的子序列时候，通常使用插入排序替代合并排序 如果已经排好序了，就不用合并了 桶排序贴图 桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。 假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。 在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。 复杂度分析贴代码123456789101112131415161718192021222324252627282930313233343536373839package com.algs_4th_xie.C2_Sort;public class BucketSort &#123; public static void bucketSort(int[] a, int max) &#123; int[] buckets; if(a == null || max &lt; 1) &#123; return ; &#125; // 创造容量为max的数组buckets，并且将buckets中的所有数据初始化为0 buckets = new int[max]; // 计数 for(int i = 0; i &lt; a.length; i++) &#123; buckets[a[i]]++; &#125; // 排序 for(int i = 0, j = 0; i &lt; max; i++) &#123; while((buckets[i]--) &gt; 0) &#123; a[j++] = i; &#125; &#125; buckets = null; &#125; public static void main(String[] args) &#123; int m; int a[] = &#123;8,2,3,4,3,6,6,3,9&#125;; System.out.println(&quot;before sort: &quot;); for(int i = 0 ; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; System.out.println(); bucketSort(a, 10); // 排序 System.out.println(&quot;after sort: &quot;); for(int i = 0 ; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"}]},{"title":"java基础学习之引用","slug":"java基础之引用","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/11/22/java基础之引用/","link":"","permalink":"http://zhangbuzola.cn/2017/11/22/java基础之引用/","excerpt":"","text":"对象和对象引用其实就是一个地址：这个地址里面存的内容是真正内容的地址 123Int a = 1;A a = new A(); A a: 可以指向A类任何一个对象的引用， a并不是一个对象。 123Person person;person = new Person(&quot;张三&quot;);person = new Person(&quot;李四&quot;); 这里让person先指向了“张三”这个对象，然后又指向了“李四”这个对象。也就是说，Person person，这句话只是声明了一个Person类的引用，它可以指向任何Person类的实例。 123int a;a=2;a=3; 这里先声明了一个int类型的变量a，先对a赋值为2，后面又赋值为3.也就是说int类型的变量a，可以让它的值为2，也可以为3，只要是合法的int类型的数值即可。 四种引用方式为什么会有四种引用方式 第一是可以让程序员通过代码的方式决定某些对象的生命周期； 第二是有利于JVM进行垃圾回收。 强引用12A a = new A();String s = &quot;hello&quot;; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。 123456789public class Main &#123; public static void main(String[] args) &#123; new Main().fun1(); &#125; public void fun1() &#123; Object object = new Object(); Object[] objArr = new Object[1000]; &#125; 当运行至Object[] objArr = new Object[1000];这句时，如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。不过要注意的是，当fun1运行完之后，object和objArr都已经不存在了，所以它们指向的对象都会被JVM回收。如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。 比如： Vector类的clear方法中就是将引用赋值给null来实现清理工作。 软引用 SoftReference如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它； 如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。 SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。 也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。 另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。 12MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。 1aRef = null; 此后，这个MyObject对象成为了软引用对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。 Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过: 1MyObject anotherRef=(MyObject)aSoftRef.get(); 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。使用ReferenceQueue清除失去了软引用对象的SoftReference：作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如: 12ReferenceQueue queue = new ReferenceQueue(); SoftReference ref=new SoftReference(aMyObject, queue); 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。 在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为: 1234SoftReference ref = null; while ((ref = (EmployeeRef) q.poll()) != null) &#123; // 清除ref &#125; 软引用是我要细说的一个部分，先说一下软引用的一个引用目的，软引用的使用是与内存挂钩的一个引用类，主要应用于内存敏感的高速缓存，其实在Android中是经常使用的到的，由于Android的虚拟机是基于寄存器的Dalvik，它的堆大小只有16M，我们都清楚无论是Android应用程序，还是Java引用程序，在实例化对象的时候都是在堆中完成的…因此在Android中这个堆的大小要求确实是很苛刻的，一旦我们读取的资源数据过大，或者是内存里的对象由于声明的周期太长，没有被及时的释放，那么就很有可能造成OOM的发生…我们都知道GC的回收机制在正常的情况下并不是时时刻刻都在工作的，它的工作时间是不定期的，因此如果在GC不工作的期间我们的内存已经爆表，那就必定导致程序终止…OOM在Android是经常见到的一种情况，对象的不及时释放，static关键字的使用，线程不可控，还有最常见的就是在读取Bitmap的时候导致这种情况的发生… 那么OOM是一个非常严重的问题，但是如果内存得不到充分的使用，这个其实也是一个潜在的问题，SoftReference（软引用），其实给我的感觉就是为了解决这样的问题，每一个对象通过软引用进行实例化，那么这个对象的数据也就会被保存起来，当需要再次调用这个对象中的数据的时候，只需要通过对象的get()方法就可以获取到该对象所保存的数据信息，其实也会是我们所说的cache，当内存快要不足的时候，GC会迅速的把所有的软引用清除掉，释放内存空间…这样不仅结合了对象的cache，同时还解决了OOM的发生，一举两得…虽然说是一举两得的东西，保证了内存能够安全的被使用，那么相反就要牺牲效率，在每一个软引用对象被实例化的时候，其实还是需要耗费许多的时间的…因此到底如何运用，取决于我们遇到的问题. 弱引用 WeakReference弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例： 12345678910111213141516171819202122public class test &#123; public static void main(String[] args) &#123; WeakReference&lt;People&gt;reference=new WeakReference&lt;People&gt;(new People(&quot;zhouqian&quot;,20)); System.out.println(reference.get()); System.gc();//通知GVM回收资源 System.out.println(reference.get()); &#125; &#125; class People&#123; public String name; public int age; public People(String name,int age) &#123; this.name=name; this.age=age; &#125; @Override public String toString() &#123; return &quot;[name:&quot;+name+&quot;,age:&quot;+age+&quot;]&quot;; &#125; &#125; [name:zhouqian,age:20]null 第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。 12345678910111213141516171819202122232425import java.lang.ref.WeakReference; public class test &#123; public static void main(String[] args) &#123; People people=new People(&quot;zhouqian&quot;,20); WeakReference&lt;People&gt;reference=new WeakReference&lt;People&gt;(people);//&lt;span style=&quot;color:#FF0000;&quot;&gt;关联强引用&lt;/span&gt; System.out.println(reference.get()); System.gc(); System.out.println(reference.get()); &#125; &#125; class People&#123; public String name; public int age; public People(String name,int age) &#123; this.name=name; this.age=age; &#125; @Override public String toString() &#123; return &quot;[name:&quot;+name+&quot;,age:&quot;+age+&quot;]&quot;; &#125; &#125;//结果发生了很大的变化 [name:zhouqian,age:20] [name:zhouqian,age:20] 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。 虚引用 PhantomReference虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。 要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 123456789import java.lang.ref.PhantomReference; import java.lang.ref.ReferenceQueue; public class Main &#123; public static void main(String[] args) &#123; ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;(); PhantomReference&lt;String&gt; pr = new PhantomReference&lt;String&gt;(new String(&quot;hello&quot;), queue); System.out.println(pr.get()); &#125; &#125; 软引用和弱引用对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。 在SoftReference类中，有三个方法，两个构造方法和一个get方法（WekReference类似）： 两个构造方法： 12345678public SoftReference(T referent) &#123; super(referent); this.timestamp = clock; &#125; public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); this.timestamp = clock; &#125; get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。 在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。 使用软引用构建敏感数据的缓存 为什么需要使用软引用 首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。 如果使用软引用 SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。看下面代码: 12MyObject aRef = new MyObject();SoftReference aSoftRef=new SoftReference(aRef); 此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。随即，我们可以结束aReference对这个MyObject实例的强引用: 1aRef = null; 此后，这个MyObject对象成为了软可及对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过: 1MyObject anotherRef=(MyObject)aSoftRef.get(); 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。 使用ReferenceQueue清除失去了软引用对象的SoftReference 作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如: 12ReferenceQueue queue = new ReferenceQueue();SoftReference ref=new SoftReference(aMyObject, queue); 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为： 1234SoftReference ref = null;while ((ref = (EmployeeRef) q.poll()) != null) &#123; // 清除ref&#125; 理解了ReferenceQueue的工作机制之后，我们就可以开始构造一个Java对象的高速缓存器了。 通过软可及对象重获方法实现Java对象的高速缓存 利用Java2平台垃圾收集机制的特性以及前述的垃圾对象重获方法，我们通过一个雇员信息查询系统的小例子来说明如何构建一种高速缓存器来避免重复构建同一个对象带来的性能损失。我们将一个雇员的档案信息定义为一个Employee类: 123456789101112131415161718192021publicclass Employee &#123; private String id;// 雇员的标识号码 private String name;// 雇员姓名 private String department;// 该雇员所在部门 private String Phone;// 该雇员联系电话 privateintsalary;// 该雇员薪资 private String origin;// 该雇员信息的来源 // 构造方法 public Employee(String id) &#123; this.id = id; getDataFromlnfoCenter(); &#125; // 到数据库中取得雇员信息 privatevoid getDataFromlnfoCenter() &#123; // 和数据库建立连接井查询该雇员的信息，将查询结果赋值 // 给name，department，plone，salary等变量 // 同时将origin赋值为&quot;From DataBase&quot; &#125;…... 这个Employee类的构造方法中我们可以预见，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。下面是一个对Employee对象进行缓存的缓存器的定义: 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.lang.ref.ReferenceQueue;import java.lang.ref.SoftReference;import java.util.Hashtable;publicclass EmployeeCache &#123; staticprivate EmployeeCache cache;// 一个Cache实例 private Hashtable&lt;String,EmployeeRef&gt; employeeRefs;// 用于Chche内容的存储 private ReferenceQueue&lt;Employee&gt; q;// 垃圾Reference的队列 // 继承SoftReference，使得每一个实例都具有可识别的标识。 // 并且该标识与其在HashMap内的key相同。 privateclass EmployeeRef extends SoftReference&lt;Employee&gt; &#123; private String _key = &quot;&quot;; public EmployeeRef(Employee em, ReferenceQueue&lt;Employee&gt; q) &#123; super(em, q); _key = em.getID(); &#125; &#125; // 构建一个缓存器实例 private EmployeeCache() &#123; employeeRefs = new Hashtable&lt;String,EmployeeRef&gt;(); q = new ReferenceQueue&lt;Employee&gt;(); &#125; // 取得缓存器实例 publicstatic EmployeeCache getInstance() &#123; if (cache == null) &#123; cache = new EmployeeCache(); &#125; returncache; &#125; // 以软引用的方式对一个Employee对象的实例进行引用并保存该引用 privatevoid cacheEmployee(Employee em) &#123; cleanCache();// 清除垃圾引用 EmployeeRef ref = new EmployeeRef(em, q); employeeRefs.put(em.getID(), ref); &#125; // 依据所指定的ID号，重新获取相应Employee对象的实例 public Employee getEmployee(String ID) &#123; Employee em = null;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"排序算法二","slug":"java 排序算法二","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/11/21/java 排序算法二/","link":"","permalink":"http://zhangbuzola.cn/2017/11/21/java 排序算法二/","excerpt":"","text":"前面已经解释了插入排序的基本算法，并没有优化，后面再说吧 下面是有关选择排序的内容了，同样有两个简单的算法 简单选择排序算法贴图 操作方法： 第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换； 第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换； 以此类推….. 第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，直到整个序列按关键码有序。 复杂度分析贴代码123456789101112131415161718192021222324252627282930public class SimpleSelectSort &#123; public static int selectMink(int[] a, int n, int i) &#123; int k = i; for(int j = i + 1; j &lt; n; j++) &#123; if(a[k] &gt; a[j]) &#123; k = j; &#125; &#125; return k; &#125; public static int[] simpleSelectSort(int[] a, int n) &#123; int key, temp; for(int i = 0; i &lt; n; i++) &#123; key = selectMink(a, n, i); if(key != i) &#123; temp = a[i]; a[i] = a[key]; a[key] = temp; &#125; &#125; return a; &#125; public static void main(String[] args) &#123; int[] a = &#123;3,1,5,7,2,4,9,6&#125;; a = simpleSelectSort(a, a.length); for(int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; &#125;&#125; 堆排序堆是一棵顺序存储的二叉排序树；有小根堆和大根堆 贴图假设有一个无序序列：{1,3,4,5,2,6,9,7,8,0} 下面是堆排序的过程：主题思想已经贴在代码中了 下面是详细的堆排序过程： 复杂度分析贴代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class HeapSort &#123; /** * 堆排序 * 主要思想： * 首先根据初始的数组去构造大根堆或者小根堆，这里是大根堆（构建一个完全二叉树，保证所有的父亲节点比孩子节点大） * 每次交换第一个和最后一个元素,输出最后一个元素，（max） 然后再把剩下的元素重新调整为大根堆 * */ public void heapAdjust(int[] a, int p, int len) &#123; int temp = a[p]; //保存当前父亲节点 int child = 2 * p + 1; // 左孩子 while(child &lt; len) &#123; // 如果有右孩子节点，并且右孩子节点的值大于左孩子节点，则选择右孩子节点 if(child + 1&lt;len &amp;&amp;a[child] &lt; a[child + 1]) &#123; child++; &#125; // 如果父亲节点的值已经大于孩子节点的值，则直接结束 if(temp &gt;= a[child]) &#123; break; &#125; // 把孩子节点的值赋值给父亲节点 a[p] = a[child]; p = child; child = 2 * child + 1; &#125; a[p] = temp; &#125; public void heapSort(int[] a) &#123; for(int i = a.length / 2; i &gt;= 0; i--) &#123; heapAdjust(a, i, a.length); &#125; // 进行第n-1次循环，完成排序 for(int i = a.length -1; i &gt; 0; i--) &#123; // 最后一个元素和第一个元素交换 int temp = a[i]; a[i] = a[0]; a[0] = temp; // 筛选R[0]节点，得到第i-1个节点的堆 heapAdjust(a, 0, i); System.out.format(&quot;第%d趟： \\t&quot;, a.length-i); printPart(a, 0, a.length-1); &#125; &#125; // 打印序列 public void printPart(int[] list, int begin, int end) &#123; for (int i = 0; i &lt; begin; i++) &#123; System.out.print(&quot;\\t&quot;); &#125; for (int i = begin; i &lt;= end; i++) &#123; System.out.print(list[i] + &quot;\\t&quot;); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; // 初始化一个序列 int[] array = &#123;1, 3, 4, 5, 2, 6, 9, 7, 8, 0&#125;; // 调用快速排序方法 HeapSort heap = new HeapSort(); System.out.print(&quot;排序前:\\t&quot;); heap.printPart(array, 0, array.length - 1); heap.heapSort(array); System.out.print(&quot;排序后:\\t&quot;); heap.printPart(array, 0, array.length - 1); &#125;&#125; 二叉堆基本操作二叉堆是一个近似完全二叉树的结构，并同时满足堆积的性质：子节点的键值或者索引总是小于或者小于它的父节点。 二叉堆的表现形式:使用数组索引来表示元素在二叉堆的位置。 从二叉堆中，我们可以得出： 元素k的父节点所在的位置为[k/2] 元素k的子节点所在的位置为2k和2k+1 跟据以上规则，我们可以使用二维数组的索引来表示二叉堆。通过二叉堆，我们可以实现插入和删除最大值都达到O(nlogn)的时间复杂度。 对于堆来说，最大元素已经位于根节点，那么删除操作就是移除并返回根节点元素，这时候二叉堆就需要重新排列；当插入新的元素的时候，也需要重新排列二叉堆以满足二叉堆的定义。现在就来看这两种操作。 从下至上的重新建堆操作: 如果一个节点的值大于其父节点的值，那么该节点就需要上移，一直到满足该节点大于其两个子节点，而小于其根节点为止，从而达到使整个堆实现二叉堆的要求。 button-up reheapify 如果一个节点的值大于其父亲节点的值，那么该节点就需要上移，重复直到满足所有父亲节点小于其根节点，从而达到使整个二叉堆的要求 从上面的图呈现的就是从下往上建堆的过程，我们只需要将该元素k和其父元素k/2进行比较，如果比父元素大，则交换，然后迭代，一直到比父元素小为止。 123456private void swim(int k) &#123; // k子节点的索引 while(k &gt; 1 &amp;&amp; less(k/2, k)) &#123; exch(k, k/2); k = k / 2; &#125;&#125; 因此，如果要往堆中插入新的元素变成了从下往上重新建堆。 1234public static void Insert(T s) &#123; pq[++N] = s; swim(N);&#125; 动画过程: top-down heapify 当一个节点比其子节点要小的时候，就违反了二叉堆的定义，需要重新建堆 123456789private void sink(int k) &#123; while (2 * k &lt;= N) &#123; int j = 2 * k; if (j &lt; N &amp;&amp; less(j, j+1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125;&#125; 这样，移除并返回最大元素操作DelMax可以变为： 移除二叉堆根节点元素，并返回 将数组中最后一个元素放到根节点位置 然后对新的根节点元素进行Sink操作，直到满足二叉堆要求。 移除最大值并返回的操作如下图所示：","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"}]},{"title":"SSM框架搭建实践篇","slug":"java_SSM环境框架按键与配置详解","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/11/21/java_SSM环境框架按键与配置详解/","link":"","permalink":"http://zhangbuzola.cn/2017/11/21/java_SSM环境框架按键与配置详解/","excerpt":"","text":"SSM框架搭建SSM介绍SSM Spring + Spring MVC + Mybatis(再可以加上maven) 自己手动完整实践一次，把所有的相关配置文件理清 Spring: 详细的介绍可以参看Spring学习笔记，再就是参看官网的文档，其他同是如此。 具体的就不一一介绍了，可以移步学习笔记。 搭建环境eclipse + tomcat7.0 +jdk1.7 完整的结构框架如下:贴图 配置文件详解 web.xml 类文件 结构 小细节 新建web项目,web.xml文件没有引入 reason: https://jingyan.baidu.com/article/90808022c495d9fd91c80f15.html 解决办法: 1右键项目名称 -&gt; Java EE Tools -&gt; Generate Deployment descriptor stub clipse中格式化代码快捷键Ctrl+Shift+F失效 google了一下，有可能是输入法的快捷键有冲突。但是我的重新设置了还是无效，不知道什么原因了 http://blog.csdn.net/abbuggy/article/details/7016185 web.xml文件报错 仅仅是语法错误而已 注解学习 如何自动添加要实现的接口 新建类的时候记得添加，在输入框中输入要实现的接口就ok啦 如何新建properties文件，并且了解properties文件的用处 cmd控制台运行sql文件 再也可以不用去安装什么navicat了，安全软件总是报病毒情况，然后mysql就挂了，重装n次mysql了，不再追求视图效果了。 解决办法：source [sql文件路径全名] 熟记mysql的cmd命令","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://zhangbuzola.cn/tags/SSM/"}]},{"title":"排序算法一","slug":"java 排序算法一","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/11/21/java 排序算法一/","link":"","permalink":"http://zhangbuzola.cn/2017/11/21/java 排序算法一/","excerpt":"","text":"写在排序之前又是一轮开始复习算法，从来没坚持下来过 这次又是从头来过，希望自己忘掉之前的不努力，好好加油准备工作和论文的事情。。。现在的主线也就是这两个了 工作多刷牛客了，既可以打鸡血又可以多知道自己和别人的差距到底有多大，sad 论文毕业好好看论文，写代码，设计算法 下面进入正文，排序，排序主要有内部排序和外部排序两种，大学期间的算法课上接触的基本上都是内部排序 内部排序内部排序主要有： 插入排序（直接插入，希尔排序），选择排序（simple select、 堆排序），交换（bubble、quick sort）， 归并排序， 基数排序 下面先解释插入排序吧 直接插入排序贴图 复杂度分析贴代码1234567891011121314151617181920public static int[] directInsertSort(int[] arr, int n) &#123; /** * 基本思想: * 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。 * 即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。 * 要点：设立哨兵，作为临时存储和判断数组边界之用。 * 平均O(n^2),最好O(n),最坏O(n^2);空间复杂度O(1);稳定;简单 * */ for(int i = 1; i &lt; n; i++) &#123; for(int j = i; j &gt; 0; j--) &#123; if(arr[j] &lt; arr[j-1]) &#123; int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125; return arr;&#125; 希尔排序贴图 复杂度分析最好和平均复杂度 nlogn 最坏： n^2 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142public class ShellSort &#123; /** * 希尔排序也成为“缩小增量排序”，其基本原理是，现将待排序的数组元素分成多个子序列 * 使得每个子序列的元素个数相对较少，然后对各个子序列分别进行直接插入排序 * 待整个待排序列“基本有序”后，最后在对所有元素进行一次直接插入排序 * 因此，我们要采用跳跃分割的策略：将相距某个“增量”的记录组成一个子序列 * 这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序 * 而不是局部有序。希尔排序是对直接插入排序算法的优化和升级。 * 所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间 * 例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。 * 但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。 * * 最好和平均复杂度 nlogn 最坏： n^2 * **/ public static int[] shellSort(int[] a) &#123; int j = 0; int temp = 0; for(int increment = a.length / 2; increment &gt; 0; increment /= 2) &#123; System.out.println(&quot;increment: &quot; + increment); for(int i = increment; i &lt; a.length; i++) &#123; temp = a[i]; for(j = i - increment; j &gt;= 0; j -= increment) &#123; if(temp &lt; a[j]) &#123; a[j+increment] = a[j]; &#125; else &#123; break; &#125; &#125; a[j+increment] = temp; &#125; &#125; return a; &#125; public static void main(String[] args) &#123; int[] a = &#123;26, 53, 67, 48, 57, 13, 48, 32, 60, 50&#125;; a = shellSort(a); for(int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + &quot; &quot;); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://zhangbuzola.cn/categories/算法/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://zhangbuzola.cn/tags/算法和数据结构/"}]},{"title":"理解值传递/引用传递","slug":"值传递引用传递","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2017/11/20/值传递引用传递/","link":"","permalink":"http://zhangbuzola.cn/2017/11/20/值传递引用传递/","excerpt":"","text":"值传递和引用传递的问题，一直在本科的时候也不是很明白，在这里总结一下。 值传递值传递是说在方法调用的时候，传递的参数是按值进行拷贝传递。形参和实参是没有关系的。 方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值。 1234567891011121314151617public class TempTest &#123; private void test1(int a)&#123; //做点事情 a = 5; System.out.println(&quot;test1方法中的a=&quot;+a); &#125; public static void main(String[] args) &#123; TempTest t = new TempTest(); int a = 3; t.test1(a);//这里传递的参数a就是按值传递 System.out.println(”main方法中的a=”+a); // 传递以后，test1方法对变量值得改变不影响这里a &#125;&#125;// ----------------------------test1方法中的a=5main方法中的a=3 引用传递引用传递是指：在方法调用时，传递的参数是按引用（地址）进行传递的。也就是变量所对应的内存空间的地址。 也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址；在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。 123456789101112public class TempTest &#123; private void test1(A a)&#123; &#125; public static void main(String[] args) &#123; TempTest t = new TempTest(); A a = new A(); t.test1(a); //这里传递的参数a就是按引用传递 &#125;&#125;class A&#123; public int age = 0;&#125; 所以如果指向的是同一个内存地址，如果里面的内容改变，是会有影响的。 1234567891011121314151617181920 public class TempTest &#123; private void test1(A a)&#123; a.age = 20; System.out.println(&quot;test1方法中的age=&quot;+a.age); &#125; public static void main(String[] args) &#123; TempTest t = new TempTest(); A a = new A(); a.age = 10; t.test1(a); System.out.println(”main方法中的age=”+a.age); &#125; &#125; class A&#123; public int age = 0; &#125;// ------------------------------test1方法中的age=20main方法中的age=20 要想正确理解按引用传递的过程，就必须学会理解内存分配的过程，内存分配示意图可以辅助我们去理解这个过程。 两者区别 ”在Java里面参数传递都是按值传递“ 这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。 在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。就是直接使用双引号定义字符串方式：String str = “Java私塾”; 12int num = 20;String str = &quot;hello&quot;; num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）。 1234567891011121314151617181920212223242526第一个例子：基本类型void foo(int value) &#123; value = 100;&#125;foo(num); // num 没有被改变第二个例子：没有提供改变自身方法的引用类型void foo(String text) &#123; text = &quot;windows&quot;;&#125;foo(str); // str 也没有被改变第三个例子：提供了改变自身方法的引用类型StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder.append(&quot;4&quot;);&#125;foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder = new StringBuilder(&quot;ipad&quot;);&#125;foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。 参考https://www.zhihu.com/question/31203609 https://www.cnblogs.com/binyue/p/3862276.html https://blog.csdn.net/morgerton/article/details/54908592","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之接口","slug":"javabase_interface","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2017/11/20/javabase_interface/","link":"","permalink":"http://zhangbuzola.cn/2017/11/20/javabase_interface/","excerpt":"","text":"接口接口概念interface: 抽象方法的集合，一个类通过实现接口的方式，来继承接口的抽象方法。 接口并不是类，类描述对象的属性和方法。接口则是包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则必须声明为抽象类。另外java中，接口类型可以用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口实现 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 123456789[可见度] interface 接口名称 [extends 其他的类名] &#123; // 声明变量 // 抽象方法&#125;(public) interface Animal &#123; public void eat(); public void travel();&#125; 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。s 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 继承一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports&#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125; // 文件名: Football.javapublic interface Football extends Sports&#123; public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);&#125; // 文件名: Hockey.javapublic interface Hockey extends Sports&#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; 支持接口之间多继承，类不能继承接口，而是要实现接口，允许一个类同时实现多个接口。 接口与类相同点 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。（接口之间多继承） 接口和普通类接口和抽象类 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口的作用 接口只是一个规范 不如直接在类中实现接口中的抽象方法，那不是更方便吗？这个是有问题的。因为当多个类拥有同样的一些方法的时候，相当于百姓遇到法律问题的时候，都需要律师这个角色去帮他们完成一些事情一样。你不可能要求所有人都要有律师的功能。 “接口+实现”最常见的优势就是实现类和接口分离，在更换实现类的时候，不用更换接口功能。 定义接口对于做单元测试也非常有帮助。 对于不需要频繁更变实现类的方法，是不是就可以不用写接口了？ 答案是No。整个系统架构的代码可以单纯认为有四部分构成。Model+Interface+Service+UtilModel是纯粹的Pojo，贫血模型，Inteface和Service是接口和实现分开的，Util是全项目通用，或者是跨项目通用的，跟业务逻辑没有任何关系的。 写接口最大的好处就是在你写的Controller代码，或者是Service里的主要业务逻辑代码的时候，屏蔽掉细节。写一个业务逻辑的时候，比如说修真院的加入班级。第一步，做校验，用户是否为空，班级是否不存在，是否已经加入了班级等等。第二步，更新班级和用户的关系表，更新班级总人数，更新职业总人数，更新用户的最新班级ID。第三步，发送系统通知，告知用户加入班级成功。如果说不用接口，只用实现类的话，第一种方式就是把所有的代码都写在这个Controller里去，代码会非常非常繁琐，一个函数突破几千行轻轻松松，而且改动起来很麻烦。第二种方式就是抽象出来函数。这种方式在某种程度上能够解决代码块大的问题，但是你必须要New一个实现类出来，想想在上述逻辑中，需要new几个实现类？这些实现类就会被New的各处都是，甚至改个名字都很蛋疼。 但是如果你使用接口的话，你会发现，接口是强制于你去将复杂的业务逻辑抽象成具体做的事儿。比如说： 1if(user==null)&#123; // to do something&#125;就变成了CheckUser（uid） 实现类也明确了自已要做的事情。从某种程度上来说，抽象成一个私有方法也能解决这个问题，但是一般都会推荐，如果你发现你写了很多私有方法，要么是他们可以继续演化成一个util，要么是可以成为一个Service。 一是实现多重继承，因为java是单根语言。 二是便于实现各种框架，java 的各种框架中，都是拿接口调来调去。一旦你实现了这个接口，你的代码就嵌入了框架。 三是为了实现前面各位说的规范。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之this和super关键字","slug":"Java基础之ThisSuper","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2017/11/19/Java基础之ThisSuper/","link":"","permalink":"http://zhangbuzola.cn/2017/11/19/Java基础之ThisSuper/","excerpt":"","text":"this 关键字关键字解释首先你要知道在一个类中无论是写入方法还是属性等，肯定是要被外界引用到的(private 等被保护的除外)，要是想在类的外部调用方法或是属性，需要一个引用类型指向一个new的对象，如HelloWorld h=new HelloWorld()；中的“h”，但是如果你要想再一个类的内部使用该类的方法、属性、构造器等，java提供了一个简单的方法–this关键字。写入一个例子看了就很好理解了。 123456789101112131415public String str = &quot;test01&quot;; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; // System.out.println(this); this.str = str; &#125; public void getInfo()&#123; System.out.println(this.str); &#125; &#125; 12345678910111213141516171819202122232425public class Test01_main &#123; public static void main(String [] args)&#123; Test01 t=new Test01(); //在Test01类的内部，调用Test01类中的str属性。 t.getInfo(); //在Test01_main类的中，调用Test01类中的str属性。 System.out.println(t.str); //对 Test01中的属性进行更改 t.setStr(&quot;new test01&quot;); //通过Test01类中查看属性 t.getInfo(); //通过外部方法查看s属性 System.out.println(t.str); &#125;&#125;// --------------------------------test01test01new test01new test01 this一般是在方法体中使用。 它实现了在类的内部调用该类的方法或属性。 在一个构造函数中调用本身的另一个构造函数。 当类没有被new是，并不知道this指向的是哪个对象，所以不能与static一起使用，因为被static修饰的方法是随类生成时生成的，不能被new。 this是对对象本身进行调用 12345678910111213public class Test02 &#123; public void getInfo()&#123; System.out.println(this); &#125; public static void main(String []args)&#123; Test02 t=new Test02(); t.getInfo(); System.out.println(t); &#125;&#125;// --------------------------------com.lava.test.Test02@368102c8com.lava.test.Test02@368102c8 主要应用this关键字主要有三个应用： this调用本类中的属性，也就是类中的成员变量； this调用本类中的其他方法； this调用本类中的其他构造方法，调用时要放在构造方法的首行。 super关键字super关键字的作用： 主要存在于子类方法中，用于指向子类对象中父类对象。 访问父类的属性 访问父类的函数 访问父类的构造函数 this和super很像，this指向的是当前对象的调用，super指向的是当前调用对象的父类。类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行子类相应构造创建了一个子类对象，该子类对象还包含了一个父类对象。该父类对象在子类对象内部。this super只能在有对象的前提下使用，不能在静态上下文使用。 1234567891011121314151617181920212223242526272829303132333435class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt(&quot;父类·无参数构造方法： &quot;+&quot;A Person.&quot;); &#125;//构造方法(1) Person(String name) &#123; prt(&quot;父类·含一个参数的构造方法： &quot;+&quot;A person&apos;s name is &quot; + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt(&quot;子类·调用父类”无参数构造方法“： &quot;+&quot;A chinese coder.&quot;); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt(&quot;子类·调用父类”含一个参数的构造方法“： &quot;+&quot;his name is &quot; + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt(&quot;子类：调用子类具有相同形参的构造方法：his age is &quot; + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese(&quot;codersai&quot;); cn = new Chinese(&quot;codersai&quot;, 18); &#125; &#125; 运行结果： 1234567父类·无参数构造方法： A Person.子类·调用父类”无参数构造方法“： A chinese coder.父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 super和this的异同 super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super()和this()均需放在构造方法内第一行。尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之编译与运行","slug":"java基础之编译","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/11/15/java基础之编译/","link":"","permalink":"http://zhangbuzola.cn/2017/11/15/java基础之编译/","excerpt":"","text":"从我们写好了一个java文件，不论是简单的还是复杂的，在我们点击run的时候，java程序是如何编译以及运行过程是如何初始化的，在这里做一下一些自己的感想。其中也有一些是参考别人的。 java程序从源文件创建到程序运行要经过两大步骤： 源文件（java文件）由编译器编译成字节码（class文件） 字节码由java虚拟机解释执行。因为java程序员在编译的同时也要经过jvm的解释运行，所以说java被称为半解释语言（”semi-interruptted language”） 第一步(编译): 创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用（方法引用，成员变量引用等等）；方法字节码放的是类中各个方法的字节码。下面是MainApp.class通过反汇编的结果，我们可以清楚看到.class文件的结构： 第二步（运行）：java类运行的过程大概可分为两个过程：1、类的加载 2、类的执行。需要说明的是：JVM主要在程序第一次主动使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。 简单的例子1234567891011121314151617public class MainApp &#123; public static void main(String[] args) &#123; Animal animal = new Animal(&quot;Puppy&quot;); animal.printName(); &#125; &#125; //Animal.java public class Animal &#123; public String name; public Animal(String name) &#123; this.name = name; &#125; public void printName() &#123; System.out.println(&quot;Animal [&quot;+name+&quot;]&quot;); &#125; &#125; 下面是程序运行的详细步骤： 在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。 然后JVM找到AppMain的主函数入口，开始执行main函数。 main函数的第一条命令是Animal animal = new Animal(“Puppy”);就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。 加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存, 然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。 当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。 开始运行printName()函数。 特别说明：java类中所有public和protected的实例方法都采用动态绑定机制，所有私有方法、静态方法、构造器及初始化方法都是采用静态绑定机制。而使用动态绑定机制的时候会用到方法表，静态绑定时并不会用到。本文只是讲述java程序运行的大概过程，所以并没有细加区分。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之多态","slug":"java基础之多态","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2017/11/13/java基础之多态/","link":"","permalink":"http://zhangbuzola.cn/2017/11/13/java基础之多态/","excerpt":"","text":"多态的概念程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 向上转型指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用） 定义多态指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现技术动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 多态的作用 消除类型之间的耦合关系 存在的前提 继续关系 子类重写父类方法 父类引用指向子类 多态情况成员访问 成员变量 编译要看父类，运行看父类 成员方法 编译看父类，运行看子类 静态方法 编译看父类，运行看父类 所以说只有非静态的成员方法，在运行时候回出现多态情况。 多态的好与坏多态的好处 可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。 可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。 接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。 灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。 简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 多态的坏处不能使用子类特有的成员属性和子类特有的成员方法 经典例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 public class A &#123; public String show(D obj) &#123; return (&quot;A and D&quot;); &#125; public String show(A obj) &#123; return (&quot;A and A&quot;); &#125; &#125; public class B extends A&#123; public String show(B obj)&#123; return (&quot;B and B&quot;); &#125; public String show(A obj)&#123; return (&quot;B and A&quot;); &#125; &#125; public class C extends B&#123; &#125; public class D extends B&#123; &#125; public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(&quot;1--&quot; + a1.show(b)); System.out.println(&quot;2--&quot; + a1.show(c)); System.out.println(&quot;3--&quot; + a1.show(d)); System.out.println(&quot;4--&quot; + a2.show(b)); //4--B and A .首先a2是A引用，B实例，调用show（B b）方法，此方法在父类A中没有定义，所以B中方法show(B b)不会调用（多态必须父类中已定义该方法），再按优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)，即先查this对象的父类，没有重头再查参数的父类。查找super.show((super)O)时，B中没有，再向上，找到A中show(A a),因此执行。 System.out.println(&quot;5--&quot; + a2.show(c)); //同上 System.out.println(&quot;6--&quot; + a2.show(d)); //A and D .查找B中没有show(D d)方法，再查A中，有，执行。 System.out.println(&quot;7--&quot; + b.show(b)); System.out.println(&quot;8--&quot; + b.show(c)); //B and B . System.out.println(&quot;9--&quot; + b.show(d)); &#125; &#125; // ---------------------------- 1--A and A 2--A and A 3--A and D 4--B and A 5--B and A 6--A and D 7--B and B 8--B and B 9--A and D 参考http://cmsblogs.com/?p=52","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之内部类","slug":"java基础之内部类","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2017/11/12/java基础之内部类/","link":"","permalink":"http://zhangbuzola.cn/2017/11/12/java基础之内部类/","excerpt":"","text":"内部类对这部分的内容还未做总结，先贴上自己看的博客吧。帮助理解。 http://cmsblogs.com/?p=63 http://cmsblogs.com/?p=68","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之初始化","slug":"java基础之初始化","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2017/11/10/java基础之初始化/","link":"","permalink":"http://zhangbuzola.cn/2017/11/10/java基础之初始化/","excerpt":"","text":"初始化顺序java程序初始化工作可以在许多不同的代码块中来完成（例如：静态代码块、构造函数等），他们执行的顺序如下： 父类静态变量 父类静态代码块 子类静态变量 子类静态代码块 父类非静态变量 父类非静态代码块 父类构造器 子类非静态变量 子类非静态代码块 子类构造器 Java程序初始化一般遵循3个原则 静态对象（变量）先于非静态对象（变量）初始化。其中静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化很多次 父类优先于子类进行初始化 按照成员变量的定义顺序进行初始化。即使变量定义散布于方法之中，他们依然在任何方法（包括构造函数）被调用前先初始化 参考https://www.zhihu.com/question/49196023","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之类与对象","slug":"javabase_class","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/11/09/javabase_class/","link":"","permalink":"http://zhangbuzola.cn/2017/11/09/javabase_class/","excerpt":"","text":"类与对象Class与ObjectClass类java在程序运行期间，系统会一直为所有的对象维护一个被称为运行时的类型标识。这个信息保存着每个对象所属的类足迹。通过专门的java类访问这些信息，保存这些信息的类被称为Class。 Object类中有一个getClass()方法会返回一个Class类的实例。Class 类是在Java语言中定义一个特定类的实现。一个类的定义包含成员变量，成员方法，还有这个类实现的接口，以及这个类的父类。Class类的对象用于表示当前运行的 Java 应用程序中的类和接口。 比如：每个数组均属于一个 Class 类对象，所有具有相同元素类型和维数的数组共享一个Class 对象。基本的 Java 类型(boolean, byte, char, short,int, long, float 和 double) 和 void 类型也可表示为 Class 对象。 所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass().这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象。我们自己无法生成一个Class对象（构造函数为private)，而这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。 我们生成的对象都会有个字段记录该对象所属类在CLass类的对象的所在位置。如下图所示： jvm为每种类管理者独一的Class对象。因此我们可以用双等号操作符来比较对象：a1.getClass()==A.class;应该返回的是true。 12forName(String classname);forName(String classname，&#123;*&#125;boolean initialze,*ClassLoader *loader); 该方法返回给定串名相应的Class对象。若给定一个类或接口的完整路径名，那么此方法将试图定位、装载和连接该类。若成功，返回该类对象。否则，抛出ClassNotFoundException异常。例如，下面代码段返回名为java.lang.Thread的运行Class描述器。Classt=Class.forName(“java.lang.Thread”);此方法是需要指定类加载器的，当用到仅有一个String参数的forName方法时，Class对象将默认调用当前类加载器作为加载器和将第二参数为true。第二个参数说明：如果是false时，调用forName方法只是在命令类加载器载入该类，而不初始化该类的静态区块，只有当该类第一次实例化时，静态区块才被调用。当为true时，则载入时就调用静态区块。Class类源码分析： 123456789/* * Private constructor. * Only the Java Virtual Machine * creates Class objects. */ private Class(ClassLoader loader) &#123; classLoader = loader; &#125;// Class类的构造方法，有删减 Class的构造方法是私有的，只有java虚拟机可以创建该类的对象，因此我们无法在代码中显式地声明一个Class对象。（不能new出一个Class对象）。但是有其他方式可以得到Class对象。 123456789101112131415161718192021class MyClass&#123;&#125;MyClass mClass1 = new MyClass();// 1. 其他类来得到Class的对象// 每个类都有一个静态成员classClass c1 = MyClass.class;// 2. 对象的getClass()方法Class c2 = mClass1.getClass();// 3. 通过 Class 类的静态方法 forName() 方法获取 Class 的对象// 区别于通过 new 创建对象（编译时静态加载），// 在开发时如果我们需要动态加载我们的功能模块，该方法可以帮助我们实现在程序运行时类的动态加载。try &#123; //注意，forName()需要传入类的全路径 //如果当前类与参数类在同一包下即可省略包名 mClass = Class.forName(&quot;custom.OtherClass&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;// 如果我们的程序中没有 OtherClass 这个类，使用 Class.forName() 动态加载时，// 在程序编译时刻是不会报错的，只有在运行时刻检测到没有该类才会出错。 通过类或类对象得到 Class 类的对象，反过来，我们也可以由 Class 类的对象得到类的对象。 1MyClass mClass2 = (MyClass)c2.newInstance(); c2.newInstance() 需要调用 MyClass 类的无参构造方法！如果 MyClass 类中存在显示的有参构造方法，会覆盖默认的无参构造方法，同时又没有显示的声明无参构造方法，那么执行这段代码时会直接导致程序Crash掉。 Class类是反射机制的基础，所以关于反射机制的学习。参看另一篇java基础学习之反射机制。 以及学习类加载器ClassLoader finalize方法 finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性 之前 java的GC只负责内存相关的清理，所有其它资源的清理必须由程序员手工完成。要不然会引起资源泄露，有可能导致程序崩溃。 调用GC并不保证GC实际执行。 finalize抛出的未捕获异常只会导致该对象的finalize执行退出。 用户可以自己调用对象的finalize方法，但是这种调用是正常的方法调用，和对象的销毁过程无关。 JVM保证在一个对象所占用的内存被回收之前，如果它实现了finalize方法，则该方法一定会被调用。Object的默认finalize什么都不做。为了效率，GC可以认为一个什么都不做的finalize不存在。 对象的finalize调用链和clone调用链一样，必须手工构造。 注意事项 一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法。 System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们。 Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行。 finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行。 对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的。 finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)。 执行过程(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。 (2) 具体的finalize流程： 对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下： unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的 finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行 finalized: 表示GC已经对该对象执行过finalize方法 reachable: 表示GC Roots引用可达 finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达 unreachable：对象不可通过上面两种途径可达 变迁说明： 新建对象首先处于[reachable, unfinalized]状态(A) 随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态 若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。 在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N) 处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因 程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为 若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O） 注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法 对象重生1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class C &#123; static A a;&#125;class A &#123; B b; public A(B b) &#123; this.b = b; &#125; @Override public void finalize() &#123; System.out.println(&quot;A finalize&quot;); C.a = this; &#125;&#125;class B &#123; String name; int age; public B(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public void finalize() &#123; System.out.println(&quot;B finalize&quot;); &#125; @Override public String toString() &#123; return name + &quot; is &quot; + age; &#125;&#125;public class Main &#123; public static void main(String[] args) throws Exception &#123; A a = new A(new B(&quot;allen&quot;, 20)); a = null; System.gc(); Thread.sleep(5000); System.out.println(C.a.b); &#125;&#125;// expected outputA finalize B finalize allen is 20 对象的finalize的执行顺序所有finalizable的对象的finalize的执行是不确定的，既不确定由哪个线程执行，也不确定执行的顺序。考虑以下情况就明白为什么了，实例a,b,c是一组相互循环引用的finalizable对象。 何时及如何使用finalize从以上的分析得出，以下结论。 最重要的，尽量不要用finalize，太复杂了，还是让系统照管比较好。可以定义其它的方法来释放非内存资源。 如果用，尽量简单。 如果用，避免对象再生，这个是自己给自己找麻烦。 可以用来保护非内存资源被释放。即使我们定义了其它的方法来释放非内存资源，但是其它人未必会调用该方法来释放。在finalize里面可以检查一下，如果没有释放就释放好了，晚释放总比不释放好。 即使对象的finalize已经运行了，不能保证该对象被销毁。要实现一些保证对象彻底被销毁时的动作，只能依赖于java.lang.ref里面的类和GC交互了。 修饰符Java语言中提供的修饰符主要分为以下两类： 访问修饰符 非访问修饰符 访问修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。 default：默认的，也称为default，在同一包内可见，不使用任何修饰符。 private：私有的，以private修饰符指定，在同一类内可见。 私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。Private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。 public：共有的，以public修饰符指定，对所有类可见。 protected：受保护的，以protected修饰符指定，对同一包内的类和所有子类可见。 用的时候呢，尽量private; 留给子类用，要用protected; 确实要公开的，用public; 默认的一般都不用实在不知道用啥，就用private，错了再改。 贯彻一个宗旨:尽可能的封装 或者:数据私有化，方法公有化 访问控制和继承请注意以下方法继承的规则： 父类中声明为public的方法在子类中也必须为public。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。 父类中默认修饰符声明的方法，能够在子类中声明为private。 父类中声明为private的方法，不能够被继承。 非访问修饰符final final变量 Final变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变。也就是说final对象的引用不能改变，但是里面的值可以改变。 Final修饰符通常和static修饰符一起使用来创建类常量。 实例: 12345678910public class Test&#123; final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = &quot;Manager&quot;; public void changeValue()&#123; value = 12; //将输出一个错误 &#125;&#125; final方法 类中的Final方法可以被子类继承，但是不能被子类修改。 声明final方法的主要目的是防止该方法的内容被修改。 如下所示，使用final修饰符声明方法。 12345public class Test&#123; public final void changeName()&#123; // 方法体 &#125;&#125; final类 Final类不能被继承，没有类能够继承final类的任何特性。 实例： 123public final class Test &#123; // 类体&#125; static 静态变量：Static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被成为类变量。局部变量能被声明为static变量。 静态方法：Static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 abstract修饰符 抽象类 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成final和strict。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample(); Synchronized修饰符Synchronized关键字声明的方法同一时间只能被一个线程访问。Synchronized修饰符可以应用于四个访问修饰符。 实例： 123public synchronized void showDetails()&#123;.......&#125; Transient修饰符序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 实例： 12public transient int limit = 55; // will not persistpublic int b; // will persist volatile修饰符Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。 实例： 12345678910111213141516public class MyRunnable implements Runnable&#123; private volatile boolean active; public void run() &#123; active = true; while (active) // line 1 &#123; // 代码 &#125; &#125; public void stop() &#123; active = false; // line 2 &#125;&#125; 一般地，在一个线程中调用run()方法，在另一个线程中调用stop()方法。如果line 1中的active位于缓冲区的值被使用，那么当把line 2中的active设置成false时，循环也不会停止 继承概念继承是一种构建新类的方式，他是基于已有的类的定义为基础，构建新的类，已有的类称为父类，新构建的类称为子类，子类能调用父类的非private修饰的成员，同时还可以自己添加一些新的成员，扩充父类，甚至重写父类已有的方法，更其表现符合子类的特征。让子类的表现更独特，更专业。 实现extends关键字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Student &#123; private String name; private String age; private String handleName(String name)&#123; return &quot;I&apos;m &quot; + name; &#125; private String handleAge(String age) &#123; return age + &quot; 岁&quot;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = handleName(name); &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = handleAge(age); &#125;&#125;public class Boys extends Student &#123; @Override public void setName(String name) &#123; super.setName(name); &#125; @Override public String getAge() &#123; return super.getAge(); &#125; @Override public String getName() &#123; return super.getName(); &#125; @Override public void setAge(String age) &#123; super.setAge(age); &#125;&#125; 关键字super，这个关键字与this相似，不过super表明调用方法的对象是父类的对象，那这段自动生成的代码的意思就是如果我们不添加新的内容，那么当我们子类调用这些方法的时候，执行的是父类的方法。同时我们在这个方法上面看见一个注解 @Override这表明这个方法是覆盖父类的方法，而不是方法重载。 多态重载与重写重载overloading 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载是一个类中多态性的一种表现。 Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型给它们的不同参数个数和参数类型给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。 重写override 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Override)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。 若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。 子类函数的访问修饰权限不能少于父类的。 方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同；如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载。Overloaded的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同。 附录：动态绑定即调用对象方法的机制 编译器检查对象声明的类型和方法名，从而获取所有候选方法。试着把上例Base类的test注释掉，这时再编译就无法通过。 重载决策：编译器检查方法调用的参数类型，从上述候选方法选出唯一的那一个（其间会有隐含类型转化）。如果编译器找到多于一个或者没找到，此时编译器就会报错。试着把上例Base类的test(byte b)注释掉，这时运行结果是1 1。 若方法类型为priavte static final ，java采用静态编译，编译器会准确知道该调用哪个方法。 当程序运行并且使用动态绑定来调用一个方法时，那么虚拟机必须调用对象的实际类型相匹配的方法版本。在例子中，b所指向的实际类型是TestOverriding，所以b.test(0)调用子类的test。但是，子类并没有重写test(byte b)，所以b.test((byte)0)调用的是父类的test(byte b)。如果把父类的(byte b)注释掉，则通过第二步隐含类型转化为int,最终调用的是子类的test(int i)。 多态父类引用指向子类对象，调用方法时会调用子类的实现，而不是父类的实现，这叫多态。我理解的多态与继承体系有关，与方法覆盖有关，与方法重载无关。 父类引用指向子类对象，调用方法时会调用子类的实现，而不是父类的实现，这叫多态。 动态绑定动态绑定（后期绑定）是指：在程序运行过程中，根据具体的实例对象才能具体确定是哪个方法。 动态绑定是多态性得以实现的重要因素，它通过方法表来实现：每个类被加载到虚拟机时，在方法区保存元数据，其中，包括一个叫做 方法表（method table）的东西，表中记录了这个类定义的方法的指针，每个表项指向一个具体的方法代码。如果这个类重写了父类中的某个方法，则对应表项指向新的代码实现处。从父类继承来的方法位于子类定义的方法的前面。 动态绑定语句的编译、运行原理：我们假设 Father ft=new Son(); ft.say(); Son继承自Father，重写了say()。 编译：我们知道，向上转型时，用父类引用执行子类对象，并可以用父类引用调用子类中重写了的同名方法。但是不能调用子类中新增的方法，为什么呢？ 因为在代码的编译阶段，编译器通过 声明对象的类型（即引用本身的类型） 在方法区中该类型的方法表中查找匹配的方法（最佳匹配法：参数类型最接近的被调用），如果有则编译通过。（这里是根据声明的对象类型来查找的，所以此处是查找 Father类的方法表，而Father类方法表中是没有子类新增的方法的，所以不能调用。） 编译阶段是确保方法的存在性，保证程序能顺利、安全运行。 运行：我们又知道，ft.say()调用的是Son中的say()，这不就与上面说的，查找Father类的方法表的匹配方法矛盾了吗？不，这里就是动态绑定机制的真正体现。 上面编译阶段在 声明对象类型 的方法表中查找方法，只是为了安全地通过编译（也为了检验方法是否是存在的）。而在实际运行这条语句时，在执行 Father ft=new Son(); 这一句时创建了一个Son实例对象，然后在 ft.say() 调用方法时，JVM会把刚才的son对象压入操作数栈，用它来进行调用。而用实例对象进行方法调用的过程就是动态绑定：根据实例对象所属的类型去查找它的方法表，找到匹配的方法进行调用。我们知道，子类中如果重写了父类的方法，则方法表中同名表项会指向子类的方法代码；若无重写，则按照父类中的方法表顺序保存在子类方法表中。故此：动态绑定根据对象的类型的方法表查找方法是一定会匹配（因为编译时在父类方法表中以及查找并匹配成功了，说明方法是存在的。这也解释了为何向上转型时父类引用不能调用子类新增的方法：在父类方法表中必须先对这个方法的存在性进行检验，如果在运行时才检验就容易出危险——可能子类中也没有这个方法）。 程序在JVM运行过程中，会把类的类型信息、static属性和方法、final常量等元数据加载到方法区，这些在类被加载时就已经知道，不需对象的创建就能访问的，就是静态绑定的内容；需要等对象创建出来，使用时根据堆中的实例对象的类型才进行取用的就是动态绑定的内容。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"深入理解java虚拟机part1","slug":"javabase_jvm","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/10/24/javabase_jvm/","link":"","permalink":"http://zhangbuzola.cn/2017/10/24/javabase_jvm/","excerpt":"","text":"深入理解java虚拟机oart1java内存区域首先，区别于java内存模型及运行时内存区域，java内存模型主要分为存储器和工作存储器，Java管理的内存也分为堆、虚拟机栈、方法区等。Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干不同数据区域。 （运行时数据区域）。两者并没有什么关系。 运行时数据区域java程序的执行过程是： 上面图可以看出jvm就是处理由类加载器加载进来的各类class字节码文件。在程序执行过程中，jvm会用一段空间来存储程序执行期间定义的各类变量和方法数据等相关信息。运行时数据区就是java内存。内存管理就是对这一片空间进行管理的，比如如何分配以及回收内存空间等等。 运行时数据区分为： 下面对运行时区域的每一部分存储的信息进行详细的说明。 程序计数器程序计数器，也称为PC寄存器。汇编中，程序计数器指的是CPU中的寄存器，它保存的是程序当前执行的指令地址，也可以说是保存下一条指令的缩在存储单元的地址。当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。 虽然java jvm中的程序计数器并不是CPU中的寄存器，但是其实功能在逻辑上是一样的。 由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。 在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。 由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。 程序计数器（Program Counter Register）是JVM中一块较小的内存区域，保存着当前线程执行的虚拟机字节码指令的内存地址。Java多线程的实现，其实是通过线程间的轮流切换并分配处理器执行时间的方式来实现的，在任何时刻，处理器都只会执行一个线程中的指令。在多线程场景下，为了保证线程切换回来后，还能恢复到原先状态，找到原先执行的指令，所以每个线程都会设立一个程序计数器，并且各个线程之间不会互相影响，程序计数器为”线程私有”的内存区域。 如果当前线程正在执行Java方法，则程序计数器保存的是虚拟机字节码的内存地址，如果正在执行的是Native方法（非Java方法，JVM底层有许多非Java编写的函数实现），计数器则为空。程序计数器是唯一一个在Java规范中没有规定任何OutOfMemory场景的区域。 java栈java栈也称为虚拟机栈，java栈是java方法执行的内存模型。 Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。讲到这里，大家就应该会明白为什么 在 使用 递归方法的时候容易导致栈内存溢出的现象了以及为什么栈区的空间不用程序员去管理了（当然在Java中，程序员基本不用关系到内存分配和释放的事情，因为Java有自己的垃圾回收机制），这部分空间的分配和释放都是由系统自动实施的。对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。下图表示了一个Java栈的模型： 局部变量表，顾名思义，想必不用解释大家应该明白它的作用了吧。就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。 操作数栈，想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。 指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。 方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。 由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。 本地方法栈本地方法栈（Native Method Stack）和虚拟机栈的作用相似，不过虚拟机栈是为Java方法服务的，而本地方法栈是为Native方法服务的。本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。 堆Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。 方法区方法区（Method Area）是用于存储类结构信息的地方，包括常量池、静态变量、构造函数等类型信息，类型信息是由类加载器在类加载时从类文件中提取出来的。 方法区同样存在垃圾收集，因为用户通过自定义加载器加载的一些类同样会成为垃圾，JVM会回收一个未被引用类所占的空间，以使方法区的空间达到最小。 方法区中还存在着常量池，常量池包含着一些常量和符号引用（加载类的连接阶段中的解析过程会将符号引用转换为直接引用）。 方法区是线程共享的。 方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。 在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。 在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。 在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。","categories":[{"name":"技术书","slug":"技术书","permalink":"http://zhangbuzola.cn/categories/技术书/"}],"tags":[{"name":"深入理解java虚拟机","slug":"深入理解java虚拟机","permalink":"http://zhangbuzola.cn/tags/深入理解java虚拟机/"}]},{"title":"java基础学习之String类","slug":"javabase_String","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/10/24/javabase_String/","link":"","permalink":"http://zhangbuzola.cn/2017/10/24/javabase_String/","excerpt":"","text":"String类学习源码分析1234567891011121314151617181920public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; ........&#125; String是final类，就是说：String不能被继承,String中的成员也都是final。 上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; count) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; if (beginIndex &gt; endIndex) &#123; throw new StringIndexOutOfBoundsException(endIndex - beginIndex); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125;public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf);&#125;public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = count; int i = -1; char[] val = value; /* avoid getfield opcode */ int off = offset; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[off + i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0 ; j &lt; i ; j++) &#123; buf[j] = val[off+j]; &#125; while (i &lt; len) &#123; char c = val[off + i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(0, len, buf); &#125; &#125; return this;&#125; 从上面的三个方法可以看出，无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点：“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 字符串常量池我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串（这点对理解上面至关重要）。 Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 123String a = &quot;chenssy&quot;;String b = &quot;chenssy&quot;;String c = new String(&quot;chenssy&quot;); new关键字一定会产生一个对象chenssy（注意这个chenssy和上面的chenssy不同），同时这个对象是存储在堆中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。但是在Java中根本就不存在两个完全一模一样的字符串对象。故堆中的chenssy应该是引用字符串常量池中chenssy。所以c、chenssy、池chenssy的关系应该是：c—&gt;chenssy—&gt;池chenssy。整个关系如下： 虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String c = new String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。 https://www.cnblogs.com/xiaoxi/p/6036701.html String StringBuilder StringBufferStringBufferStringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。 其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。 同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。 在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法： append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。 insert：该类方法主要是在StringBuffer对象中插入内容。 delete：该类方法主要用于移除StringBuffer对象中的内容。 StringBuilderStringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。 上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。 正确使用String、StringBuffer、StringBuilder这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。 在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。 但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如： 12String name = ”I ” + ”am ” + ”chenssy ” ;StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”); 对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。 对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）： String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。 StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。 StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。 String内容不可变，StringBuffer和StringBuilder内容可变； StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用）； 如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之final关键字","slug":"java基础之final","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2017/10/23/java基础之final/","link":"","permalink":"http://zhangbuzola.cn/2017/10/23/java基础之final/","excerpt":"","text":"final 作用修饰数据，方法，类 final 数据不改变的编译时常量 在运行的时候被初始化的值，而你不希望它被改变 final 方法不能被其他类继承 不会被覆盖 类的private方法会隐式地被指定为final方法。 父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。 12345678910public class Custom extends Person&#123; public void method1()&#123; System.out.println(&quot;Person&apos;s method1....&quot;); &#125; // Cannot override the final method from person：子类不能覆盖父类的final方法 // public void method2()&#123; // System.out.println(&quot;Person&apos;s method2...&quot;); // &#125; &#125; final 类不能继承，final类中的方法都隐式指定为final final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 final参数在实际应用中，我们除了可以用final修饰成员变量、成员方法、类，还可以修饰参数、若某个参数被final修饰了，则代表了该参数是不可改变的。 如果在方法中我们修改了该参数，则编译器会提示你：The final local variable i cannot be assigned. It must be blank and not using a compound assignment。 12345678910111213141516171819202122232425public class Custom &#123; public void test(final int i)&#123; //i++; ---final参数不可改变 System.out.println(i); &#125; public void test(final Person p)&#123; //p = new Person(); --final参数不可变 p.setName(&quot;chenssy&quot;); &#125; &#125;``` # final数据这里只阐述一点就是：不要以为某些数据是final就可以在编译期知道其值，通过final_03我们就知道了，在这里是使用随机数其进行初始化，他要在运行期才能知道其值。有时候数据的恒定不变是很有用的，它能够减轻系统运行时的负担。对于这些恒定不变的数据我可以叫做“常量”。“常量”主要应用与以下两个地方：- 编译期常量，永远不可改变。- 运行期初始化时，我们希望它不会被改变。对于编译期常量，它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可更改的，编译期可以将它代入到任何用到它的计算式中，也就是说可以在编译期执行计算式。当然对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化。有些变量，我们希望它可以根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。对于运行期常量，它既可是基本数据类型，也可是引用数据类型。基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。 public class Person { private String name; Person(String name){ this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } public class FinalTest { private final String final_01 = “chenssy”; //编译期常量，必须要进行初始化，且不可更改 private final String final_02; //构造器常量，在实例化一个对象时被初始化 private static Random random = new Random(); private final int final_03 = random.nextInt(50); //使用随机数来进行初始化 //引用 public final Person final_04 = new Person(&quot;chen_ssy&quot;); //final指向引用数据类型 FinalTest(String final_02){ this.final_02 = final_02; } public String toString(){ return &quot;final_01 = &quot; + final_01 +&quot; final_02 = &quot; + final_02 + &quot; final_03 = &quot; + final_03 + &quot; final_04 = &quot; + final_04.getName(); } public static void main(String[] args) { System.out.println(&quot;------------第一次创建对象------------&quot;); FinalTest final1 = new FinalTest(&quot;cm&quot;); System.out.println(final1); System.out.println(&quot;------------第二次创建对象------------&quot;); FinalTest final2 = new FinalTest(&quot;zj&quot;); System.out.println(final2); System.out.println(&quot;------------修改引用对象--------------&quot;); final2.final_04.setName(&quot;chenssy&quot;); System.out.println(final2); } } Output:————第一次创建对象————final_01 = chenssy final_02 = cm final_03 = 34 final_04 = chen_ssy————第二次创建对象————final_01 = chenssy final_02 = zj final_03 = 46 final_04 = chen_ssy————修改引用对象————–final_01 = chenssy final_02 = zj final_03 = 46 final_04 = chenssy` 参考https://blog.csdn.net/qq1028951741/article/details/53418852","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之重写和重载","slug":"Java基础之重写重载","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2017/10/23/Java基础之重写重载/","link":"","permalink":"http://zhangbuzola.cn/2017/10/23/Java基础之重写重载/","excerpt":"","text":"Overload 重载 方法名一样，参数列表不一样（参数类型，顺序，个数） 返回值不同不能区分重载方法 重载（overloading）：同一个类内，方法名相同，但具有不同的参数个数和类型。类自身的多态性的体现，编译时根据参数类型匹配确定调用哪个方法。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 Override重写（overriding，也称为方法重写）：子类不想原封不动地继承父类方法时用到。 由于有出现父类的任何地方均可有子类来代替的规则，所以重写的规则如下： 方法名和参数列表必须与父类的被重写方法相同，否则就是重载了。 返回类型必须与父类方法相同或范围更窄 抛出的异常必须与父类方法相同或异常更小 访问修饰符可以更广。 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 重写的注意事项： 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 总结方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之强制类型转换","slug":"java基础之强制类型转换","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2017/10/22/java基础之强制类型转换/","link":"","permalink":"http://zhangbuzola.cn/2017/10/22/java基础之强制类型转换/","excerpt":"","text":"强制类型转换在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。 在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。 当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。 举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它： 1Father father = new Son(); 在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！ 1Son son = (Son)father; 这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。 前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？ 当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如： 12Father father = new Father();Son son = (Son) father; 这个系统会抛出ClassCastException异常信息。 所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。 所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之static关键字","slug":"java基础之static","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2017/10/21/java基础之static/","link":"","permalink":"http://zhangbuzola.cn/2017/10/21/java基础之static/","excerpt":"","text":"static 关键字“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” 因为它不依附于任何对象，既然都没有对象，就谈不上this了 静态变量static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static成员变量的初始化顺序按照定义的顺序进行初始化。 static成员变量的初始化顺序按照定义的顺序进行初始化。 静态方法和非静态方法1234567891011121314151617class MyObject &#123; private static String str1 = &quot;staticproperty&quot;; private String str2 = &quot;property&quot;; public MyObject() &#123; &#125; public void print1() &#123; sysout(str1); sysout(str2); print2(); &#125; public static void print2() &#123; sysout(str1); sysout(str2); print1(); // 编译不成功 &#125;&#125; static静态代码块静态代码块用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次 123456789101112class Person&#123; private Date birthDate; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf(&quot;1946&quot;); Date endDate = Date.valueOf(&quot;1964&quot;); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好： 12345678910111213141516class Person&#123; private Date birthDate; private static Date startDate,endDate; static&#123; startDate = Date.valueOf(&quot;1946&quot;); endDate = Date.valueOf(&quot;1964&quot;); &#125; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125; &#125; 因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Test &#123; Person person = new Person(&quot;Test&quot;); static&#123; System.out.println(&quot;test static&quot;); &#125; public Test() &#123; System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new MyClass(); &#125;&#125; class Person&#123; static&#123; System.out.println(&quot;person static&quot;); &#125; public Person(String str) &#123; System.out.println(&quot;person &quot;+str); &#125;&#125; class MyClass extends Test &#123; Person person = new Person(&quot;MyClass&quot;); static&#123; System.out.println(&quot;myclass static&quot;); &#125; public MyClass() &#123; System.out.println(&quot;myclass constructor&quot;); &#125;&#125;// 输出test staticmyclass staticperson staticperson Testtest constructorperson MyClassmyclass constructor 在Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之基本类型","slug":"java基础之基本类型","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2017/10/20/java基础之基本类型/","link":"","permalink":"http://zhangbuzola.cn/2017/10/20/java基础之基本类型/","excerpt":"","text":"基本类型 所占的字节数： 1234567byte： 1个字节；char： 2个字节；short： 2个字节；int： 4个字节；long： 8个字节；float： 4个字节；（6位小数，指数是：10^-38~10^38; 范围：）double： 8个字节 基本类型的后缀： 123long ： l 或 Lfloat： f 或 F；double： d 或 D Java中，如果对整数不指定类型，默认时int类型，对小数不指定类型，默认是double类型。基本类型由小到大，可以自动转换，但是由大到小，则需要强制类型转换。 大小范围 byte byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子 12byte a = 100byte b = -50。 short short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子 12short s = 1000short r = -20000 int int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子 12int a = 100000int b = -200000 long long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子 12long a = 100000LLong b = -200000L “L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子 1float f1 = 234.5f double double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子 double d1 = 123.4123456789101112- booleanboolean数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；默认值是 false；例子 boolean one = true1234567891011- charchar类型是一个单一的 16 位 Unicode 字符；最小值是 \\u0000（即为0）；最大值是 \\uffff（即为65,535）；char 数据类型可以储存任何字符；例子 char letter = ‘A’;。123456789101112# 运算类型转换Int后面的字面量转换为比int类型低的类型变量``` public static void main(String[] args) &#123; int a = 8; //8是字面常量 byte b = 9; //9是字面常量 char c = 9+5;//常量表达式 short s = (short) (c+10); //变量表达式，需要显式强制转换 &#125; 上面的代码是经过编译的，是正确的。b是byte类型，但b=9不需要显式地手动强制转换，这是因为9是字面常量，是由JVM自动完成。 我们再来看一下c=9+5，c是char类型，9+5得到结果是int类型，但也不需要显式地手动强制转换。这是因为 9+5是常量表达式，所以在编译期间已经由编译器计算出结果了，即经过编译后，相当于 c=14，也是字面常量，所以可以隐式转换。同理，short s = (short) (c+10); 子所以不能隐式转换，就是因为表达式不是常量表达式，包含了变量，只能在运行期间完成，所以就要手动强制转换。 整形字面常量的大小超出目标类型所能表示的范围时，要手动强制类型转换。 12byte b = 128;//编译错误，128超出byte类型所能表示的范围byte c = (byte)128;//编译通过 对于传参数时，必须要显式地进行强制类型转换，明确转换的类型 编译器子所以这样要求，其实为了避免 方法重载出现的隐式转换 与 小类型自动转大类型 发生冲突。 1234567891011public static void main(String[] args) &#123; shortMethod(8);//编译错误 shortMethod((short)8); //编译通过 longMethod(8);//编译通过，因为这是小类型变成大类型，是不需要强制类型转换的&#125;public static void shortMethod(short c)&#123; System.out.println(c);&#125;public static void longMethod(short l)&#123; System.out.println(l);&#125; char类型的特殊情况 ：下面再细讲 复合运算符（+=、-=、*=、/=、%=）是可以将右边表达式的类型自动强制转换成左边的类型 123456public static void main(String[] args) &#123; int a = 8; short s = 5; s += a; s += a+5; &#125; s+=a、s+=a+5;的表达式计算结果都是int类型，但都不需要手动强制转换。其实，如果是反编译这段代码的class文件，你会发现s+=a;，其实是被编译器处理成了 1s=(short)(s+a) 也就是说对于所有的复合运算的隐式类型转换，其实是编译器自动添加类型转换的代码。 所以，相对于整形字面常量的隐式转换，复合运算符的隐式转换则没有任何限制因为前者只能在编译器期间发生，后者则是编译器实实在在的补全了类型转换的代码。 特殊的char类型char类型在基本类中是一个比较特殊的存在。这种特殊性在于char类型是一个无符号类型，所以char类型与其他基本类型不是子集与父集间的关系（其他类型都是有符号的类型）。也就是说，char类型与byte、short之间的转换都需要显式的强制类型转换（小类型自动转换成大类型失败）。 同时，由于char类型是一个无符号类型，所以对于整形字面常量的隐式转换的限制，不仅包括字面常量数值的大小不能超出2个字节，还包括字面常量数值不能为负数 123456789byte b = 2;char c = 2;//编译通过c = 100000000000;//编译不通过，超出char类型的范围char d = -2//字面常量为负数，编译不通过d = (char)-100;//编译通过char f = (char)b; //编译通过，必须显式的强制类型转换f = b;//编译不通过，不能隐式转换int i = c;//编译通过，可以不需要强制类型转换short s = (short) c;//编译通过，必须显式地强制类型转换 char类型是无符号的类型，这种无符号也体现在在其转换成int类型时，也就是说，char类型在扩展时，也是按无符号的方式扩展，扩展位填0。我们来看一个例子： 12345678public static void main(String[] args) &#123; short s = -5; char c = (char)s; System.out.println(c==s); //false System.out.println(&quot;(int)c = &quot;+(int)c); //转换成int类型，值为65531 System.out.println(&quot;(short)c = &quot;+(short)c); //-5 System.out.println(&quot;(int)s = &quot;+(int)s);//-5 &#125; 从上面的结果发现，char类型的c 与 short类s其实存储字节码内容是一样的，但由于前者是无符号，所以扩展成int类型的结果是 65531，而不是 -5。运算符==比较的就是他们扩展成int类型的值，所以为fasle。 对char类型的类型转换，可以总结成以下几点： char类型与byte、short的相互转换，都需要显式地强类型制转换。 对于数值是负数的，都需要进行显式地强制类型转换，特别是在整形字面常量的隐式转换中。 char类型转换成int、long类型是符合 小类型转大类型的规则，即无需要强制类型转换。 在Java中，一个运算结果的类型是与表达式中类型最高的相等，如： 1234char cc = 5;float dd = 0.6f+cc;//最高类型是float，运算结果是floatfloat ee = (float) (0.6d+cc);//最高类型是double，运算结果也是doubleint aa = 5+cc;//最高类型是int，运算结果也为int 但是，对于最高类型是byte、short、char的运算来说，则运行结果却不是最高类型，而是int类型。看下面的例子，c、d运算的最高类型都是char，但运算结果却是int，所以需要强制类型转换。 12345678byte b = 2;char a = 5;char c = (char) (a+b);//byte+char，运算结果的类型为int，需要强制类型转换int e = a+b;//编译通过，不需要强制类型转换，可以证明是intchar d = (char) (a+c);//char+char，short s1 = 5;short s2 = 6;short s3 =(short)s1+s2; 综上所述，java的运算结果的类型有两个性质： 运算结果的类型必须是int类型或int类型以上。 最高类型低于int类型的，运算结果都为int类型。否则，运算结果与表达式中最高类型一致。 浮点数类型浮点类型的介绍我们都知道，long类型转换成float类型是不需要强制类型转换的，也就是说相对于flaot类型，long类型是小类型，存储的范围要更小。然而flaot只占了4个字节，而long却占了8个字节，long类型的存储空间要比float类型大。这究竟是怎么一回事，我们接下来将细细分析。 浮点数使用 IEEE（电气和电子工程师协会）格式。 浮点数类型使用 符号位、指数、有效位数（尾数）来表示。要注意一下，尾数的最高 在java中，float 和 double 的结构如下： 类型 符号位 指数域 有效位域 float 1位 8位 23位 double 1位 11位 52位 符号位： 0为正，1为负； 指数域： 无符号的，float的偏移量为127（即float的指数范围是-126~127，），double 有效位域： 无符号的； 浮点类型的两个需要注意的地方 存储的小数的数值可能是模糊值 123456public static void main(String[] args) &#123; double d1 = 0.1; double d2 = 0.2; System.out.println(d1+d2 == 0.3); System.out.println(d1+d2);&#125; 运行结果： 12false 0.30000000000000004 上述的运算结果并不是错误。这是因为无法用二进制来准确地存储的0.3，这是一个无限循环的值，与10进制的1/3很相似。不只是0.3，很多小数都是无法准确地用浮点型表示，其实这是由 小数的十进制转成二进制的算法所决定的，十进制的小数要不断乘2，知道最后的结果为整数才是最后的二进制值，但这有可能怎么也得不到整数，所以最后得到的结果可能是一个 无限值 ，浮点型就无法表示了 但是对于 整数 来说，在浮点数的有效范围内，则都是精确的。同样，也是由于转换算法：十进制的整数转成二进制的算法是不断对2求余数，所以 不会存在无限值的情况； 浮点数的有效位及精度 浮点型所能表示的有效位是有限的，所以哪怕是整数，只要超出有效位数，也只能存储相似值，也就是该数值的最低有效位将会丢失,从而造精度丢失。float类型的二进制有效位是24位，对应十进制的7 ~ 8位数字；double类型的二进制53位，对应十进制的10 ~ 11位数字。 double、float类型 所能表示的范围比int、long类型表示的范围要广，也浮点类型属于大类型。但是，并不能完美地表整形，浮点类型的精度丢失会造成一些问题。 12345678910public static void main(String[] args) &#123; int a = 3000000; int b = 30000000; float f1 = a; float f2 = b; System.out.println(&quot;3000000==3000001 &quot;+(f1==f1+1)); System.out.println(&quot;30000000==30000001 &quot;+(f2==f2+1)); System.out.println(&quot;3000000的有效二进制位数：&quot;+ Integer.toBinaryString(a).length()); System.out.println(&quot;30000000的有效二进制位数：&quot;+ Integer.toBinaryString(b).length());&#125; 运行结果： 12343000000 == 3000001 false30000000 == 30000001 true3000000的有效二进制位数： 2230000000的有效二进制位数： 25 上面的例子很好体现了精度丢失所带来的后果：30000000==30000001 的比较居然为true了。而造成这种结果的原因就是 30000000的有效二进制位数是25位，超出了float所能表示的有效位24位，最后一位就被舍去，所以就造成在刚加的1也被舍去，因此30000000的加一操作前后的浮点型表示是一样的。 当然，并不是超出浮点型的有效位就不能精确表示，其实，主要看的是最高有效位与最低非0有效位之间的 “间隙”，如果间隙的在浮点型的有效位数内，自然可以精确表示，因为舍去的低有效位都是0，自然就无所谓了。如果上面的例子的浮点型用的是double就不会丢失精度了，因为double的精度是52位。 解决浮点型精度丢失的问题 浮点型带来精度丢失的问题是很让人头痛的，所以一般情况下，在程序中是不会使用float、double来存储比较大的数据。而商业计算往往要求结果精确。《Effactive Java》书中有一句话： float和double类型的主要设计目标是为了科学计算和工程计算JDK为此提供了两个高精度的大数操作类给我们：BigInteger、BigDecimal。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"mysql实战part3","slug":"2018-04-10 mysql_3","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2017/10/20/2018-04-10 mysql_3/","link":"","permalink":"http://zhangbuzola.cn/2017/10/20/2018-04-10 mysql_3/","excerpt":"","text":"1234567891011从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp_no进行忽略。CREATE TABLE IF NOT EXISTS &quot;titles&quot; (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);SELECT title, COUNT(DISTINCT emp_no) AS t FROM titlesGROUP BY title HAVING t &gt;= 2 1234567891011121314查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));select * from employees where emp_no % 2 == 1and last_name != &apos;Mary&apos;order by hire_date desc 12345678910111213141516171819统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg。CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));CREATE TABLE IF NOT EXISTS &quot;titles&quot; (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);select title, avg(salary)from titles left join salarieson titles.emp_no = salaries.emp_nowhere titles.to_date = &quot;9999-01-01&quot;and salaries.to_date = &quot;9999-01-01&quot;group by titles.title 12345678910111213获取当前（to_date=&apos;9999-01-01&apos;）薪水第二多的员工的emp_no以及其对应的薪水salaryCREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));select emp_no, salaryfrom salarieswhere to_date = &quot;9999-01-01&quot;order by salary desclimit 1,1 123456789101112131415161718192021查找当前薪水(to_date=&apos;9999-01-01&apos;)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order byCREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));select e.emp_no,max(s.salary) salary, e.last_name, e.first_namefrom employees e, salaries swhere s.to_date = &quot;9999-01-01&quot;and s.emp_no=e.emp_noand s.salary not in (select max(salary) from salaries where to_date = &quot;9999-01-01&quot;) 1234567891011121314151617181920212223查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));select a.last_name, a.first_name, c.dept_namefrom (employees as a left join dept_emp as b on a.emp_no=b.emp_no)left join departments as c on b.dept_no = c.dept_no 12345678910111213CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));select ((select salary from salaries where emp_no = &quot;10001&quot; order by to_date desc limit 1) - (select salary from salaries where emp_no = &quot;10001&quot;order by to_date asc limit 1)) growth","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangbuzola.cn/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangbuzola.cn/tags/MySQL/"}]},{"title":"java基础学习之进程优先级","slug":"java基础之线程优先级","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/10/19/java基础之线程优先级/","link":"","permalink":"http://zhangbuzola.cn/2017/10/19/java基础之线程优先级/","excerpt":"","text":"多线程的优先级，小伙伴们应该都或多或少的用过或者见到过，但是，对于具体用法可能还是有点不太清楚，这篇文章就对这个问题进行一个探讨，也欢迎小伙伴们一起留言讨论。 在不同的JVM中（JVM也算是一个操作系统），有着不同的CPU调度算法，对于大部分的JVM来说，优先级也是调度算法中的一个参数。 所以，线程优先级在一定程度上，对线程的调度执行顺序有所影响，但不能用于保证线程的执行顺序，因为优先级仅仅是其中一个参数而已，其他参数还可能有线程的等待时间、执行时间等。而且操作系统也可抗能可以完全不用理会JAVA线程对于优先级的设定。 线程优先级的范围一般是1~10，默认是5，但也有的JVM不是这个范围。所以，一般也尽量不要设置优先级为数字，可以使用Thread类的3个静态字段： 123static int MAX_PRIORITY ： 线程可以具有的最高优先级。static int MIN_PRIORITY ： 线程可以具有的最低优先级。static int NORM_PRIORITY ： 分配给线程的默认优先级。 同时。对于需要较多CPU时间的线程需要设置较低的优先级，这样可以确保处理器不会被独占。 一直在思考怎么设计，才能用简单明了的例子来证明优先级对线程的执行顺序有影响，最后为了严谨，还是不得不用到线程锁，可能对初学者来说，有点难理解。 不过，思路是很清晰的：就是如何让10个线程一起同时并发。首先让创建的10个线程依次进入对象锁的池中等待，然后当10个线程创建完后，main线程（主线程）同时唤醒这10个线程，于是10个线程同时一起并发竞争CPU，只计算5次，看看线程的结束的先后顺序。（注意：之所以线程的执行次数限制在5次，而不是无限，是因为会发生线程饥饿，高优先级线程占用着CPU，导致低优先级的线程无法被调度！！） 虽然线程的结束顺序不是完全按照优先级高低，但也基本是优先级高的线程结束的较快，被CPU调度的概率越大。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之线程与进程","slug":"java基础之多线程一","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/10/19/java基础之多线程一/","link":"","permalink":"http://zhangbuzola.cn/2017/10/19/java基础之多线程一/","excerpt":"","text":"进程进程定义 狭义定义：进程就是一段程序的执行过程。 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 简单的来讲进程的概念主要有两点： 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。 进程状态进程状态：进程有三个状态，就绪、运行和阻塞。 就绪状态其实就是获取了出cpu外的所有资源，只要处理器分配资源就可以马上执行。就绪状态有排队序列什么的，排队原则不再赘述。 运行态就是获得了处理器分配的资源，程序开始执行。 阻塞态，当程序条件不够时候，需要等待条件满足时候才能执行，如等待i/o操作时候，此刻的状态就叫阻塞态。 程序说起进程，就不得不说下程序。先看定义：程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程则是在处理机上的一次执行过程，它是一个动态的概念。这个不难理解，其实进程是包含程序的，进程的执行离不开程序，进程中的文本区域就是代码区，也就是程序。 线程通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。 多线程在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。 最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢。多线程的出现就是为了提高效率。 进程与线程的区别进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 优缺点线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"java基础学习之同步方法","slug":"java基础之同步方法","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/10/18/java基础之同步方法/","link":"","permalink":"http://zhangbuzola.cn/2017/10/18/java基础之同步方法/","excerpt":"","text":"参考https://www.cnblogs.com/upcwanghaibo/p/6535505.html 同步方法：使用Synchronized关键字修饰 同步方法：java每个对象都有一个内置锁，当用Synchronized关键字修饰方法的时候，内置锁会保护这个方法，在调用该方法的时候，需要获得内置锁，否则会处于阻塞状态 同步代码块 1synchronized(object)&#123;&#125; 即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步同步是一个高开销的操作，因此需要考虑锁的粒度 123456789101112131415161718192021222324252627282930313233343536package com.xhj.thread; /** * 线程同步的运用 * * @author XIEHEJUN * */ public class SynchronizedThread &#123; class Bank &#123; private int account = 100; public int getAccount() &#123; return account; &#125; /** * 用同步方法实现 * * @param money */ public synchronized void save(int money) &#123; account += money; &#125; /** * 用同步代码块实现 * * @param money */ public void save1(int money) &#123; synchronized (this) &#123; account += money; &#125; &#125; &#125; 同步是多线程中的重要概念。同步的使用可以保证在多线程运行的环境中，程序不会产生设计之外的错误结果。同步的实现方式有两种，同步方法和同步块，这两种方式都要用到synchronized关键字。 同步方法:给一个方法增加synchronized修饰符之后就可以使它成为同步方法，这个方法可以是静态方法和非静态方法，但是不能是抽象类的抽象方法，也不能是接口中的接口方法。下面代码是一个同步方法的示例： 123456public synchronized void aMethod() &#123; // do something &#125; public static synchronized void anotherMethod() &#123; // do something &#125; 线程在执行同步方法时是具有排它性的。当任意一个线程进入到一个对象的任意一个同步方法时，这个对象的所有同步方法都被锁定了，在此期间，其他任何线程都不能访问这个对象的任意一个同步方法，直到这个线程执行完它所调用的同步方法并从中退出，从而导致它释放了该对象的同步锁之后。在一个对象被某个线程锁定之后，其他线程是可以访问这个对象的所有非同步方法的。 同步块：同步块是通过锁定一个指定的对象，来对同步块中包含的代码进行同步；而同步方法是对这个方法块里的代码进行同步，而这种情况下锁定的对象就是同步方法所属的主体对象自身。 如果这个方法是静态同步方法呢？那么线程锁定的就不是这个类的对象了，也不是这个类自身，而是这个类对应的java.lang.Class类型的对象。同步方法和同步块之间的相互制约只限于同一个对象之间，所以静态同步方法只受它所属类的其它静态同步方法的制约，而跟这个类的实例（对象）没有关系。 如果一个对象既有同步方法，又有同步块，那么当其中任意一个同步方法或者同步块被某个线程执行时，这个对象就被锁定了，其他线程无法在此时访问这个对象的同步方法，也不能执行同步块。 wait与notify wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 使用特殊域变量(volatile)实现线程同步 volatile关键字为域变量的访问提供了一种免锁机制 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新 因此每次使用该域就要重新计算，而不是使用寄存器中的值 volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 使用重入锁实现线程同步在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。 ReenreantLock类的常用方法有： 123ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 例如：在上面例子的基础上，改写后的代码为: 1234567891011121314151617181920//只给出要修改的代码，其余代码与上同 class Bank &#123; private int account = 100; //需要声明这个锁 private Lock lock = new ReentrantLock(); public int getAccount() &#123; return account; &#125; //这里不再需要synchronized public void save(int money) &#123; lock.lock(); try&#123; account += money; &#125;finally&#123; lock.unlock(); &#125; &#125; ｝ 使用局部变量实现线程同步如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。 ThreadLocal 类的常用方法 1234ThreadLocal() : 创建一个线程本地变量 get() : 返回此线程局部变量的当前线程副本中的值 initialValue() : 返回此线程局部变量的当前线程的&quot;初始值&quot; set(T value) : 将此线程局部变量的当前线程副本中的值设置为value 12345678910111213141516//只改Bank类，其余代码与上同public class Bank&#123; //使用ThreadLocal类管理共享变量account private static ThreadLocal&lt;Integer&gt; account = new ThreadLocal&lt;Integer&gt;()&#123; @Override protected Integer initialValue()&#123; return 100; &#125; &#125;; public void save(int money)&#123; account.set(account.get()+money); &#125; public int getAccount()&#123; return account.get(); &#125; &#125; 注：ThreadLocal与同步机制 ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式 使用阻塞队列实现线程同步前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 本小节主要是使用LinkedBlockingQueue来实现线程的同步 LinkedBlockingQueue是一个基于已连接节点的，范围任意的blocking queue。 队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~LinkedBlockingQueue 类常用方法 LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue put(E e) : 在队尾添加一个元素，如果队列满则阻塞 size() : 返回队列中的元素个数 take() : 移除并返回队头元素，如果队列空则阻塞代码实例： 实现商家生产商品和买卖商品的同步 使用原子变量实现线程同步需要使用线程同步的根本原因在于对普通变量的操作不是原子的。 那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作即-这几种行为要么同时完成，要么都不完成。在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。其中AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。 AtomicInteger类常用方法：123AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicIntegeraddAddGet(int dalta) : 以原子方式将给定值与当前值相加get() : 获取当前值 class Bank { private AtomicInteger account = new AtomicInteger(100); public AtomicInteger getAccount() { return account; } public void save(int money) { account.addAndGet(money); } } 补充–原子操作主要有： 对于引用变量和大多数原始变量(long和double除外)的读写操作； 对于所有使用volatile修饰的变量(包括long和double)的读写操作。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"神经网络初探","slug":"NerualNeiwork_regression_keras","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2017/10/18/NerualNeiwork_regression_keras/","link":"","permalink":"http://zhangbuzola.cn/2017/10/18/NerualNeiwork_regression_keras/","excerpt":"","text":"人工神经网络和生物神经网络什么是神经网络我们这里所要谈论的神经网络不是动物或者人类的神经。。，而是为计算机量身定制的神经系统，计算机神经网络是一种模仿生物神经网络的计算机模型。神经网络由大量的人工神经元连接进行计算，大多数情况下，计算机神经网络能够在外界信息的基础上改变内部结构，是一种自己适应的逐渐的过程。现代神经网络是基于传统统计学建模的工具，常用来在输入和输出之间复杂的关系进行建模，或者来探索数据之间的模式。 神经网络是一种运算模型，有大量的节点或者神经元和其之间的联系构成组成，正如人类神经系统之间的神经元一样，是负责传递和加工信息的。神经元也可以被训练或者强化，形成固定的意识形态，对特殊的信息会有更强的反应。 目前的百度搜索和google系统的识别图片能力，都是得力于神经网路的不断发展。 上面就是对一个神经网路进行可视化。可以看出：一个复杂的神经网络大致组成主要有： input layer： 直接接受信息的神经层 output layer：是最初信息在神经元间经过传输，中转，分析，权衡而形成的输出结果，通过这一层输出的结果，我们就可以看出计算机对事物的认知。 hidden layer: 对信息的加工处理过程 具体来说，神经网络是怎么样被训练的，如果我们想让计算机能够准确判断猫或者狗狗，就需要很多数据，就需要准备上千万张具有标签的猫猫狗狗的图片，然后经过上千万的训练，训练时间随着计算机硬件的不断发展，处理时间也大大缩短，不需要担心训练费时的问题。 但是同样，给计算机一张猫猫的图片，计算机会认为是狗，这是一个错误的区分，但是这种错误的区分，可以通过反向传播方法，进行改进，这就是知错能改。在这样一次一次受教训的训练过程，计算机就能更加准确地判断图片中的事物了。 现在我们进一步看神经网络是怎样被训练的，在神经网络的每个神经元里都是一个激活函数，利用激活函数，当我们向计算机第一次传入一张猫咪的图片时，神经网络中众多的神经元只有部分神经元被激活，这时候，输出结果与原始label不符合，所有神经元的参数就会被调整，这时有的神经元会变得迟钝，有的神经元会变得敏感，这就说明了所有神经元的参数正在被改变，变得对图片中重要的特征信息敏感。从而能达到对预测结果的准确性。 梯度下降神经网络是当今最为流行的深度学习框架。他的基本原理也很简单，就是梯度下降机制。 学习机器学习的时候，都经常会看到： 具体相关的数学推导可以在详细做笔记。这里断一下。 视频中简单明了的介绍了梯度下降机制，帮助初学者理解。 神经网络的黑盒不黑视频中为了都说神经网络在做什么，对神经网络这一个黑盒的正确打开方式。当然这不是一个人类的复杂神经网络，这里指的是计算机中的神经网络。都说神经网络是一个黑盒，如果我们将一个不明物体放入黑盒，你会得到另一个和不明物体有某种联系的另一个信息。 一般来说，神经网络是一连串的神经层，将输入进行加工处理，再进行输出。加工过程就是黑盒。 feature, feature representation 神经网络就是一次一次特征转换的过程，从而能够让计算机识别出原始食物标签的系统。 手写识别例子： 输出是用三个信息来代表整张图片数字的像素特征。 迁移学习","categories":[{"name":"工具","slug":"工具","permalink":"http://zhangbuzola.cn/categories/工具/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://zhangbuzola.cn/tags/神经网络/"}]},{"title":"mysql实战part1","slug":"mysql_practice","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2017/10/15/mysql_practice/","link":"","permalink":"http://zhangbuzola.cn/2017/10/15/mysql_practice/","excerpt":"","text":"join12345678910111213查找各个部门当前(to_date=&apos;9999-01-01&apos;)领导当前薪水详情以及其对应部门编号dept_noCREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 12345select a.emp_no, a.salary, a.from_date, a.to_date, b.dept_nofrom salaries a left join dept_manager bon a.emp_no = b.emp_nowhere a.to_date = &apos;9999-01-01&apos;and b.to_date = &apos;9999-01-01&apos; 123456789101112131415查找所有已经分配部门的员工的last_name和first_nameCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 123select e.last_name, e.first_name, d.dept_nofrom employees e, dept_emp dwhere e.emp_no = d.emp_no","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangbuzola.cn/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangbuzola.cn/tags/MySQL/"}]},{"title":"java基础学习之构造函数","slug":"java基础之构造函数","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2017/10/15/java基础之构造函数/","link":"","permalink":"http://zhangbuzola.cn/2017/10/15/java基础之构造函数/","excerpt":"","text":"本篇博文主要是为新手、对java语言感兴趣的人和那些没有系统学习过java基础知识的人进行一个总结，在文章中对构造函数进行了较为详细的说明和讨论，也包含了我个人对于java面向对象中构造函数的一些看法。希望走在java学习道路上的同行者可以有一个较为清晰的认知和理解。当然仅为个人观点，水平有限，不足之处，还请大家多多指出，互相交流学习。 构造函数的概念很多java新手谈到构造函数就会犯晕，我们先来看看什么是构造函数。 首先，构造函数是函数的一种特殊形式，特殊在哪里？构造函数中不需要定义返回类型（void是无需返回值的意思，请注意区分两者），且构造函数的名称与所在的类名完全一致，其余的与函数的特性相同，可以带有参数列表，可以存在函数的重载现象。 构造函数的格式了解了构造函数的基本概念，现在来写一个构造函数，希望大家可以了解、记忆其格式，通过实例发现其与普通函数的不同之处。 `public class Demo{ private int num=0; //无参构造函数 Demo() { System.out.println(&quot;constractor_run&quot;); } //有参构造函数 Demo(int num) { System.out.println(&quot;constractor_args_run&quot;); } //普通成员函数 public void demoFunction() { System.out.println(&quot;function_run&quot;); } } 在这里要说明一点，如果在类中我们不声明构造函数，JVM会帮我们默认生成一个空参数的构造函数；如果在类中我们声明了带参数列表的构造函数，JVM就不会帮我们默认生成一个空参数的构造函数，我们想要使用空参数的构造函数就必须自己去显式的声明一个空参的构造函数。 构造函数的作用通过开头的介绍，构造函数的轮廓已经渐渐清晰，那么为什么会有构造函数呢？构造函数有什么作用？构造函数是面向对象编程思想所需求的，它的主要作用有以下两个： 创建对象。任何一个对象创建时，都需要初始化才能使用，所以任何类想要创建实例对象就必须具有构造函数。 对象初始化。构造函数可以对对象进行初始化，并且是给与之格式（参数列表）相符合的对象初始化，是具有一定针对性的初始化函数。 构造函数与普通函数的区别下面来详细的分析下构造函数与普通函数的区别，通过两者的一个对比，希望可以加深对构造函数的概念的理解。 格式不同： 构造函数不存在返回类型，函数名与所在类的类名一致； 普通函数有返回类型，函数名可以根据需求进行命名。 调用时期不同 构造函数在类的对象创建时就运行； 普通函数在对象调用时才会执行。 执行次数不同 一个对象创建后，其构造函数只执行一次，就是创建时执行； 一个对象创建后，其普通函数可以执行多次，取决于对象的调用次数。 构造函数的使用场景分析了那么多构造函数的信息，那么什么时候使用构造函数呢？既然构造函数是对新对象进行初始化，那么当开发中分析事物的时候，发现事物一出现就具备了某些特征时，就可以将其定义在构造函数中，这样方便快捷，也符合面向对象的编程思想。 构造函数在继承中的特点在继承中，子类创建的对象可以调用父类的公共方法和属性，那么子类会不会调用父类的构造函数呢？子类的构造函数与父类的构造函数有什么关系？子类的构造函数需要注意些什么问题呢？下面来解答这三个问题。 子类会不会调用父类的函数？ 子类继承父类，子类对象初始化时父类的构造函数也会执行，因为子类需要使用父类中的属性，子类需要知道是如何初始化的，所以子类初始化必然会调用父类的构造函数（除非父类没有属性，那么这个类的描述也太差了点，或者没有必要去创建这个类了）。 子类的构造函数与父类的构造函数有什么关系？ 子类的构造函数中默认的第一行有一条隐式语句super()，该语句会访问父类中的空参数构造函数，除非父类中没有空参数的构造函数，那么子类构造函数的第一行必须显式调用父类的构造函数，即super(int x,…) 。 子类的构造函数需要注意些什么问题呢？ 子类的构造函数中，super()语句代表调用了父类的构造函数；this()语句代表调用了子类自身的构造函数。需要注意的是，如果这两条语句显式写出来必须放在构造方法的第一行，而且这两条语句不能共存，一个构造函数中的第一行要么是this()要么是super()。 为什么在第一行？因为需要首先进行初始化。 为什么不能共存？因为this()代表的本类的其他构造函数，也会去调用super()，出现了this()就没有必要再出现super()了，重复调用没有意义。换言之，子类中至少有一个构造函数的开头为super()，当然可以隐式存在；也就是说至少有一个构造函数的开头不是this()。 构造函数的扩展以上的六条已经讲构造函数的概念、特点、使用等问题介绍的比较清楚，下面来介绍几点与构造函数相关的扩展性的小知识。 所有的类都有构造函数么？构造函数可以被私有化么？ 既然构造函数用于创建对象并且初始化对象，那么当一个类不需要创建对象时，就不需要定义构造函数，但是在java中，所有的类都拥有构造函数，只是有些类的构造函数对开发人员来说是隐藏不可见的，这一点与我们的预期并不相同，不过换个角度这也很好理解，因为java是面向对象的，我们创建类的目的就是为了创建对象或者创建其子类对象，所以没有构造函数的类（无法创建对象的类）并没有什么意义。 而对于第二个问题，一个类不想要外界创建其对象时，就可以将其构造函数私有化，本类中提供返回对象的方法，并且多数情况下提供的对象是唯一的，单例设计模式就是一个很好的例子，而当我们开发中需要保证对象唯一性的时候，往往就采取这种做法。 构造代码块与构造函数有什么相似和不同？构造代码块用一对“{}”表示，代码块位置没有具体的要求，但必须与类的成员同等级别，在括号的区域内，可以对所有该类的对象进行初始化，也就是说该类对象创建时都会执行到该代码块，并且其优先于构造函数执行。构造函数如前面提到的是具有针对性的，而构造代码块是作用于所有本类对象的。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"},{"name":"构造函数","slug":"构造函数","permalink":"http://zhangbuzola.cn/tags/构造函数/"}]},{"title":"python之多线程学习","slug":"python_thread","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2017/10/14/python_thread/","link":"","permalink":"http://zhangbuzola.cn/2017/10/14/python_thread/","excerpt":"","text":"python 基础之 多线程什么是多进程 多线程：我可以分配python分批量完成多个任务，并且能够在同一时间处理这些任务，大大提高了CPU的利用率及节省了计算机的计算时间，比如说：海量数据处理，如果利用计算机中的核去处理这些数据，可能会花上十秒左右的时间，但是如果利用多线程，将这批海量数据人为或者经过某种策略分割成几部分，我们将这几部分数据放在不同的线程中处理，这样，多线程同时运行，如此，处理的时间大大减少了。 添加线程1234567891011121314# -*- coding=utf-8 -*-# import threadingdef thread_job(): print(&quot;this is an added thread, number is %s&quot; % threading.current_thread())def main(): added_thread = threading.Thread(target = thread_job) added_thread.start() print(threading.active_count()) # 2 表示目前有两个线程被激活了 print(threading.enumerate()) print(threading.current_thread())if __name__ == &quot;__main__&quot;: main() join功能123456789101112131415161718192021222324252627282930313233# 无join# -*- coding=utf-8 -*-# import threadingimport timedef thread_job(): #print(&quot;this is an added thread, number is %s&quot; % threading.current_thread()) print(&quot;T1 start...\\n&quot;) for i in range(10): time.sleep(0.1) print(&quot;T1 finished...\\n&quot;)def main(): added_thread = threading.Thread(target = thread_job, name = &quot;T1&quot;) added_thread.start() print(&quot;all done...\\n&quot;) print(threading.active_count()) # 2 表示目前有两个线程被激活了 print(threading.enumerate()) print(threading.current_thread())if __name__ == &quot;__main__&quot;: main()--------------------------------------------T1 start...all done...2[&lt;Thread(T1, started 33208)&gt;, &lt;_MainThread(MainThread, started 55396)&gt;]&lt;_MainThread(MainThread, started 55396)&gt;T1 finished... 注意线程的执行顺序及最后输出结果的顺序 如果想线程都结束后再执行线程外的程序，这个时候就要用到join语句了。 12345678910111213141516171819202122232425262728# -*- coding=utf-8 -*-# import threadingimport timedef thread_job(): #print(&quot;this is an added thread, number is %s&quot; % threading.current_thread()) print(&quot;T1 start...\\n&quot;) for i in range(10): time.sleep(0.1) print(&quot;T1 finished...\\n&quot;)def main(): added_thread = threading.Thread(target = thread_job, name = &quot;T1&quot;) added_thread.start() added_thread.join() print(&quot;all done...\\n&quot;) print(threading.active_count()) # 2 表示目前有两个线程被激活了 print(threading.enumerate()) print(threading.current_thread())if __name__ == &quot;__main__&quot;: main()-----------------------------------T1 start...T1 finished...all done... 如果在添加线程任务的话 12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding=utf-8 -*-# import threadingimport timedef thread_job(): #print(&quot;this is an added thread, number is %s&quot; % threading.current_thread()) print(&quot;T1 start...\\n&quot;) for i in range(10): time.sleep(0.1) print(&quot;T1 finished...\\n&quot;)def T2_job(): print(&quot;T2 start....\\n&quot;) print(&quot;T2 finished....\\n&quot;)def main(): added_thread = threading.Thread(target = thread_job, name = &quot;T1&quot;) added_thread2 = threading.Thread(target = T2_job, name = &quot;T2&quot;) added_thread.start() added_thread2.start() #added_thread.join() print(&quot;all done...\\n&quot;) print(threading.active_count()) # 2 表示目前有两个线程被激活了 print(threading.enumerate()) print(threading.current_thread())if __name__ == &quot;__main__&quot;: main()-------------------------------------T1 start...T2 start....all done...T2 finished....3[&lt;Thread(T1, started 3000)&gt;, &lt;_MainThread(MainThread, started 37460)&gt;]&lt;_MainThread(MainThread, started 37460)&gt;T1 finished... 1234567891011121314151617181920212223242526272829303132333435363738394041# T2 join# -*- coding=utf-8 -*-# import threadingimport timedef thread_job(): #print(&quot;this is an added thread, number is %s&quot; % threading.current_thread()) print(&quot;T1 start...\\n&quot;) for i in range(10): time.sleep(0.1) print(&quot;T1 finished...\\n&quot;)def T2_job(): print(&quot;T2 start....\\n&quot;) print(&quot;T2 finished....\\n&quot;)def main(): added_thread = threading.Thread(target = thread_job, name = &quot;T1&quot;) added_thread2 = threading.Thread(target = T2_job, name = &quot;T2&quot;) added_thread.start() added_thread2.start() added_thread2.join() print(&quot;all done...\\n&quot;) print(threading.active_count()) # 2 表示目前有两个线程被激活了 print(threading.enumerate()) print(threading.current_thread())if __name__ == &quot;__main__&quot;: main()------------------------------------T1 start...T2 start....T2 finished....all done...2[&lt;_MainThread(MainThread, started 4072)&gt;, &lt;Thread(T1, started 16804)&gt;]&lt;_MainThread(MainThread, started 4072)&gt;T1 finished... Queue功能因为多线程涉及功能是没有返回值的，所以，需要将多线程的运算结果放在队列中，然后对每个线程的队列在主线程在依次出队列进行操作结果。 123456789101112131415161718192021222324252627def queue_job_cal(l, q): for i in range(len(l)): l[i] = l[i] ** 2 q.put(l) return ldef multiple_thread_queue(data): q = Queue.Queue() threads = [] # 所有线程列表 #data = [[1,2,3], [4,5,6], [7,8,9], [2,3,2]] for i in range(4): #4个线程 t = threading.Thread(target = queue_job_cal, args = (data[i], q)) t.start() threads.append(t) for thread in threads: thread.join() # 加载在主线程中，等待当前线程运行结束完执行其他 results = [] for result in range(4): results.append(q.get()) print(results)if __name__ == &quot;__main__&quot;: data = [[1,2,3], [4,5,6], [7,8,9], [2,3,2]] multiple_thread_queue(data)------------------------------------------------[[1, 4, 9], [16, 25, 36], [49, 64, 81], [4, 9, 4]] 不一定有效率多线程：一个任务分给了很多人去做，工作效率大大提高了。但是在python中，并不是平均分配任务，对于资源的利用及线程的运行是需要考量的。 python其实是在同一个时间只处理一个线程，这个时候会对共有资源上锁，只不过切换的速度够快，让用户有一种错觉，觉得多线程任务在同一时间处理了。 123456789101112131415161718192021222324252627282930313233343536373839404142# 比一定有效率# import threadingimport Queueimport copyimport timedef job(l, q): res = sum(l) q.put(res)def multithreading(l): q = Queue.Queue() threads = [] for i in range(4): t = threading.Thread(target=job, args=(copy.copy(l), q), name=&apos;T%i&apos; % i) t.start() threads.append(t) [t.join() for t in threads] total = 0 for _ in range(4): total += q.get() print(total)def normal(l): total = sum(l) print(total)if __name__ == &apos;__main__&apos;: l = list(range(1000000)) s_t = time.time() normal(l*4) print(&apos;normal: &apos;,time.time()-s_t) s_t = time.time() multithreading(l) print(&apos;multithreading: &apos;, time.time()-s_t)-----------------------------------------------------1999998000000(&apos;normal: &apos;, 0.2349998950958252)1999998000000(&apos;multithreading: &apos;, 0.22099995613098145) # 只是稍微快了一点 这个时间段是有三个线程在运算，但是实际上只有一个线程在run，在读写期间，GIL会将任务丢给thread2，依次，其他线程也这样得到时间片运行。为什么整任务的运行时间比没有多线程还是减少了呢，因为读写的时间节省下来，在读写时间上，时间片会交给其他线程运行。所以在小型任务中，可能运行时间并不会有明显的区别。但是在大数据处理的时候，多线程的又是就会显示出来。 多核的运算，不会受到GIL的影响 锁lock如果想让第一个线程处理完的结果拿去第二个线程去再次处理。这是对共有资源的处理才会涉及锁的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 对公共资源不上锁# Lock# def job1(): global Area for i in range(10): Area = Area + 1 print(&quot;job1:&quot;, Area)def job2(): global Area for i in range(10): Area = Area + 10 print(&quot;job2:&quot;, Area)if __name__ == &apos;__main__&apos;: Area = 0 t1 = threading.Thread(target=job1) t2 = threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join()--------------------------------------job1: 1job1: 2job1:job2: 1313job1:job2: 2424job1:job2: 3535job1:job2: 46job1: 4647job2:job1: 5858job2:job1: 6969job2:job1: 8080job2: 90job2: 100job2: 110 对公共资源加锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Lock# def job1(): global Area, lock lock.acquire() # 开始加锁 for i in range(10): Area = Area + 1 print &quot;job1:&quot;, Area lock.release() # 在释放锁之前，job2都不能读写Areadef job2(): global Area, lock lock.acquire() # 开始加锁 for i in range(10): Area = Area + 10 print &quot;job2:&quot;, Area lock.release() # 在释放锁之前，job1都不能读写Areaif __name__ == &apos;__main__&apos;: lock = threading.Lock() Area = 0 t1 = threading.Thread(target=job1) t2 = threading.Thread(target=job2) t1.start() t2.start() t1.join() t2.join()-------------------------------------------------job1: 1job1: 2job1: 3job1: 4job1: 5job1: 6job1: 7job1: 8job1: 9job1: 10job2: 20job2: 30job2: 40job2: 50job2: 60job2: 70job2: 80job2: 90job2: 100job2: 110","categories":[{"name":"Python","slug":"Python","permalink":"http://zhangbuzola.cn/categories/Python/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://zhangbuzola.cn/tags/多线程/"},{"name":"python","slug":"python","permalink":"http://zhangbuzola.cn/tags/python/"}]},{"title":"java基础学习之封装与继承","slug":"java基础之封装与继承","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/10/10/java基础之封装与继承/","link":"","permalink":"http://zhangbuzola.cn/2017/10/10/java基础之封装与继承/","excerpt":"","text":"封装概念封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。 对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。 好处使用封装有三大好处： 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员进行更精确的控制。 隐藏信息，实现细节。 首先我们先来看两个类：Husband.java、Wife.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Husband &#123; /* * 对属性的封装 * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 */ private String name ; private String sex ; private int age ; private Wife wife; /* * setter()、getter()是该对象对外开发的接口 */ public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setWife(Wife wife) &#123; this.wife = wife; &#125;&#125;public class Wife &#123; private String name; private int age; private String sex; private Husband husband; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setHusband(Husband husband) &#123; this.husband = husband; &#125; public Husband getHusband() &#123; return husband; &#125; &#125; 从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。 所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。 通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写： 123456public class Husband &#123; public String name ; public String sex ; public int age ; public Wife wife;&#125; 使用的话： 1234Husband husband = new Husband();husband.age = 30;husband.name = &quot;张三&quot;;husband.sex = &quot;男&quot;; //貌似有点儿多余 封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。 继承概念继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。 继承定义了类如何相互关联，共享特性。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。同时在使用继承时需要记住三句话： 子类拥有父类非private的属性和方法。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。 诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。对于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用super()即可。 对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。 通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。 但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。 缺点首先我们需要明确，继承存在如下缺陷： 父类变，子类就必须变。 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。 继承是一种强耦合关系。 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbuzola.cn/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://zhangbuzola.cn/tags/java基础/"}]},{"title":"mysql实战part2","slug":"2018-03-19 mysql_4","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2017/10/10/2018-03-19 mysql_4/","link":"","permalink":"http://zhangbuzola.cn/2017/10/10/2018-03-19 mysql_4/","excerpt":"","text":"牛客 sql学习实践表123456789CREATE TABLE &apos;employees&apos; ( &apos;emp_no&apos; INT(11) NOT NULL, &apos;birth_date&apos; DATE NOT NULL, &apos;first_name&apos; VARCHAR(14) NOT NULL, &apos;last_name&apos; VARCHAR(16) NOT NULL, &apos;gender&apos; CHAR(1) NOT NULL, &apos;hire_date&apos; DATE NOT NULL, PRIMARY KEY(&apos;emp_no&apos;)); 操作查找入职最晚的员工信息1SELECT * FROM EMPLOYEES WHERE hire_date = (SELECT MAX(hire_date) FROM employees); select 检索表中行列数据 where 之后接指定的搜索条件（知道sql语句中的一些函数）和order by 同时使用的时候，order by 紧随其后。 查找入职时间倒数第三的人员信息1SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2, 1; order by ‘column’ 对某列进行排序 desc 降序排序 limit &lt;位置偏移量&gt;, 行数 123456/*当没有指定位置偏移量时，只取4条时，可以这样写*/SELECT * FROM YourTableName LIMIT 4; /*当指定了位置偏移量时，从第3条起取4条时，可以这样写*//*因为索引是从0开始计数的，所以第3条对应的索引就是2*/SELECT * FROM YourTableName LIMIT 2,4; 三123456789101112131415161718查找各个部门当前(to_date=&apos;9999-01-01&apos;)领导当前薪水详情以及其对应部门编号dept_noCREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));select salaries.*, dept_manager.dept_no from salaries, dept_managerwhere salaries.emp_no = dept_manager.emp_noand salaries.to_date = &quot;9999-01-01&quot;and dept_manager.to_date = &quot;9999-01-01&quot; 1234567891011121314151617181920查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));select e.last_name, e.first_name, d.dept_nofrom employees eleft join dept_emp don e.emp_no = d.emp_no 1234567891011121314151617181920212223242526查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));方法一：利用 INNER JOIN 连接两张表SELECT e.emp_no, s.salary FROM employees AS e INNER JOIN salaries AS sON e.emp_no = s.emp_no AND e.hire_date = s.from_dateORDER BY e.emp_no DESC方法二：直接用逗号并列查询两张表SELECT e.emp_no, s.salary FROM employees AS e, salaries AS sWHERE e.emp_no = s.emp_no AND e.hire_date = s.from_dateORDER BY e.emp_no DESC 12345678910查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数tCREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));select emp_no, count(emp_no) as t from salariesgroup by emp_no having t &gt; 15 1234567891011找出所有员工当前(to_date=&apos;9999-01-01&apos;)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));select distinct(salary) from salarieswhere to_date = &quot;9999-01-01&quot;order by salary desc 12345678910111213141516171819获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=&apos;9999-01-01&apos;CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));select d.dept_no, d.emp_no,s.salaryfrom salaries as s inner join dept_manager as don d.emp_no = s.emp_noand d.to_date = &quot;9999-01-01&quot;and s.to_date = &quot;9999-01-01&quot; 12345678910111213141516171819获取所有非manager的员工emp_noCREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));select a.emp_nofrom employees awhere a.emp_no not in (select b.emp_no from dept_manager b) 12345678910111213141516171819获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=&apos;9999-01-01&apos;。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));select de.emp_no, dm.emp_no as manager_nofrom dept_emp de, dept_manager dmwhere de.to_date = &quot;9999-01-01&quot; and dm.to_date = &quot;9999-01-01&quot;and de.dept_no = dm.dept_no and dm.emp_no != de.emp_no 12345678910111213141516171819获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salaryCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));SELECT d.dept_no,d.emp_no,MAX(s.salary) AS salaryFROM salaries AS s inner join dept_emp AS dON d.emp_no=s.emp_noWHERE d.to_date=&apos;9999-01-01&apos; AND s.to_date=&apos;9999-01-01&apos;GROUP BY d.dept_no 123456789从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。CREATE TABLE IF NOT EXISTS &quot;titles&quot; (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);SELECT title, COUNT(emp_no) AS t FROM titlesGROUP BY title HAVING t &gt;= 2","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zhangbuzola.cn/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhangbuzola.cn/tags/MySQL/"}]}]}